{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aAAgBL,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,sOACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { DynamicServerError } from '../../client/components/hooks-server-context'\nimport type { FetchMetrics } from '../base-http'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isPrerendering?: boolean\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n  dynamicUsageErr?: DynamicServerError\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  revalidatedTags?: string[]\n  fetchMetrics?: FetchMetrics\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  requestEndedState?: { ended?: boolean }\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  dynamicIOEnabled: boolean\n  dev: boolean\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorageInstance","workAsyncStorage"],"mappings":"AAUA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workUnitAsyncStorageInstance"],"mappings":";;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,0OACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\n\ntype WorkUnitPhase = 'action' | 'render' | 'after'\n\ntype PhasePartial = {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n}\n\nexport type RequestStore = {\n  type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly implicitTags: string[]\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n} & PhasePartial\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern = {\n  type: 'prerender'\n  readonly implicitTags: string[]\n\n  /**\n   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n   */\n  readonly renderSignal: AbortSignal\n  /**\n   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n   * a sync API which requires the prerender to end immediately\n   */\n  readonly controller: AbortController\n\n  /**\n   * when not null this signal is used to track cache reads during prerendering and\n   * to await all cache reads completing before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  // DEV ONLY\n  // When used this flag informs certain APIs to skip logging because we're\n  // not part of the primary render path and are just prerendering to produce\n  // validation results\n  validating?: boolean\n} & PhasePartial\n\nexport type PrerenderStorePPR = {\n  type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  readonly dynamicTracking: null | DynamicTrackingState\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n} & PhasePartial\n\nexport type PrerenderStoreLegacy = {\n  type: 'prerender-legacy'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n} & PhasePartial\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\nexport type UseCacheStore = {\n  type: 'cache'\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this cache entry during the cache render.\n  revalidate: number // implicit revalidate time from inner caches / fetches\n  expire: number // server expiration time\n  stale: number // client expiration time\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  tags: null | string[]\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n} & PhasePartial\n\nexport type UnstableCacheStore = {\n  type: 'unstable-cache'\n} & PhasePartial\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n * Inside this context we should never expose any request or page specific information.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function getExpectedRequestStore(\n  callingExpression: string\n): RequestStore {\n  const workUnitStore = workUnitAsyncStorageInstance.getStore()\n  if (workUnitStore) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      // This should not happen because we should have checked it already.\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`\n      )\n    }\n    if (workUnitStore.type === 'cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n    } else if (workUnitStore.type === 'unstable-cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n    }\n  }\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  if (\n    workUnitStore.type === 'prerender' ||\n    workUnitStore.type === 'prerender-ppr'\n  ) {\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  if (\n    workUnitStore.type !== 'prerender-legacy' &&\n    workUnitStore.type !== 'cache' &&\n    workUnitStore.type !== 'unstable-cache'\n  ) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore.renderResumeDataCache\n    }\n\n    // We return the mutable resume data cache here as an immutable version of\n    // the cache as it can also be used for reading.\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getHmrRefreshHash(\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  return workUnitStore.type === 'cache'\n    ? workUnitStore.hmrRefreshHash\n    : workUnitStore.type === 'request'\n      ? workUnitStore.cookies.get('__next_hmr_refresh_hash__')?.value\n      : undefined\n}\n"],"names":["workUnitAsyncStorageInstance","workUnitAsyncStorage","getExpectedRequestStore","callingExpression","workUnitStore","getStore","type","Error","getPrerenderResumeDataCache","prerenderResumeDataCache","getRenderResumeDataCache","renderResumeDataCache","getHmrRefreshHash","hmrRefreshHash","cookies","get","value","undefined"],"mappings":"AAQA,qDAAqD;;;;;;;AACrD,SAASA,4BAA4B,QAAQ,0CAA0C;;;AAqLhF,SAASE,wBACdC,iBAAyB;IAEzB,MAAMC,0OAAgBJ,+BAAAA,CAA6BK,QAAQ;IAC3D,IAAID,eAAe;QACjB,IAAIA,cAAcE,IAAI,KAAK,WAAW;YACpC,OAAOF;QACT;QACA,IACEA,cAAcE,IAAI,KAAK,eACvBF,cAAcE,IAAI,KAAK,mBACvBF,cAAcE,IAAI,KAAK,oBACvB;YACA,oEAAoE;YACpE,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,iEAAiE,CAAC,GADrF,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,IAAIC,cAAcE,IAAI,KAAK,SAAS;YAClC,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,2JAA2J,CAAC,GAD/K,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,OAAO,IAAIC,cAAcE,IAAI,KAAK,kBAAkB;YAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,sKAAsK,CAAC,GAD1L,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IACA,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,CAAC,EAAE,EAAEJ,kBAAkB,iHAAiH,CAAC,GADrI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASK,4BACdJ,aAA4B;IAE5B,IACEA,cAAcE,IAAI,KAAK,eACvBF,cAAcE,IAAI,KAAK,iBACvB;QACA,OAAOF,cAAcK,wBAAwB;IAC/C;IAEA,OAAO;AACT;AAEO,SAASC,yBACdN,aAA4B;IAE5B,IACEA,cAAcE,IAAI,KAAK,sBACvBF,cAAcE,IAAI,KAAK,WACvBF,cAAcE,IAAI,KAAK,kBACvB;QACA,IAAIF,cAAcE,IAAI,KAAK,WAAW;YACpC,OAAOF,cAAcO,qBAAqB;QAC5C;QAEA,0EAA0E;QAC1E,gDAAgD;QAChD,OAAOP,cAAcK,wBAAwB;IAC/C;IAEA,OAAO;AACT;AAEO,SAASG,kBACdR,aAA4B;QAKtBA;IAHN,OAAOA,cAAcE,IAAI,KAAK,UAC1BF,cAAcS,cAAc,GAC5BT,cAAcE,IAAI,KAAK,YAAA,CACrBF,6BAAAA,cAAcU,OAAO,CAACC,GAAG,CAAC,4BAAA,KAAA,OAAA,KAAA,IAA1BX,2BAAwDY,KAAK,GAC7DC;AACR","ignoreList":[0]}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aAAgBL,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","afterTaskAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,2OACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorageInstance","afterTaskAsyncStorage"],"mappings":"AAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/strip-flight-headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'node:http'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\n\n/**\n * Removes the flight headers from the request.\n *\n * @param req the request to strip the headers from\n */\nexport function stripFlightHeaders(headers: IncomingHttpHeaders) {\n  for (const header of FLIGHT_HEADERS) {\n    delete headers[header.toLowerCase()]\n  }\n}\n"],"names":["FLIGHT_HEADERS","stripFlightHeaders","headers","header","toLowerCase"],"mappings":";;;AAEA,SAASA,cAAc,QAAQ,6CAA4C;;AAOpE,SAASC,mBAAmBC,OAA4B;IAC7D,KAAK,MAAMC,0MAAUH,iBAAAA,CAAgB;QACnC,OAAOE,OAAO,CAACC,OAAOC,WAAW,GAAG;IACtC;AACF","ignoreList":[0]}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workUnitAsyncStorageInstance"],"mappings":";;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,uOACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicExpression: undefined | string\n  syncDynamicErrorWithStack: null | Error\n  // Dev only\n  syncDynamicLogged?: boolean\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspendedDynamic: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasSyncDynamicErrors: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicExpression: undefined,\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspendedDynamic: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasSyncDynamicErrors: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n  return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      if (prerenderStore.validating === true) {\n        // We always log Request Access in dev at the point of calling the function\n        // So we mark the dynamic validation as not requiring it to be printed\n        dynamicTracking.syncDynamicLogged = true\n      }\n    }\n  }\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  if (\n    workStore &&\n    workStore.isStaticGeneration &&\n    workStore.fallbackRouteParams &&\n    workStore.fallbackRouteParams.size > 0\n  ) {\n    // There are fallback route params, we should track these as dynamic\n    // accesses.\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      // We're prerendering with dynamicIO or PPR or both\n      if (workUnitStore.type === 'prerender') {\n        // We are in a prerender with dynamicIO semantics\n        // We are going to hang here and never resolve. This will cause the currently\n        // rendering component to effectively be a dynamic hole\n        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // We're prerendering with PPR\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    dynamicValidation.hasSuspendedDynamic = true\n    return\n  } else if (\n    serverDynamic.syncDynamicErrorWithStack ||\n    clientDynamic.syncDynamicErrorWithStack\n  ) {\n    dynamicValidation.hasSyncDynamicErrors = true\n    return\n  } else {\n    const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport function throwIfDisallowedDynamic(\n  route: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): void {\n  let syncError: null | Error\n  let syncExpression: undefined | string\n  let syncLogged: boolean\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    syncError = serverDynamic.syncDynamicErrorWithStack\n    syncExpression = serverDynamic.syncDynamicExpression!\n    syncLogged = serverDynamic.syncDynamicLogged === true\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    syncError = clientDynamic.syncDynamicErrorWithStack\n    syncExpression = clientDynamic.syncDynamicExpression!\n    syncLogged = clientDynamic.syncDynamicLogged === true\n  } else {\n    syncError = null\n    syncExpression = undefined\n    syncLogged = false\n  }\n\n  if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n    if (!syncLogged) {\n      // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n      // the offending sync error is logged before we exit the build\n      console.error(syncError)\n    }\n    // The actual error should have been logged when the sync access ocurred\n    throw new StaticGenBailoutError()\n  }\n\n  const dynamicErrors = dynamicValidation.dynamicErrors\n  if (dynamicErrors.length) {\n    for (let i = 0; i < dynamicErrors.length; i++) {\n      console.error(dynamicErrors[i])\n    }\n\n    throw new StaticGenBailoutError()\n  }\n\n  if (!dynamicValidation.hasSuspendedDynamic) {\n    if (dynamicValidation.hasDynamicMetadata) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    } else if (dynamicValidation.hasDynamicViewport) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    }\n  }\n}\n"],"names":["React","DynamicServerError","StaticGenBailoutError","workUnitAsyncStorage","workAsyncStorage","makeHangingPromise","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","scheduleOnNextTick","hasPostpone","unstable_postpone","createDynamicTrackingState","isDebugDynamicAccesses","dynamicAccesses","syncDynamicExpression","undefined","syncDynamicErrorWithStack","createDynamicValidationState","hasSuspendedDynamic","hasDynamicMetadata","hasDynamicViewport","hasSyncDynamicErrors","dynamicErrors","getFirstDynamicReason","trackingState","expression","markCurrentScopeAsDynamic","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","route","postponeWithTracking","dynamicTracking","revalidate","err","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","trackFallbackParamAccessed","prerenderStore","getStore","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","_store","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","abortOnSynchronousPlatformIOAccess","errorWithStack","trackSynchronousPlatformIOAccessInDev","requestStore","prerenderPhase","abortAndThrowOnSynchronousRequestDataAccess","validating","syncDynamicLogged","trackSynchronousRequestDataAccessInDev","Postpone","assertPostpone","createPostponeReason","isDynamicPostpone","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","isPrerenderInterruptedError","accessedDynamicData","length","consumeDynamicAccess","serverDynamic","clientDynamic","formatDynamicAPIAccesses","filter","access","map","split","slice","line","join","createPostponedAbortSignal","AbortController","x","signal","createHangingInputAbortSignal","cacheSignal","inputReady","then","annotateDynamicAccess","useDynamicRouteParams","workStore","isStaticGeneration","fallbackRouteParams","size","use","renderSignal","hasSuspenseRegex","hasMetadataRegex","RegExp","hasViewportRegex","hasOutletRegex","trackAllowedDynamicAccess","componentStack","dynamicValidation","test","createErrorWithComponentStack","throwIfDisallowedDynamic","syncError","syncExpression","syncLogged","console","i"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 804, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-async-storage-instance.ts"],"sourcesContent":["import type { ActionAsyncStorage } from './action-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const actionAsyncStorageInstance: ActionAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","actionAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,wOACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n"],"names":["actionAsyncStorageInstance","actionAsyncStorage"],"mappings":"AAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/flight-render-result.ts"],"sourcesContent":["import { RSC_CONTENT_TYPE_HEADER } from '../../client/components/app-router-headers'\nimport RenderResult, { type RenderResultMetadata } from '../render-result'\n\n/**\n * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.\n */\nexport class FlightRenderResult extends RenderResult {\n  constructor(\n    response: string | ReadableStream<Uint8Array>,\n    metadata: RenderResultMetadata = {}\n  ) {\n    super(response, { contentType: RSC_CONTENT_TYPE_HEADER, metadata })\n  }\n}\n"],"names":["RSC_CONTENT_TYPE_HEADER","RenderResult","FlightRenderResult","constructor","response","metadata","contentType"],"mappings":";;;AAAA,SAASA,uBAAuB,QAAQ,6CAA4C;AACpF,OAAOC,kBAAiD,mBAAkB;;;AAKnE,MAAMC,qMAA2BD,UAAAA;IACtCE,YACEC,QAA6C,EAC7CC,WAAiC,CAAC,CAAC,CACnC;QACA,KAAK,CAACD,UAAU;YAAEE,6MAAaN,0BAAAA;YAAyBK;QAAS;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 879, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import type { ErrorInfo } from 'react'\n\nimport stringHash from 'next/dist/compiled/string-hash'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createFlightReactServerErrorHandler(\n  shouldFormatError: boolean,\n  onReactServerRenderError: (err: DigestedError) => void\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + err.stack || '').toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Record exception in an active span, if available.\n    const span = getTracer().getActiveScopeSpan()\n    if (span) {\n      span.recordException(err)\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      })\n    }\n\n    onReactServerRenderError(err)\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  silenceLogger: boolean,\n  onReactServerRenderError: undefined | ((err: DigestedError) => void)\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + (err.stack || '')).toString()\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (!silenceLogger) {\n        onReactServerRenderError?.(err)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  silenceLogger: boolean,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = stringHash(\n        err.message + (errorInfo?.componentStack || err.stack || '')\n      ).toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (\n        !silenceLogger &&\n        // HTML errors contain RSC errors as well, filter them out before reporting\n        isSSRError\n      ) {\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["stringHash","formatServerError","SpanStatusCode","getTracer","isAbortError","isBailoutToCSRError","isDynamicServerError","isNextRouterError","getProperError","createDigestWithErrorCode","getDigestForWellKnownError","error","digest","undefined","createFlightReactServerErrorHandler","shouldFormatError","onReactServerRenderError","thrownValue","toString","err","message","stack","span","getActiveScopeSpan","recordException","setStatus","code","ERROR","createHTMLReactServerErrorHandler","isNextExport","reactServerErrors","silenceLogger","has","set","includes","createHTMLErrorHandler","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","get","componentStack","isUserLandError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1058, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type { DynamicParamTypes, DynamicParamTypesShort } from './types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted': 'ci',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted': 'di',\n}\n\n/**\n * Shorten the dynamic param in order to make it smaller when transmitted to the browser.\n */\nexport function getShortDynamicParamType(\n  type: DynamicParamTypes\n): DynamicParamTypesShort {\n  const short = dynamicParamTypes[type]\n  if (!short) {\n    throw new Error('Unknown dynamic param type')\n  }\n  return short\n}\n"],"names":["dynamicParamTypes","catchall","dynamic","getShortDynamicParamType","type","short","Error"],"mappings":";;;;AAEO,MAAMA,oBAGT;IACFC,UAAU;IACV,wBAAwB;IACxB,qBAAqB;IACrBC,SAAS;IACT,uBAAuB;AACzB,EAAC;AAKM,SAASC,yBACdC,IAAuB;IAEvB,MAAMC,QAAQL,iBAAiB,CAACI,KAAK;IACrC,IAAI,CAACC,OAAO;QACV,MAAM,OAAA,cAAuC,CAAvC,IAAIC,MAAM,+BAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAsC;IAC9C;IACA,OAAOD;AACT","ignoreList":[0]}},
    {"offset": {"line": 1086, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-segment-param.tsx"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\nimport type { DynamicParamTypes } from './types'\n\n/**\n * Parse dynamic route segment to type of parameter\n */\nexport function getSegmentParam(segment: string): {\n  param: string\n  type: DynamicParamTypes\n} | null {\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n    segment.startsWith(marker)\n  )\n\n  // if an interception marker is part of the path segment, we need to jump ahead\n  // to the relevant portion for param parsing\n  if (interceptionMarker) {\n    segment = segment.slice(interceptionMarker.length)\n  }\n\n  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n    return {\n      // TODO-APP: Optional catchall does not currently work with parallel routes,\n      // so for now aren't handling a potential interception marker.\n      type: 'optional-catchall',\n      param: segment.slice(5, -2),\n    }\n  }\n\n  if (segment.startsWith('[...') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'catchall-intercepted' : 'catchall',\n      param: segment.slice(4, -1),\n    }\n  }\n\n  if (segment.startsWith('[') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'dynamic-intercepted' : 'dynamic',\n      param: segment.slice(1, -1),\n    }\n  }\n\n  return null\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","getSegmentParam","segment","interceptionMarker","find","marker","startsWith","slice","length","endsWith","type","param"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,oDAAmD;;AAMvF,SAASC,gBAAgBC,OAAe;IAI7C,MAAMC,+NAAqBH,6BAAAA,CAA2BI,IAAI,CAAC,CAACC,SAC1DH,QAAQI,UAAU,CAACD;IAGrB,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAIF,oBAAoB;QACtBD,UAAUA,QAAQK,KAAK,CAACJ,mBAAmBK,MAAM;IACnD;IAEA,IAAIN,QAAQI,UAAU,CAAC,YAAYJ,QAAQO,QAAQ,CAAC,OAAO;QACzD,OAAO;YACL,4EAA4E;YAC5E,8DAA8D;YAC9DC,MAAM;YACNC,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,WAAWJ,QAAQO,QAAQ,CAAC,MAAM;QACvD,OAAO;YACLC,MAAMP,qBAAqB,yBAAyB;YACpDQ,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,QAAQJ,QAAQO,QAAQ,CAAC,MAAM;QACpD,OAAO;YACLC,MAAMP,qBAAqB,wBAAwB;YACnDQ,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1126, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-script-nonce-from-header.tsx"],"sourcesContent":["import { ESCAPE_REGEX } from '../htmlescape'\n\nexport function getScriptNonceFromHeader(\n  cspHeaderValue: string\n): string | undefined {\n  const directives = cspHeaderValue\n    // Directives are split by ';'.\n    .split(';')\n    .map((directive) => directive.trim())\n\n  // First try to find the directive for the 'script-src', otherwise try to\n  // fallback to the 'default-src'.\n  const directive =\n    directives.find((dir) => dir.startsWith('script-src')) ||\n    directives.find((dir) => dir.startsWith('default-src'))\n\n  // If no directive could be found, then we're done.\n  if (!directive) {\n    return\n  }\n\n  // Extract the nonce from the directive\n  const nonce = directive\n    .split(' ')\n    // Remove the 'strict-src'/'default-src' string, this can't be the nonce.\n    .slice(1)\n    .map((source) => source.trim())\n    // Find the first source with the 'nonce-' prefix.\n    .find(\n      (source) =>\n        source.startsWith(\"'nonce-\") &&\n        source.length > 8 &&\n        source.endsWith(\"'\")\n    )\n    // Grab the nonce by trimming the 'nonce-' prefix.\n    ?.slice(7, -1)\n\n  // If we could't find the nonce, then we're done.\n  if (!nonce) {\n    return\n  }\n\n  // Don't accept the nonce value if it contains HTML escape characters.\n  // Technically, the spec requires a base64'd value, but this is just an\n  // extra layer.\n  if (ESCAPE_REGEX.test(nonce)) {\n    throw new Error(\n      'Nonce value from Content-Security-Policy contained HTML escape characters.\\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters'\n    )\n  }\n\n  return nonce\n}\n"],"names":["ESCAPE_REGEX","getScriptNonceFromHeader","cspHeaderValue","directive","directives","split","map","trim","find","dir","startsWith","nonce","slice","source","length","endsWith","test","Error"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,gBAAe;;AAErC,SAASC,yBACdC,cAAsB;QAmBRC;IAjBd,MAAMC,aAAaF,eACjB,+BAA+B;KAC9BG,KAAK,CAAC,KACNC,GAAG,CAAC,CAACH,YAAcA,UAAUI,IAAI;IAEpC,yEAAyE;IACzE,iCAAiC;IACjC,MAAMJ,YACJC,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC,kBACxCN,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC;IAE1C,mDAAmD;IACnD,IAAI,CAACP,WAAW;QACd;IACF;IAEA,uCAAuC;IACvC,MAAMQ,QAAAA,CAAQR,kCAAAA,UACXE,KAAK,CAAC,KACP,yEAAyE;KACxEO,KAAK,CAAC,GACNN,GAAG,CAAC,CAACO,SAAWA,OAAON,IAAI,IAC5B,kDAAkD;KACjDC,IAAI,CACH,CAACK,SACCA,OAAOH,UAAU,CAAC,cAClBG,OAAOC,MAAM,GAAG,KAChBD,OAAOE,QAAQ,CAAC,KAAA,KAAA,OAAA,KAAA,IAVRZ,gCAaVS,KAAK,CAAC,GAAG,CAAC;IAEd,iDAAiD;IACjD,IAAI,CAACD,OAAO;QACV;IACF;IAEA,sEAAsE;IACtE,uEAAuE;IACvE,eAAe;IACf,wKAAIX,eAAAA,CAAagB,IAAI,CAACL,QAAQ;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,gKADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAON;AACT","ignoreList":[0]}},
    {"offset": {"line": 1168, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { InstrumentationOnRequestError } from '../instrumentation/types'\nimport type { NextRequestHint } from '../web/adapter'\nimport type { BaseNextRequest } from '../base-http'\nimport type { IncomingMessage } from 'http'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nconst dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])\n\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n\nconst segmentSchema = s.union([\n  s.string(),\n  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n])\n\nexport type Segment = s.Infer<typeof segmentSchema>\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(\n    s.nullable(\n      s.union([\n        s.literal('refetch'),\n        s.literal('refresh'),\n        s.literal('inside-shared-layout'),\n      ])\n    )\n  ),\n  s.optional(s.boolean()),\n])\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation  inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case  during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?: 'refetch' | 'refresh' | 'inside-shared-layout' | null,\n  isRootLayout?: boolean,\n]\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  segment: Segment,\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type ServerOnInstrumentationRequestError = (\n  error: unknown,\n  // The request could be middleware, node server or web server request,\n  // we normalized them into an aligned format to `onRequestError` API later.\n  request: NextRequestHint | BaseNextRequest | IncomingMessage,\n  errorContext: Parameters<InstrumentationOnRequestError>[2]\n) => void | Promise<void>\n\nexport interface RenderOptsPartial {\n  previewProps: __ApiPreviewProps | undefined\n  err?: Error | null\n  dev?: boolean\n  basePath: string\n  trailingSlash: boolean\n  clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  supportsDynamicResponse: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  botType?: 'dom' | 'html' | undefined\n  serveStreamingMetadata?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  cacheLifeProfiles?: {\n    [profile: string]: import('../use-cache/cache-life').CacheLife\n  }\n  setIsrStatus?: (key: string, value: boolean | null) => void\n  isRevalidate?: boolean\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  onInstrumentationRequestError?: ServerOnInstrumentationRequestError\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  htmlLimitedBots: string | undefined\n  experimental: {\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    expireTime: number | undefined\n    clientTraceMetadata: string[] | undefined\n    dynamicIO: boolean\n    clientSegmentCache: boolean\n    inlineCss: boolean\n    authInterrupts: boolean\n  }\n  postponed?: string\n\n  /**\n   * Should wait for react stream allReady to resolve all suspense boundaries,\n   * in order to perform a full page render.\n   */\n  shouldWaitOnAllReady?: boolean\n\n  /**\n   * The resume data cache that was generated for this partially prerendered\n   * page during dev warmup.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n\n  /**\n   * When true, the page will be rendered using the static rendering to detect\n   * any dynamic API's that would have stopped the page from being fully\n   * statically generated.\n   */\n  isDebugDynamicAccesses?: boolean\n\n  /**\n   * The maximum length of the headers that are emitted by React and added to\n   * the response.\n   */\n  reactMaxHeadersLength: number | undefined\n\n  isStaticGeneration?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n\nexport type PreloadCallbacks = (() => void)[]\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** assetPrefix */\n  p: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** postponed */\n  s: boolean\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n"],"names":["s","dynamicParamTypesSchema","enums","segmentSchema","union","string","tuple","flightRouterStateSchema","record","lazy","optional","nullable","literal","boolean"],"mappings":";;;AAcA,OAAOA,OAAO,iCAAgC;;AAe9C,MAAMC,oMAA0BD,UAAAA,CAAEE,KAAK,CAAC;IAAC;IAAK;IAAM;IAAM;IAAK;CAAK;AAIpE,MAAMC,0LAAgBH,UAAAA,CAAEI,KAAK,CAAC;8KAC5BJ,UAAAA,CAAEK,MAAM;8KACRL,UAAAA,CAAEM,KAAK,CAAC;kLAACN,UAAAA,CAAEK,MAAM;kLAAIL,UAAAA,CAAEK,MAAM;QAAIJ;KAAwB;CAC1D;AAOM,MAAMM,oMAA2CP,UAAAA,CAAEM,KAAK,CAAC;IAC9DH;8KACAH,UAAAA,CAAEQ,MAAM,2KACNR,UAAAA,CAAEK,MAAM,8KACRL,UAAAA,CAAES,IAAI,CAAC,IAAMF;8KAEfP,UAAAA,CAAEU,QAAQ,2KAACV,UAAAA,CAAEW,QAAQ,2KAACX,UAAAA,CAAEK,MAAM;8KAC9BL,UAAAA,CAAEU,QAAQ,2KACRV,UAAAA,CAAEW,QAAQ,2KACRX,UAAAA,CAAEI,KAAK,CAAC;kLACNJ,UAAAA,CAAEY,OAAO,CAAC;kLACVZ,UAAAA,CAAEY,OAAO,CAAC;kLACVZ,UAAAA,CAAEY,OAAO,CAAC;KACX;8KAGLZ,UAAAA,CAAEU,QAAQ,2KAACV,UAAAA,CAAEa,OAAO;CACrB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1205, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/parse-and-validate-flight-router-state.tsx"],"sourcesContent":["import type { FlightRouterState } from './types'\nimport { flightRouterStateSchema } from './types'\nimport { assert } from 'next/dist/compiled/superstruct'\n\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[]\n): FlightRouterState\nexport function parseAndValidateFlightRouterState(\n  stateHeader: undefined\n): undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined {\n  if (typeof stateHeader === 'undefined') {\n    return undefined\n  }\n  if (Array.isArray(stateHeader)) {\n    throw new Error(\n      'Multiple router state headers were sent. This is not allowed.'\n    )\n  }\n\n  // We limit the size of the router state header to ~40kb. This is to prevent\n  // a malicious user from sending a very large header and slowing down the\n  // resolving of the router state.\n  // This is around 2,000 nested or parallel route segment states:\n  // '{\"children\":[\"\",{}]}'.length === 20.\n  if (stateHeader.length > 20 * 2000) {\n    throw new Error('The router state header was too large.')\n  }\n\n  try {\n    const state = JSON.parse(decodeURIComponent(stateHeader))\n    assert(state, flightRouterStateSchema)\n    return state\n  } catch {\n    throw new Error('The router state header was sent but could not be parsed.')\n  }\n}\n"],"names":["flightRouterStateSchema","assert","parseAndValidateFlightRouterState","stateHeader","undefined","Array","isArray","Error","length","state","JSON","parse","decodeURIComponent"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,UAAS;AACjD,SAASC,MAAM,QAAQ,iCAAgC;;;AAWhD,SAASC,kCACdC,WAA0C;IAE1C,IAAI,OAAOA,gBAAgB,aAAa;QACtC,OAAOC;IACT;IACA,IAAIC,MAAMC,OAAO,CAACH,cAAc;QAC9B,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4EAA4E;IAC5E,yEAAyE;IACzE,iCAAiC;IACjC,gEAAgE;IAChE,wCAAwC;IACxC,IAAIJ,YAAYK,MAAM,GAAG,KAAK,MAAM;QAClC,MAAM,OAAA,cAAmD,CAAnD,IAAID,MAAM,2CAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkD;IAC1D;IAEA,IAAI;QACF,MAAME,QAAQC,KAAKC,KAAK,CAACC,mBAAmBT;sLAC5CF,SAAAA,EAAOQ,uLAAOT,0BAAAA;QACd,OAAOS;IACT,EAAE,OAAM;QACN,MAAM,OAAA,cAAsE,CAAtE,IAAIF,MAAM,8DAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAqE;IAC7E;AACF","ignoreList":[0]}},
    {"offset": {"line": 1253, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-flight-router-state-from-loader-tree.ts"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\nimport type { FlightRouterState } from './types'\nimport type { GetDynamicParamFromSegment } from './app-render'\nimport { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\n\nexport function createFlightRouterStateFromLoaderTree(\n  [segment, parallelRoutes, { layout }]: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  searchParams: any,\n  rootLayoutIncluded = false\n): FlightRouterState {\n  const dynamicParam = getDynamicParamFromSegment(segment)\n  const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment\n\n  const segmentTree: FlightRouterState = [\n    addSearchParamsIfPageSegment(treeSegment, searchParams),\n    {},\n  ]\n\n  if (!rootLayoutIncluded && typeof layout !== 'undefined') {\n    rootLayoutIncluded = true\n    segmentTree[4] = true\n  }\n\n  segmentTree[1] = Object.keys(parallelRoutes).reduce(\n    (existingValue, currentValue) => {\n      existingValue[currentValue] = createFlightRouterStateFromLoaderTree(\n        parallelRoutes[currentValue],\n        getDynamicParamFromSegment,\n        searchParams,\n        rootLayoutIncluded\n      )\n      return existingValue\n    },\n    {} as FlightRouterState[1]\n  )\n\n  return segmentTree\n}\n"],"names":["addSearchParamsIfPageSegment","createFlightRouterStateFromLoaderTree","segment","parallelRoutes","layout","getDynamicParamFromSegment","searchParams","rootLayoutIncluded","dynamicParam","treeSegment","segmentTree","Object","keys","reduce","existingValue","currentValue"],"mappings":";;;AAGA,SAASA,4BAA4B,QAAQ,2BAA0B;;AAEhE,SAASC,sCACd,CAACC,SAASC,gBAAgB,EAAEC,MAAM,EAAE,CAAa,EACjDC,0BAAsD,EACtDC,YAAiB,EACjBC,qBAAqB,KAAK;IAE1B,MAAMC,eAAeH,2BAA2BH;IAChD,MAAMO,cAAcD,eAAeA,aAAaC,WAAW,GAAGP;IAE9D,MAAMQ,cAAiC;oLACrCV,+BAAAA,EAA6BS,aAAaH;QAC1C,CAAC;KACF;IAED,IAAI,CAACC,sBAAsB,OAAOH,WAAW,aAAa;QACxDG,qBAAqB;QACrBG,WAAW,CAAC,EAAE,GAAG;IACnB;IAEAA,WAAW,CAAC,EAAE,GAAGC,OAAOC,IAAI,CAACT,gBAAgBU,MAAM,CACjD,CAACC,eAAeC;QACdD,aAAa,CAACC,aAAa,GAAGd,sCAC5BE,cAAc,CAACY,aAAa,EAC5BV,4BACAC,cACAC;QAEF,OAAOO;IACT,GACA,CAAC;IAGH,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 1281, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/csrf-protection.ts"],"sourcesContent":["// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function\n// can be run from edge. This is a simple implementation that safely achieves the required functionality.\n// the goal is to match the functionality for remotePatterns as defined here -\n// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns\n// TODO - retrofit micromatch to work in edge and use that instead\nfunction matchWildcardDomain(domain: string, pattern: string) {\n  const domainParts = domain.split('.')\n  const patternParts = pattern.split('.')\n\n  if (patternParts.length < 1) {\n    // pattern is empty and therefore invalid to match against\n    return false\n  }\n\n  if (domainParts.length < patternParts.length) {\n    // domain has too few segments and thus cannot match\n    return false\n  }\n\n  let depth = 0\n  while (patternParts.length && depth++ < 2) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '':\n      case '*':\n      case '**': {\n        // invalid pattern. pattern segments must be non empty\n        // Additionally wildcards are only supported below the domain level\n        return false\n      }\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  while (patternParts.length) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '': {\n        // invalid pattern. pattern segments must be non empty\n        return false\n      }\n      case '*': {\n        // wildcard matches anything so we continue if the domain part is non-empty\n        if (domainPart) {\n          continue\n        } else {\n          return false\n        }\n      }\n      case '**': {\n        // if this is not the last item in the pattern the pattern is invalid\n        if (patternParts.length > 0) {\n          return false\n        }\n        // recursive wildcard matches anything so we terminate here if the domain part is non empty\n        return domainPart !== undefined\n      }\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  // We exhausted the pattern. If we also exhausted the domain we have a match\n  return domainParts.length === 0\n}\n\nexport const isCsrfOriginAllowed = (\n  originDomain: string,\n  allowedOrigins: string[] = []\n): boolean => {\n  return allowedOrigins.some(\n    (allowedOrigin) =>\n      allowedOrigin &&\n      (allowedOrigin === originDomain ||\n        matchWildcardDomain(originDomain, allowedOrigin))\n  )\n}\n"],"names":["matchWildcardDomain","domain","pattern","domainParts","split","patternParts","length","depth","patternPart","pop","domainPart","undefined","isCsrfOriginAllowed","originDomain","allowedOrigins","some","allowedOrigin"],"mappings":"AAAA,uHAAuH;AACvH,yGAAyG;AACzG,8EAA8E;AAC9E,4EAA4E;AAC5E,kEAAkE;;;;AAClE,SAASA,oBAAoBC,MAAc,EAAEC,OAAe;IAC1D,MAAMC,cAAcF,OAAOG,KAAK,CAAC;IACjC,MAAMC,eAAeH,QAAQE,KAAK,CAAC;IAEnC,IAAIC,aAAaC,MAAM,GAAG,GAAG;QAC3B,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAIH,YAAYG,MAAM,GAAGD,aAAaC,MAAM,EAAE;QAC5C,oDAAoD;QACpD,OAAO;IACT;IAEA,IAAIC,QAAQ;IACZ,MAAOF,aAAaC,MAAM,IAAIC,UAAU,EAAG;QACzC,MAAMC,cAAcH,aAAaI,GAAG;QACpC,MAAMC,aAAaP,YAAYM,GAAG;QAElC,OAAQD;YACN,KAAK;YACL,KAAK;YACL,KAAK;gBAAM;oBACT,sDAAsD;oBACtD,mEAAmE;oBACnE,OAAO;gBACT;YACA;gBAAS;oBACP,IAAIE,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,MAAOH,aAAaC,MAAM,CAAE;QAC1B,MAAME,cAAcH,aAAaI,GAAG;QACpC,MAAMC,aAAaP,YAAYM,GAAG;QAElC,OAAQD;YACN,KAAK;gBAAI;oBACP,sDAAsD;oBACtD,OAAO;gBACT;YACA,KAAK;gBAAK;oBACR,2EAA2E;oBAC3E,IAAIE,YAAY;wBACd;oBACF,OAAO;wBACL,OAAO;oBACT;gBACF;YACA,KAAK;gBAAM;oBACT,qEAAqE;oBACrE,IAAIL,aAAaC,MAAM,GAAG,GAAG;wBAC3B,OAAO;oBACT;oBACA,2FAA2F;oBAC3F,OAAOI,eAAeC;gBACxB;YACA;gBAAS;oBACP,IAAID,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,4EAA4E;IAC5E,OAAOL,YAAYG,MAAM,KAAK;AAChC;AAEO,MAAMM,sBAAsB,CACjCC,cACAC,iBAA2B,EAAE;IAE7B,OAAOA,eAAeC,IAAI,CACxB,CAACC,gBACCA,iBACCA,CAAAA,kBAAkBH,gBACjBb,oBAAoBa,cAAcG,cAAa;AAEvD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\n// This function creates a Flight-acceptable server module map proxy from our\n// Server Reference Manifest similar to our client module map.\n// This is because our manifest contains a lot of internal Next.js data that\n// are relevant to the runtime, workers, etc. that React doesn't need to know.\nexport function createServerModuleMap({\n  serverActionsManifest,\n}: {\n  serverActionsManifest: ActionManifest\n}) {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          serverActionsManifest[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ][id].workers\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string,\n  serverActionsManifest: ActionManifest\n) {\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n  const workerName = normalizeWorkerPageName(pageName)\n\n  // no workers, nothing to forward to\n  if (!workers) return\n\n  // if there is a worker for this page, no need to forward it.\n  if (workers[workerName]) {\n    return\n  }\n\n  // otherwise, grab the first worker that has a handler for this action id\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\n/**\n * The flight entry loader keys actions by bundlePath.\n * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n"],"names":["normalizeAppPath","pathHasPrefix","removePathPrefix","workAsyncStorage","createServerModuleMap","serverActionsManifest","Proxy","get","_","id","workers","process","env","NEXT_RUNTIME","workStore","getStore","workerEntry","normalizeWorkerPageName","page","Object","values","at","undefined","moduleId","async","name","chunks","selectWorkerForForwarding","actionId","pageName","workerName","denormalizeWorkerPageName","keys","bundlePath"],"mappings":";;;;AACA,SAASA,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,aAAa,QAAQ,gDAA+C;AAC7E,SAASC,gBAAgB,QAAQ,mDAAkD;AACnF,SAASC,gBAAgB,QAAQ,gCAA+B;;;;;;AAMzD,SAASC,sBAAsB,EACpCC,qBAAqB,EAGtB;IACC,OAAO,IAAIC,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;YACP,MAAMC,UACJL,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,UAAS,SAAS,qCAChD,CAACJ,GAAG,CAACC,OAAO;YAEf,MAAMI,8RAAYX,mBAAAA,CAAiBY,QAAQ;YAE3C,IAAIC;YAIJ,IAAIF,WAAW;gBACbE,cAAcN,OAAO,CAACO,wBAAwBH,UAAUI,IAAI,EAAE;YAChE,OAAO;gBACL,gEAAgE;gBAChE,kEAAkE;gBAClE,sEAAsE;gBACtE,qEAAqE;gBACrE,qEAAqE;gBACrE,qEAAqE;gBACrE,oCAAoC;gBACpCF,cAAcG,OAAOC,MAAM,CAACV,SAASW,EAAE,CAAC;YAC1C;YAEA,IAAI,CAACL,aAAa;gBAChB,OAAOM;YACT;YAEA,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGR;YAE5B,OAAO;gBAAEP,IAAIc;gBAAUE,MAAMhB;gBAAIiB,QAAQ,EAAE;gBAAEF;YAAM;QACrD;IACF;AAEJ;AAMO,SAASG,0BACdC,QAAgB,EAChBC,QAAgB,EAChBxB,qBAAqC;QAGnCA;IADF,MAAMK,UAAAA,CACJL,mCAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,UAAS,SAAS,qCAChD,CAACe,SAAS,KAAA,OAAA,KAAA,IAFXvB,iCAEaK,OAAO;IACtB,MAAMoB,aAAab,wBAAwBY;IAE3C,oCAAoC;IACpC,IAAI,CAACnB,SAAS;IAEd,6DAA6D;IAC7D,IAAIA,OAAO,CAACoB,WAAW,EAAE;QACvB;IACF;IAEA,yEAAyE;IACzE,OAAOC,0BAA0BZ,OAAOa,IAAI,CAACtB,QAAQ,CAAC,EAAE;AAC1D;AAEA;;;CAGC,GACD,SAASO,wBAAwBY,QAAgB;IAC/C,iNAAI5B,gBAAAA,EAAc4B,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;CAEC,GACD,SAASE,0BAA0BE,UAAkB;IACnD,2MAAOjC,mBAAAA,kNAAiBE,mBAAAA,EAAiB+B,YAAY;AACvD","ignoreList":[0]}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport { selectWorkerForForwarding } from './action-utils'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server.edge'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\nfunction formDataFromSearchQueryString(query: string) {\n  const searchParams = new URLSearchParams(query)\n  const formData = new FormData()\n  for (const [key, value] of searchParams) {\n    formData.append(key, value)\n  }\n  return formData\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nasync function addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  await Promise.all([\n    workStore.incrementalCache?.revalidateTag(workStore.revalidatedTags || []),\n    ...Object.values(workStore.pendingRevalidates || {}),\n    ...(workStore.pendingRevalidateWrites || []),\n  ])\n\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // To keep the header size small, we use a tuple of\n  // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]\n  // instead of a JSON object.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.revalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  res.setHeader(\n    'x-action-revalidated',\n    JSON.stringify([[], isTagRevalidated, isCookieRevalidated])\n  )\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string,\n  workStore: WorkStore\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string\n): URL | null {\n  if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {\n    // Make sure we are appending the basePath to relative URLS\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.revalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.revalidatedTags.join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\nexport function parseHostHeader(\n  headers: IncomingHttpHeaders,\n  originDomain?: string\n) {\n  const forwardedHostHeader = headers['x-forwarded-host']\n  const forwardedHostHeaderValue =\n    forwardedHostHeader && Array.isArray(forwardedHostHeader)\n      ? forwardedHostHeader[0]\n      : forwardedHostHeader?.split(',')?.[0]?.trim()\n  const hostHeader = headers['host']\n\n  if (originDomain) {\n    return forwardedHostHeaderValue === originDomain\n      ? {\n          type: HostType.XForwardedHost,\n          value: forwardedHostHeaderValue,\n        }\n      : hostHeader === originDomain\n        ? {\n            type: HostType.Host,\n            value: hostHeader,\n          }\n        : undefined\n  }\n\n  return forwardedHostHeaderValue\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeaderValue,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n}\n\ntype ServerModuleMap = Record<\n  string,\n  {\n    id: string\n    chunks: string[]\n    name: string\n  }\n>\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  serverModuleMap,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  serverModuleMap: ServerModuleMap\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n}): Promise<\n  | undefined\n  | {\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n> {\n  const contentType = req.headers['content-type']\n  const { serverActionsManifest, page } = ctx.renderOpts\n\n  const {\n    actionId,\n    isURLEncodedAction,\n    isMultipartAction,\n    isFetchAction,\n    isServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  // If it's not a Server Action, skip handling.\n  if (!isServerAction) {\n    return\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  const finalizeAndGenerateFlight: GenerateFlight = (...args) => {\n    // When we switch to the render phase, cookies() will return\n    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n    // We want the render to see any cookie writes that we performed during the action,\n    // so we need to update the immutable cookies to reflect the changes.\n    synchronizeMutableCookies(requestStore)\n    requestStore.phase = 'render'\n    return generateFlight(...args)\n  }\n\n  requestStore.phase = 'action'\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originDomain =\n    typeof req.headers['origin'] === 'string'\n      ? new URL(req.headers['origin']).host\n      : undefined\n  const host = parseHostHeader(req.headers)\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        await Promise.all([\n          workStore.incrementalCache?.revalidateTag(\n            workStore.revalidatedTags || []\n          ),\n          ...Object.values(workStore.pendingRevalidates || {}),\n          ...(workStore.pendingRevalidateWrites || []),\n        ])\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // if the page was not revalidated, we can skip the rendering the flight tree\n            skipFlight: !workStore.pathWasRevalidated,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  let boundActionArguments: unknown[] = []\n\n  const { actionAsyncStorage } = ComponentMod\n\n  let actionResult: RenderResult | undefined\n  let formState: any | undefined\n  let actionModId: string | undefined\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(\n      actionId,\n      page,\n      serverActionsManifest\n    )\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath,\n          workStore\n        ),\n      }\n    }\n  }\n\n  try {\n    await actionAsyncStorage.run({ isAction: true }, async () => {\n      if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' &&\n        isWebNextRequest(req)\n      ) {\n        if (!req.body) {\n          throw new Error('invariant: Missing request body.')\n        }\n\n        // TODO: add body limit\n\n        // Use react-server-dom-webpack/server.edge\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeAction,\n          decodeFormState,\n        } = ComponentMod\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        if (isMultipartAction) {\n          // TODO-APP: Add streaming support\n          const formData = await req.request.formData()\n          if (isFetchAction) {\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              const actionReturnedState = await workUnitAsyncStorage.run(\n                requestStore,\n                action\n              )\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n\n              requestStore.phase = 'render'\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          const reader = req.body.getReader()\n          while (true) {\n            const { done, value } = await reader.read()\n            if (done) {\n              break\n            }\n\n            chunks.push(value)\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        isNodeNextRequest(req)\n      ) {\n        // Use react-server-dom-webpack/server.node which supports streaming\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeReplyFromBusboy,\n          decodeAction,\n          decodeFormState,\n        } = require(\n          `./react-server.node`\n        ) as typeof import('./react-server.node')\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        const { Transform } =\n          require('node:stream') as typeof import('node:stream')\n\n        const defaultBodySizeLimit = '1 MB'\n        const bodySizeLimit =\n          serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n        const bodySizeLimitBytes =\n          bodySizeLimit !== defaultBodySizeLimit\n            ? (\n                require('next/dist/compiled/bytes') as typeof import('bytes')\n              ).parse(bodySizeLimit)\n            : 1024 * 1024 // 1 MB\n\n        let size = 0\n        const body = req.body.pipe(\n          new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } = require('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\n                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n        )\n\n        if (isMultipartAction) {\n          if (isFetchAction) {\n            const busboy = (require('busboy') as typeof import('busboy'))({\n              defParamCharset: 'utf8',\n              headers: req.headers,\n              limits: { fieldSize: bodySizeLimitBytes },\n            })\n\n            body.pipe(busboy)\n\n            boundActionArguments = await decodeReplyFromBusboy(\n              busboy,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            // React doesn't yet publish a busboy version of decodeAction\n            // so we polyfill the parsing of FormData.\n            const fakeRequest = new Request('http://localhost', {\n              method: 'POST',\n              // @ts-expect-error\n              headers: { 'Content-Type': contentType },\n              body: new ReadableStream({\n                start: (controller) => {\n                  body.on('data', (chunk) => {\n                    controller.enqueue(new Uint8Array(chunk))\n                  })\n                  body.on('end', () => {\n                    controller.close()\n                  })\n                  body.on('error', (err) => {\n                    controller.error(err)\n                  })\n                },\n              }),\n              duplex: 'half',\n            })\n            const formData = await fakeRequest.formData()\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              const actionReturnedState = await workUnitAsyncStorage.run(\n                requestStore,\n                action\n              )\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n\n              requestStore.phase = 'render'\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          for await (const chunk of req.body) {\n            chunks.push(Buffer.from(chunk))\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else {\n        throw new Error('Invariant: Unknown request type.')\n      }\n\n      // actions.js\n      // app/page.js\n      //   action worker1\n      //     appRender1\n\n      // app/foo/page.js\n      //   action worker2\n      //     appRender\n\n      // / -> fire action -> POST / -> appRender1 -> modId for the action file\n      // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n      try {\n        actionModId =\n          actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n      } catch (err) {\n        if (actionId !== null) {\n          console.error(err)\n        }\n        return {\n          type: 'not-found',\n        }\n      }\n\n      const actionMod = (await ComponentMod.__next_app__.require(\n        actionModId\n      )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n      const actionHandler =\n        actionMod[\n          // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n          actionId!\n        ]\n\n      const returnVal = await workUnitAsyncStorage.run(requestStore, () =>\n        actionHandler.apply(null, boundActionArguments)\n      )\n\n      // For form actions, we need to continue rendering the page.\n      if (isFetchAction) {\n        await addRevalidationHeader(res, {\n          workStore,\n          requestStore,\n        })\n\n        actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n          actionResult: Promise.resolve(returnVal),\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        })\n      }\n    })\n\n    return {\n      type: 'done',\n      result: actionResult,\n      formState,\n    }\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore\n          ),\n        }\n      }\n\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.fromStatic(''),\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            skipFlight: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n      return {\n        type: 'not-found',\n      }\n    }\n\n    if (isFetchAction) {\n      res.statusCode = 500\n      await Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ])\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      requestStore.phase = 'render'\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    throw err\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string {\n  try {\n    // if we're missing the action ID header, we can't do any further processing\n    if (!actionId) {\n      throw new Error(\"Invariant: Missing 'next-action' header.\")\n    }\n\n    const actionModId = serverModuleMap?.[actionId]?.id\n\n    if (!actionModId) {\n      throw new Error(\n        \"Invariant: Couldn't find action module ID from module map.\"\n      )\n    }\n\n    return actionModId\n  } catch (err) {\n    throw new Error(\n      `Failed to find Server Action \"${actionId}\". This request might be from an older or newer deployment. ${\n        err instanceof Error ? `Original error: ${err.message}` : ''\n      }\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n}\n"],"names":["RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RenderResult","FlightRenderResult","filterReqHeaders","actionsForbiddenHeaders","getModifiedCookieValues","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","getServerActionRequestMetadata","isCsrfOriginAllowed","warn","RequestCookies","ResponseCookies","HeadersAdapter","fromNodeOutgoingHttpHeaders","selectWorkerForForwarding","isNodeNextRequest","isWebNextRequest","RedirectStatusCode","synchronizeMutableCookies","workUnitAsyncStorage","formDataFromSearchQueryString","query","searchParams","URLSearchParams","formData","FormData","key","value","append","nodeHeadersToRecord","headers","record","Object","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","from","responseHeaders","getHeaders","responseCookies","mergedHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","Promise","all","incrementalCache","revalidateTag","revalidatedTags","values","pendingRevalidates","pendingRevalidateWrites","isTagRevalidated","length","isCookieRevalidated","mutableCookies","setHeader","JSON","stringify","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","requestProtocol","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","includes","cancel","err","console","error","fromStatic","getAppRelativeRedirectUrl","redirectUrl","parsedRedirectUrl","pathname","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","search","prerenderManifest","preview","previewModeId","limitUntrustedHeaderValueForLogs","slice","parseHostHeader","originDomain","forwardedHostHeader","forwardedHostHeaderValue","split","trim","hostHeader","type","handleAction","ComponentMod","serverModuleMap","generateFlight","serverActions","ctx","contentType","serverActionsManifest","page","renderOpts","actionId","isURLEncodedAction","isMultipartAction","isFetchAction","isServerAction","isStaticGeneration","temporaryReferences","finalizeAndGenerateFlight","args","phase","fetchCache","warning","warnBadServerActionRequest","allowedOrigins","statusCode","promise","reject","result","actionResult","skipFlight","pathWasRevalidated","boundActionArguments","actionAsyncStorage","formState","actionModId","actionWasForwarded","Boolean","forwardedWorker","run","isAction","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","request","action","actionReturnedState","getActionModIdOrError","chunks","reader","getReader","done","read","push","actionData","Buffer","concat","decodeReplyFromBusboy","require","Transform","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","pipe","transform","chunk","encoding","callback","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","fakeRequest","Request","ReadableStream","start","controller","on","enqueue","Uint8Array","close","actionMod","__next_app__","actionHandler","returnVal","apply","resolve","SeeOther","id","message"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2097, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/server-inserted-html.tsx"],"sourcesContent":["// Provider for the `useServerInsertedHTML` API to register callbacks to insert\n// elements into the HTML stream.\n\nimport React, { type JSX } from 'react'\nimport { ServerInsertedHTMLContext } from '../../shared/lib/server-inserted-html.shared-runtime'\n\nexport function createServerInsertedHTML() {\n  const serverInsertedHTMLCallbacks: (() => React.ReactNode)[] = []\n  const addInsertedHtml = (handler: () => React.ReactNode) => {\n    serverInsertedHTMLCallbacks.push(handler)\n  }\n\n  return {\n    ServerInsertedHTMLProvider({ children }: { children: JSX.Element }) {\n      return (\n        <ServerInsertedHTMLContext.Provider value={addInsertedHtml}>\n          {children}\n        </ServerInsertedHTMLContext.Provider>\n      )\n    },\n    renderServerInsertedHTML() {\n      return serverInsertedHTMLCallbacks.map((callback, index) => (\n        <React.Fragment key={'__next_server_inserted__' + index}>\n          {callback()}\n        </React.Fragment>\n      ))\n    },\n  }\n}\n"],"names":["React","ServerInsertedHTMLContext","createServerInsertedHTML","serverInsertedHTMLCallbacks","addInsertedHtml","handler","push","ServerInsertedHTMLProvider","children","Provider","value","renderServerInsertedHTML","map","callback","index","Fragment"],"mappings":"AAAA,+EAA+E;AAC/E,iCAAiC;;;;;AAEjC,OAAOA,WAAyB,QAAO;AACvC,SAASC,yBAAyB,QAAQ,uDAAsD;;;;AAEzF,SAASC;IACd,MAAMC,8BAAyD,EAAE;IACjE,MAAMC,kBAAkB,CAACC;QACvBF,4BAA4BG,IAAI,CAACD;IACnC;IAEA,OAAO;QACLE,4BAA2B,EAAEC,QAAQ,EAA6B;YAChE,OAAA,WAAA,sMACE,MAAA,2MAACP,4BAAAA,CAA0BQ,QAAQ,EAAA;gBAACC,OAAON;0BACxCI;;QAGP;QACAG;YACE,OAAOR,4BAA4BS,GAAG,CAAC,CAACC,UAAUC,QAAAA,WAAAA,sMAChD,MAAA,wLAACd,UAAAA,CAAMe,QAAQ,EAAA;8BACZF;mBADkB,6BAA6BC;QAItD;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2133, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/required-scripts.tsx"],"sourcesContent":["import { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { BuildManifest } from '../get-page-files'\n\nimport ReactDOM from 'react-dom'\n\nexport function getRequiredScripts(\n  buildManifest: BuildManifest,\n  assetPrefix: string,\n  crossOrigin: undefined | '' | 'anonymous' | 'use-credentials',\n  SRIManifest: undefined | Record<string, string>,\n  qs: string,\n  nonce: string | undefined,\n  pagePath: string\n): [\n  () => void,\n  { src: string; integrity?: string; crossOrigin?: string | undefined },\n] {\n  let preinitScripts: () => void\n  let preinitScriptCommands: string[] = []\n  const bootstrapScript: {\n    src: string\n    integrity?: string\n    crossOrigin?: string | undefined\n  } = {\n    src: '',\n    crossOrigin,\n  }\n\n  const files = (\n    buildManifest.rootMainFilesTree?.[pagePath] || buildManifest.rootMainFiles\n  ).map(encodeURIPath)\n  if (files.length === 0) {\n    throw new Error(\n      'Invariant: missing bootstrap script. This is a bug in Next.js'\n    )\n  }\n  if (SRIManifest) {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n    bootstrapScript.integrity = SRIManifest[files[0]]\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      const integrity = SRIManifest[files[i]]\n      preinitScriptCommands.push(src, integrity)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a double indexed array of src/integrity pairs\n      for (let i = 0; i < preinitScriptCommands.length; i += 2) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          integrity: preinitScriptCommands[i + 1],\n          crossOrigin,\n          nonce,\n        })\n      }\n    }\n  } else {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      preinitScriptCommands.push(src)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a singled indexed array of src values\n      for (let i = 0; i < preinitScriptCommands.length; i++) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          nonce,\n          crossOrigin,\n        })\n      }\n    }\n  }\n\n  return [preinitScripts, bootstrapScript]\n}\n"],"names":["encodeURIPath","ReactDOM","getRequiredScripts","buildManifest","assetPrefix","crossOrigin","SRIManifest","qs","nonce","pagePath","preinitScripts","preinitScriptCommands","bootstrapScript","src","files","rootMainFilesTree","rootMainFiles","map","length","Error","integrity","i","push","preinit","as"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;AAGhE,OAAOC,cAAc,YAAW;;;AAEzB,SAASC,mBACdC,aAA4B,EAC5BC,WAAmB,EACnBC,WAA6D,EAC7DC,WAA+C,EAC/CC,EAAU,EACVC,KAAyB,EACzBC,QAAgB;QAiBdN;IAZF,IAAIO;IACJ,IAAIC,wBAAkC,EAAE;IACxC,MAAMC,kBAIF;QACFC,KAAK;QACLR;IACF;IAEA,MAAMS,QACJX,CAAAA,CAAAA,CAAAA,mCAAAA,cAAcY,iBAAiB,KAAA,OAAA,KAAA,IAA/BZ,gCAAiC,CAACM,SAAS,KAAIN,cAAca,aAAY,EACzEC,GAAG,uLAACjB,gBAAAA;IACN,IAAIc,MAAMI,MAAM,KAAK,GAAG;QACtB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,IAAIb,aAAa;QACfM,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAC3DK,gBAAgBQ,SAAS,GAAGd,WAAW,CAACQ,KAAK,CAAC,EAAE,CAAC;QAEjD,IAAK,IAAIO,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjD,MAAMa,YAAYd,WAAW,CAACQ,KAAK,CAACO,EAAE,CAAC;YACvCV,sBAAsBW,IAAI,CAACT,KAAKO;QAClC;QACAV,iBAAiB;YACf,yEAAyE;YACzE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,KAAK,EAAG;oNACxDpB,UAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJJ,WAAWT,qBAAqB,CAACU,IAAI,EAAE;oBACvChB;oBACAG;gBACF;YACF;QACF;IACF,OAAO;QACLI,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAE3D,IAAK,IAAIc,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjDI,sBAAsBW,IAAI,CAACT;QAC7B;QACAH,iBAAiB;YACf,iEAAiE;YACjE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,IAAK;oNACrDpB,UAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJhB;oBACAH;gBACF;YACF;QACF;IACF;IAEA,OAAO;QAACK;QAAgBE;KAAgB;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 2203, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/make-get-server-inserted-html.tsx"],"sourcesContent":["import React, { type JSX } from 'react'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport type { ClientTraceDataEntry } from '../lib/trace/tracer'\n\nexport function makeGetServerInsertedHTML({\n  polyfills,\n  renderServerInsertedHTML,\n  serverCapturedErrors,\n  tracingMetadata,\n  basePath,\n}: {\n  polyfills: JSX.IntrinsicElements['script'][]\n  renderServerInsertedHTML: () => React.ReactNode\n  tracingMetadata: ClientTraceDataEntry[] | undefined\n  serverCapturedErrors: Array<unknown>\n  basePath: string\n}) {\n  let flushedErrorMetaTagsUntilIndex = 0\n  // flag for static content that only needs to be flushed once\n  let hasFlushedInitially = false\n\n  const polyfillTags = polyfills.map((polyfill) => {\n    return <script key={polyfill.src} {...polyfill} />\n  })\n\n  return async function getServerInsertedHTML() {\n    // Loop through all the errors that have been captured but not yet\n    // flushed.\n    const errorMetaTags = []\n    while (flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length) {\n      const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex]\n      flushedErrorMetaTagsUntilIndex++\n\n      if (isHTTPAccessFallbackError(error)) {\n        errorMetaTags.push(\n          <meta name=\"robots\" content=\"noindex\" key={error.digest} />,\n          process.env.NODE_ENV === 'development' ? (\n            <meta name=\"next-error\" content=\"not-found\" key=\"next-error\" />\n          ) : null\n        )\n      } else if (isRedirectError(error)) {\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(error),\n          basePath\n        )\n        const statusCode = getRedirectStatusCodeFromError(error)\n        const isPermanent =\n          statusCode === RedirectStatusCode.PermanentRedirect ? true : false\n        if (redirectUrl) {\n          errorMetaTags.push(\n            <meta\n              id=\"__next-page-redirect\"\n              httpEquiv=\"refresh\"\n              content={`${isPermanent ? 0 : 1};url=${redirectUrl}`}\n              key={error.digest}\n            />\n          )\n        }\n      }\n    }\n\n    const traceMetaTags = (tracingMetadata || []).map(\n      ({ key, value }, index) => (\n        <meta key={`next-trace-data-${index}`} name={key} content={value} />\n      )\n    )\n\n    const serverInsertedHTML = renderServerInsertedHTML()\n\n    // Skip React rendering if we know the content is empty.\n    if (\n      polyfillTags.length === 0 &&\n      traceMetaTags.length === 0 &&\n      errorMetaTags.length === 0 &&\n      Array.isArray(serverInsertedHTML) &&\n      serverInsertedHTML.length === 0\n    ) {\n      return ''\n    }\n\n    const stream = await renderToReadableStream(\n      <>\n        {\n          /* Insert the polyfills if they haven't been flushed yet. */\n          hasFlushedInitially ? null : polyfillTags\n        }\n        {serverInsertedHTML}\n        {hasFlushedInitially ? null : traceMetaTags}\n        {errorMetaTags}\n      </>,\n      {\n        // Larger chunk because this isn't sent over the network.\n        // Let's set it to 1MB.\n        progressiveChunkSize: 1024 * 1024,\n      }\n    )\n\n    hasFlushedInitially = true\n\n    // There's no need to wait for the stream to be ready\n    // e.g. calling `await stream.allReady` because `streamToString` will\n    // wait and decode the stream progressively with better parallelism.\n    return streamToString(stream)\n  }\n}\n"],"names":["React","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","renderToReadableStream","streamToString","RedirectStatusCode","addPathPrefix","makeGetServerInsertedHTML","polyfills","renderServerInsertedHTML","serverCapturedErrors","tracingMetadata","basePath","flushedErrorMetaTagsUntilIndex","hasFlushedInitially","polyfillTags","map","polyfill","script","src","getServerInsertedHTML","errorMetaTags","length","error","push","meta","name","content","digest","process","env","NODE_ENV","redirectUrl","statusCode","isPermanent","PermanentRedirect","id","httpEquiv","traceMetaTags","key","value","index","serverInsertedHTML","Array","isArray","stream","progressiveChunkSize"],"mappings":";;;;AAAA,OAAOA,WAAyB,QAAO;AACvC,SAASC,yBAAyB,QAAQ,oEAAmE;AAC7G,SACEC,uBAAuB,EACvBC,8BAA8B,QACzB,mCAAkC;AACzC,SAASC,eAAe,QAAQ,yCAAwC;AACxE,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SAASC,cAAc,QAAQ,0CAAyC;AACxE,SAASC,kBAAkB,QAAQ,+CAA8C;AACjF,SAASC,aAAa,QAAQ,gDAA+C;;;;;;;;;;AAGtE,SAASC,0BAA0B,EACxCC,SAAS,EACTC,wBAAwB,EACxBC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EAOT;IACC,IAAIC,iCAAiC;IACrC,6DAA6D;IAC7D,IAAIC,sBAAsB;IAE1B,MAAMC,eAAeP,UAAUQ,GAAG,CAAC,CAACC;QAClC,OAAA,WAAA,sMAAO,MAAA,EAACC,UAAAA;YAA2B,GAAGD,QAAQ;WAA1BA,SAASE,GAAG;IAClC;IAEA,OAAO,eAAeC;QACpB,kEAAkE;QAClE,WAAW;QACX,MAAMC,gBAAgB,EAAE;QACxB,MAAOR,iCAAiCH,qBAAqBY,MAAM,CAAE;YACnE,MAAMC,QAAQb,oBAAoB,CAACG,+BAA+B;YAClEA;YAEA,IAAId,gQAAAA,EAA0BwB,QAAQ;gBACpCF,cAAcG,IAAI,CAAA,WAAA,sMAChB,MAAA,EAACC,QAAAA;oBAAKC,MAAK;oBAASC,SAAQ;mBAAeJ,MAAMK,MAAM,GACvDC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAA,WAAA,sMACvB,MAAA,EAACN,QAAAA;oBAAKC,MAAK;oBAAaC,SAAQ;mBAAgB,gBAC9C;YAER,OAAO,IAAIzB,+MAAAA,EAAgBqB,QAAQ;gBACjC,MAAMS,2NAAc1B,gBAAAA,GAClBN,6MAAAA,EAAwBuB,QACxBX;gBAEF,MAAMqB,iMAAahC,iCAAAA,EAA+BsB;gBAClD,MAAMW,cACJD,gNAAe5B,sBAAAA,CAAmB8B,iBAAiB,GAAG,OAAO;gBAC/D,IAAIH,aAAa;oBACfX,cAAcG,IAAI,CAAA,WAAA,sMAChB,MAAA,EAACC,QAAAA;wBACCW,IAAG;wBACHC,WAAU;wBACVV,SAAS,GAAGO,cAAc,IAAI,EAAE,KAAK,EAAEF,aAAa;uBAC/CT,MAAMK,MAAM;gBAGvB;YACF;QACF;QAEA,MAAMU,gBAAiB3B,CAAAA,mBAAmB,EAAC,EAAGK,GAAG,CAC/C,CAAC,EAAEuB,GAAG,EAAEC,KAAK,EAAE,EAAEC,QAAAA,WAAAA,IACf,wMAAA,EAAChB,QAAAA;gBAAsCC,MAAMa;gBAAKZ,SAASa;eAAhD,CAAC,gBAAgB,EAAEC,OAAO;QAIzC,MAAMC,qBAAqBjC;QAE3B,wDAAwD;QACxD,IACEM,aAAaO,MAAM,KAAK,KACxBgB,cAAchB,MAAM,KAAK,KACzBD,cAAcC,MAAM,KAAK,KACzBqB,MAAMC,OAAO,CAACF,uBACdA,mBAAmBpB,MAAM,KAAK,GAC9B;YACA,OAAO;QACT;QAEA,MAAMuB,SAAS,6LAAM1C,yBAAAA,EAAAA,WAAAA,IACnB,yMAAA,EAAA,8LAAA,CAAA,WAAA,EAAA;;gBAEI,0DAA0D,GAC1DW,sBAAsB,OAAOC;gBAE9B2B;gBACA5B,sBAAsB,OAAOwB;gBAC7BjB;;YAEH;YACE,yDAAyD;YACzD,uBAAuB;YACvByB,sBAAsB,OAAO;QAC/B;QAGFhC,sBAAsB;QAEtB,qDAAqD;QACrD,qEAAqE;QACrE,oEAAoE;QACpE,wNAAOV,iBAAAA,EAAeyC;IACxB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2295, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-css-inlined-link-tags.tsx"],"sourcesContent":["import type {\n  ClientReferenceManifest,\n  CssResource,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get external stylesheet link hrefs based on server CSS manifest.\n */\nexport function getLinkAndScriptTags(\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  filePath: string,\n  injectedCSS: Set<string>,\n  injectedScripts: Set<string>,\n  collectNewImports?: boolean\n): { styles: CssResource[]; scripts: string[] } {\n  const filePathWithoutExt = filePath.replace(/\\.[^.]+$/, '')\n  const cssChunks = new Set<CssResource>()\n  const jsChunks = new Set<string>()\n\n  const entryCSSFiles =\n    clientReferenceManifest.entryCSSFiles[filePathWithoutExt]\n  const entryJSFiles =\n    clientReferenceManifest.entryJSFiles?.[filePathWithoutExt] ?? []\n\n  if (entryCSSFiles) {\n    for (const css of entryCSSFiles) {\n      if (!injectedCSS.has(css.path)) {\n        if (collectNewImports) {\n          injectedCSS.add(css.path)\n        }\n        cssChunks.add(css)\n      }\n    }\n  }\n\n  if (entryJSFiles) {\n    for (const file of entryJSFiles) {\n      if (!injectedScripts.has(file)) {\n        if (collectNewImports) {\n          injectedScripts.add(file)\n        }\n        jsChunks.add(file)\n      }\n    }\n  }\n\n  return { styles: [...cssChunks], scripts: [...jsChunks] }\n}\n"],"names":["getLinkAndScriptTags","clientReferenceManifest","filePath","injectedCSS","injectedScripts","collectNewImports","filePathWithoutExt","replace","cssChunks","Set","jsChunks","entryCSSFiles","entryJSFiles","css","has","path","add","file","styles","scripts"],"mappings":"AAMA;;CAEC,GACD;;;AAAO,SAASA,qBACdC,uBAA8D,EAC9DC,QAAgB,EAChBC,WAAwB,EACxBC,eAA4B,EAC5BC,iBAA2B;QASzBJ;IAPF,MAAMK,qBAAqBJ,SAASK,OAAO,CAAC,YAAY;IACxD,MAAMC,YAAY,IAAIC;IACtB,MAAMC,WAAW,IAAID;IAErB,MAAME,gBACJV,wBAAwBU,aAAa,CAACL,mBAAmB;IAC3D,MAAMM,eACJX,CAAAA,CAAAA,wCAAAA,wBAAwBW,YAAY,KAAA,OAAA,KAAA,IAApCX,qCAAsC,CAACK,mBAAmB,KAAI,EAAE;IAElE,IAAIK,eAAe;QACjB,KAAK,MAAME,OAAOF,cAAe;YAC/B,IAAI,CAACR,YAAYW,GAAG,CAACD,IAAIE,IAAI,GAAG;gBAC9B,IAAIV,mBAAmB;oBACrBF,YAAYa,GAAG,CAACH,IAAIE,IAAI;gBAC1B;gBACAP,UAAUQ,GAAG,CAACH;YAChB;QACF;IACF;IAEA,IAAID,cAAc;QAChB,KAAK,MAAMK,QAAQL,aAAc;YAC/B,IAAI,CAACR,gBAAgBU,GAAG,CAACG,OAAO;gBAC9B,IAAIZ,mBAAmB;oBACrBD,gBAAgBY,GAAG,CAACC;gBACtB;gBACAP,SAASM,GAAG,CAACC;YACf;QACF;IACF;IAEA,OAAO;QAAEC,QAAQ;eAAIV;SAAU;QAAEW,SAAS;eAAIT;SAAS;IAAC;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 2342, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-preloadable-fonts.tsx"],"sourcesContent":["import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get hrefs for fonts to preload\n * Returns null if there are no fonts at all.\n * Returns string[] if there are fonts to preload (font paths)\n * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded\n * Returns null if there are fonts but none to preload and at least some were previously preloaded\n */\nexport function getPreloadableFonts(\n  nextFontManifest: DeepReadonly<NextFontManifest> | undefined,\n  filePath: string | undefined,\n  injectedFontPreloadTags: Set<string>\n): string[] | null {\n  if (!nextFontManifest || !filePath) {\n    return null\n  }\n  const filepathWithoutExtension = filePath.replace(/\\.[^.]+$/, '')\n  const fontFiles = new Set<string>()\n  let foundFontUsage = false\n\n  const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension]\n  if (preloadedFontFiles) {\n    foundFontUsage = true\n    for (const fontFile of preloadedFontFiles) {\n      if (!injectedFontPreloadTags.has(fontFile)) {\n        fontFiles.add(fontFile)\n        injectedFontPreloadTags.add(fontFile)\n      }\n    }\n  }\n\n  if (fontFiles.size) {\n    return [...fontFiles].sort()\n  } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {\n    return []\n  } else {\n    return null\n  }\n}\n"],"names":["getPreloadableFonts","nextFontManifest","filePath","injectedFontPreloadTags","filepathWithoutExtension","replace","fontFiles","Set","foundFontUsage","preloadedFontFiles","app","fontFile","has","add","size","sort"],"mappings":"AAGA;;;;;;CAMC,GACD;;;AAAO,SAASA,oBACdC,gBAA4D,EAC5DC,QAA4B,EAC5BC,uBAAoC;IAEpC,IAAI,CAACF,oBAAoB,CAACC,UAAU;QAClC,OAAO;IACT;IACA,MAAME,2BAA2BF,SAASG,OAAO,CAAC,YAAY;IAC9D,MAAMC,YAAY,IAAIC;IACtB,IAAIC,iBAAiB;IAErB,MAAMC,qBAAqBR,iBAAiBS,GAAG,CAACN,yBAAyB;IACzE,IAAIK,oBAAoB;QACtBD,iBAAiB;QACjB,KAAK,MAAMG,YAAYF,mBAAoB;YACzC,IAAI,CAACN,wBAAwBS,GAAG,CAACD,WAAW;gBAC1CL,UAAUO,GAAG,CAACF;gBACdR,wBAAwBU,GAAG,CAACF;YAC9B;QACF;IACF;IAEA,IAAIL,UAAUQ,IAAI,EAAE;QAClB,OAAO;eAAIR;SAAU,CAACS,IAAI;IAC5B,OAAO,IAAIP,kBAAkBL,wBAAwBW,IAAI,KAAK,GAAG;QAC/D,OAAO,EAAE;IACX,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2384, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/has-loading-component-in-tree.tsx"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\n\nexport function hasLoadingComponentInTree(tree: LoaderTree): boolean {\n  const [, parallelRoutes, { loading }] = tree\n\n  if (loading) {\n    return true\n  }\n\n  return Object.values(parallelRoutes).some((parallelRoute) =>\n    hasLoadingComponentInTree(parallelRoute)\n  ) as boolean\n}\n"],"names":["hasLoadingComponentInTree","tree","parallelRoutes","loading","Object","values","some","parallelRoute"],"mappings":";;;AAEO,SAASA,0BAA0BC,IAAgB;IACxD,MAAM,GAAGC,gBAAgB,EAAEC,OAAO,EAAE,CAAC,GAAGF;IAExC,IAAIE,SAAS;QACX,OAAO;IACT;IAEA,OAAOC,OAAOC,MAAM,CAACH,gBAAgBI,IAAI,CAAC,CAACC,gBACzCP,0BAA0BO;AAE9B","ignoreList":[0]}},
    {"offset": {"line": 2400, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GACD;;;AAAO,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0]}},
    {"offset": {"line": 2414, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/parse-loader-tree.ts"],"sourcesContent":["import { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { LoaderTree } from '../lib/app-dir-module'\n\nexport function parseLoaderTree(tree: LoaderTree) {\n  const [segment, parallelRoutes, modules] = tree\n  const { layout } = modules\n  let { page } = modules\n  // a __DEFAULT__ segment means that this route didn't match any of the\n  // segments in the route, so we should use the default page\n  page = segment === DEFAULT_SEGMENT_KEY ? modules.defaultPage : page\n\n  const layoutOrPagePath = layout?.[1] || page?.[1]\n\n  return {\n    page,\n    segment,\n    modules,\n    layoutOrPagePath,\n    parallelRoutes,\n  }\n}\n"],"names":["DEFAULT_SEGMENT_KEY","parseLoaderTree","tree","segment","parallelRoutes","modules","layout","page","defaultPage","layoutOrPagePath"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ,2BAA0B;;AAGvD,SAASC,gBAAgBC,IAAgB;IAC9C,MAAM,CAACC,SAASC,gBAAgBC,QAAQ,GAAGH;IAC3C,MAAM,EAAEI,MAAM,EAAE,GAAGD;IACnB,IAAI,EAAEE,IAAI,EAAE,GAAGF;IACf,sEAAsE;IACtE,2DAA2D;IAC3DE,OAAOJ,oLAAYH,sBAAAA,GAAsBK,QAAQG,WAAW,GAAGD;IAE/D,MAAME,mBAAmBH,CAAAA,UAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,EAAE,KAAA,CAAIC,QAAAA,OAAAA,KAAAA,IAAAA,IAAM,CAAC,EAAE;IAEjD,OAAO;QACLA;QACAJ;QACAE;QACAI;QACAL;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2441, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-asset-query-string.ts"],"sourcesContent":["import type { AppRenderContext } from './app-render'\n\nconst isDev = process.env.NODE_ENV === 'development'\nconst isTurbopack = !!process.env.TURBOPACK\n\nexport function getAssetQueryString(\n  ctx: AppRenderContext,\n  addTimestamp: boolean\n) {\n  let qs = ''\n\n  // In development we add the request timestamp to allow react to\n  // reload assets when a new RSC response is received.\n  // Turbopack handles HMR of assets itself and react doesn't need to reload them\n  // so this approach is not needed for Turbopack.\n  const shouldAddVersion = isDev && !isTurbopack && addTimestamp\n  if (shouldAddVersion) {\n    qs += `?v=${ctx.requestTimestamp}`\n  }\n\n  if (ctx.renderOpts.deploymentId) {\n    qs += `${shouldAddVersion ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n  }\n  return qs\n}\n"],"names":["isDev","process","env","NODE_ENV","isTurbopack","TURBOPACK","getAssetQueryString","ctx","addTimestamp","qs","shouldAddVersion","requestTimestamp","renderOpts","deploymentId"],"mappings":";;;AAEA,MAAMA,QAAQC,QAAQC,GAAG,CAACC,QAAQ,gCAAK;AACvC,MAAMC,cAAc,CAAC,CAACH,QAAQC,GAAG,CAACG,SAAS;AAEpC,SAASC,oBACdC,GAAqB,EACrBC,YAAqB;IAErB,IAAIC,KAAK;IAET,gEAAgE;IAChE,qDAAqD;IACrD,+EAA+E;IAC/E,gDAAgD;IAChD,MAAMC,mBAAmBV,SAAS,CAACI,eAAeI;IAClD,IAAIE,mCAAkB;;IAEtB;IAEA,IAAIH,IAAIK,UAAU,CAACC,YAAY,EAAE;QAC/BJ,MAAM,GAAGC,mBAAmB,0DAAM,IAAI,IAAI,EAAEH,IAAIK,UAAU,CAACC,YAAY,EAAE;IAC3E;IACA,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 2467, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/render-css-resource.tsx"],"sourcesContent":["import type { CssResource } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport type { PreloadCallbacks } from './types'\n\n/**\n * Abstracts the rendering of CSS files based on whether they are inlined or not.\n * For inlined CSS, renders a <style> tag with the CSS content directly embedded.\n * For external CSS files, renders a <link> tag pointing to the CSS file.\n */\nexport function renderCssResource(\n  entryCssFiles: CssResource[],\n  ctx: AppRenderContext,\n  preloadCallbacks?: PreloadCallbacks\n) {\n  return entryCssFiles.map((entryCssFile, index) => {\n    // `Precedence` is an opt-in signal for React to handle resource\n    // loading and deduplication, etc. It's also used as the key to sort\n    // resources so they will be injected in the correct order.\n    // During HMR, it's critical to use different `precedence` values\n    // for different stylesheets, so their order will be kept.\n    // https://github.com/facebook/react/pull/25060\n    const precedence =\n      process.env.NODE_ENV === 'development'\n        ? 'next_' + entryCssFile.path\n        : 'next'\n\n    // In dev, Safari and Firefox will cache the resource during HMR:\n    // - https://github.com/vercel/next.js/issues/5860\n    // - https://bugs.webkit.org/show_bug.cgi?id=187726\n    // Because of this, we add a `?v=` query to bypass the cache during\n    // development. We need to also make sure that the number is always\n    // increasing.\n    const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(\n      entryCssFile.path\n    )}${getAssetQueryString(ctx, true)}`\n\n    if (entryCssFile.inlined && !ctx.parsedRequestHeaders.isRSCRequest) {\n      return (\n        <style\n          key={index}\n          nonce={ctx.nonce}\n          // @ts-ignore\n          precedence={precedence}\n          href={fullHref}\n        >\n          {entryCssFile.content}\n        </style>\n      )\n    }\n\n    preloadCallbacks?.push(() => {\n      ctx.componentMod.preloadStyle(\n        fullHref,\n        ctx.renderOpts.crossOrigin,\n        ctx.nonce\n      )\n    })\n\n    return (\n      <link\n        key={index}\n        rel=\"stylesheet\"\n        href={fullHref}\n        // @ts-ignore\n        precedence={precedence}\n        crossOrigin={ctx.renderOpts.crossOrigin}\n        nonce={ctx.nonce}\n      />\n    )\n  })\n}\n"],"names":["encodeURIPath","getAssetQueryString","renderCssResource","entryCssFiles","ctx","preloadCallbacks","map","entryCssFile","index","precedence","process","env","NODE_ENV","path","fullHref","assetPrefix","inlined","parsedRequestHeaders","isRSCRequest","style","nonce","href","content","push","componentMod","preloadStyle","renderOpts","crossOrigin","link","rel"],"mappings":";;;;AACA,SAASA,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,mBAAmB,QAAQ,2BAA0B;;;;AAQvD,SAASC,kBACdC,aAA4B,EAC5BC,GAAqB,EACrBC,gBAAmC;IAEnC,OAAOF,cAAcG,GAAG,CAAC,CAACC,cAAcC;QACtC,gEAAgE;QAChE,oEAAoE;QACpE,2DAA2D;QAC3D,iEAAiE;QACjE,0DAA0D;QAC1D,+CAA+C;QAC/C,MAAMC,aACJC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cACrB,UAAUL,aAAaM,IAAI,GAC3B;QAEN,iEAAiE;QACjE,kDAAkD;QAClD,mDAAmD;QACnD,mEAAmE;QACnE,mEAAmE;QACnE,cAAc;QACd,MAAMC,WAAW,GAAGV,IAAIW,WAAW,CAAC,OAAO,4LAAEf,gBAAAA,EAC3CO,aAAaM,IAAI,kNACfZ,sBAAAA,EAAoBG,KAAK,OAAO;QAEpC,IAAIG,aAAaS,OAAO,IAAI,CAACZ,IAAIa,oBAAoB,CAACC,YAAY,EAAE;YAClE,OAAA,WAAA,sMACE,MAAA,EAACC,SAAAA;gBAECC,OAAOhB,IAAIgB,KAAK;gBAChB,aAAa;gBACbX,YAAYA;gBACZY,MAAMP;0BAELP,aAAae,OAAO;eANhBd;QASX;QAEAH,oBAAAA,OAAAA,KAAAA,IAAAA,iBAAkBkB,IAAI,CAAC;YACrBnB,IAAIoB,YAAY,CAACC,YAAY,CAC3BX,UACAV,IAAIsB,UAAU,CAACC,WAAW,EAC1BvB,IAAIgB,KAAK;QAEb;QAEA,OAAA,WAAA,sMACE,MAAA,EAACQ,QAAAA;YAECC,KAAI;YACJR,MAAMP;YACN,aAAa;YACbL,YAAYA;YACZkB,aAAavB,IAAIsB,UAAU,CAACC,WAAW;YACvCP,OAAOhB,IAAIgB,KAAK;WANXZ;IASX;AACF","ignoreList":[0]}},
    {"offset": {"line": 2520, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-component-styles-and-scripts.tsx"],"sourcesContent":["import React from 'react'\nimport { interopDefault } from './interop-default'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport { renderCssResource } from './render-css-resource'\n\nexport async function createComponentStylesAndScripts({\n  filePath,\n  getComponent,\n  injectedCSS,\n  injectedJS,\n  ctx,\n}: {\n  filePath: string\n  getComponent: () => any\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  ctx: AppRenderContext\n}): Promise<[React.ComponentType<any>, React.ReactNode, React.ReactNode]> {\n  const { styles: entryCssFiles, scripts: jsHrefs } = getLinkAndScriptTags(\n    ctx.clientReferenceManifest,\n    filePath,\n    injectedCSS,\n    injectedJS\n  )\n\n  const styles = renderCssResource(entryCssFiles, ctx)\n\n  const scripts = jsHrefs\n    ? jsHrefs.map((href, index) => (\n        <script\n          src={`${ctx.assetPrefix}/_next/${encodeURIPath(\n            href\n          )}${getAssetQueryString(ctx, true)}`}\n          async={true}\n          key={`script-${index}`}\n        />\n      ))\n    : null\n\n  const Comp = interopDefault(await getComponent())\n\n  return [Comp, styles, scripts]\n}\n"],"names":["React","interopDefault","getLinkAndScriptTags","getAssetQueryString","encodeURIPath","renderCssResource","createComponentStylesAndScripts","filePath","getComponent","injectedCSS","injectedJS","ctx","styles","entryCssFiles","scripts","jsHrefs","clientReferenceManifest","map","href","index","script","src","assetPrefix","async","Comp"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,cAAc,QAAQ,oBAAmB;AAClD,SAASC,oBAAoB,QAAQ,8BAA6B;AAElE,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAChE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;;;AAElD,eAAeC,gCAAgC,EACpDC,QAAQ,EACRC,YAAY,EACZC,WAAW,EACXC,UAAU,EACVC,GAAG,EAOJ;IACC,MAAM,EAAEC,QAAQC,aAAa,EAAEC,SAASC,OAAO,EAAE,uNAAGb,uBAAAA,EAClDS,IAAIK,uBAAuB,EAC3BT,UACAE,aACAC;IAGF,MAAME,iNAASP,oBAAAA,EAAkBQ,eAAeF;IAEhD,MAAMG,UAAUC,UACZA,QAAQE,GAAG,CAAC,CAACC,MAAMC,QAAAA,WAAAA,sMACjB,MAAA,EAACC,UAAAA;YACCC,KAAK,GAAGV,IAAIW,WAAW,CAAC,OAAO,4LAAElB,gBAAAA,EAC/Bc,sNACEf,sBAAAA,EAAoBQ,KAAK,OAAO;YACpCY,OAAO;WACF,CAAC,OAAO,EAAEJ,OAAO,KAG1B;IAEJ,MAAMK,wMAAOvB,iBAAAA,EAAe,MAAMO;IAElC,OAAO;QAACgB;QAAMZ;QAAQE;KAAQ;AAChC","ignoreList":[0]}},
    {"offset": {"line": 2557, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-layer-assets.tsx"],"sourcesContent":["import React from 'react'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { PreloadCallbacks } from './types'\nimport { renderCssResource } from './render-css-resource'\n\nexport function getLayerAssets({\n  ctx,\n  layoutOrPagePath,\n  injectedCSS: injectedCSSWithCurrentLayout,\n  injectedJS: injectedJSWithCurrentLayout,\n  injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  preloadCallbacks,\n}: {\n  layoutOrPagePath: string | undefined\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n}): React.ReactNode {\n  const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath\n    ? getLinkAndScriptTags(\n        ctx.clientReferenceManifest,\n        layoutOrPagePath,\n        injectedCSSWithCurrentLayout,\n        injectedJSWithCurrentLayout,\n        true\n      )\n    : { styles: [], scripts: [] }\n\n  const preloadedFontFiles = layoutOrPagePath\n    ? getPreloadableFonts(\n        ctx.renderOpts.nextFontManifest,\n        layoutOrPagePath,\n        injectedFontPreloadTagsWithCurrentLayout\n      )\n    : null\n\n  if (preloadedFontFiles) {\n    if (preloadedFontFiles.length) {\n      for (let i = 0; i < preloadedFontFiles.length; i++) {\n        const fontFilename = preloadedFontFiles[i]\n        const ext = /\\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)![1]\n        const type = `font/${ext}`\n        const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`\n\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preloadFont(\n            href,\n            type,\n            ctx.renderOpts.crossOrigin,\n            ctx.nonce\n          )\n        })\n      }\n    } else {\n      try {\n        let url = new URL(ctx.assetPrefix)\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect(url.origin, 'anonymous', ctx.nonce)\n        })\n      } catch (error) {\n        // assetPrefix must not be a fully qualified domain name. We assume\n        // we should preconnect to same origin instead\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect('/', 'anonymous', ctx.nonce)\n        })\n      }\n    }\n  }\n\n  const styles = renderCssResource(styleTags, ctx, preloadCallbacks)\n\n  const scripts = scriptTags\n    ? scriptTags.map((href, index) => {\n        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(\n          href\n        )}${getAssetQueryString(ctx, true)}`\n\n        return (\n          <script\n            src={fullSrc}\n            async={true}\n            key={`script-${index}`}\n            nonce={ctx.nonce}\n          />\n        )\n      })\n    : []\n\n  return styles.length || scripts.length ? [...styles, ...scripts] : null\n}\n"],"names":["React","getLinkAndScriptTags","getPreloadableFonts","getAssetQueryString","encodeURIPath","renderCssResource","getLayerAssets","ctx","layoutOrPagePath","injectedCSS","injectedCSSWithCurrentLayout","injectedJS","injectedJSWithCurrentLayout","injectedFontPreloadTags","injectedFontPreloadTagsWithCurrentLayout","preloadCallbacks","styles","styleTags","scripts","scriptTags","clientReferenceManifest","preloadedFontFiles","renderOpts","nextFontManifest","length","i","fontFilename","ext","exec","type","href","assetPrefix","push","componentMod","preloadFont","crossOrigin","nonce","url","URL","preconnect","origin","error","map","index","fullSrc","script","src","async"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,oBAAoB,QAAQ,8BAA6B;AAClE,SAASC,mBAAmB,QAAQ,0BAAyB;AAE7D,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;;;AAElD,SAASC,eAAe,EAC7BC,GAAG,EACHC,gBAAgB,EAChBC,aAAaC,4BAA4B,EACzCC,YAAYC,2BAA2B,EACvCC,yBAAyBC,wCAAwC,EACjEC,gBAAgB,EAQjB;IACC,MAAM,EAAEC,QAAQC,SAAS,EAAEC,SAASC,UAAU,EAAE,GAAGX,uOAC/CP,uBAAAA,EACEM,IAAIa,uBAAuB,EAC3BZ,kBACAE,8BACAE,6BACA,QAEF;QAAEI,QAAQ,EAAE;QAAEE,SAAS,EAAE;IAAC;IAE9B,MAAMG,qBAAqBb,6NACvBN,sBAAAA,EACEK,IAAIe,UAAU,CAACC,gBAAgB,EAC/Bf,kBACAM,4CAEF;IAEJ,IAAIO,oBAAoB;QACtB,IAAIA,mBAAmBG,MAAM,EAAE;YAC7B,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,mBAAmBG,MAAM,EAAEC,IAAK;gBAClD,MAAMC,eAAeL,kBAAkB,CAACI,EAAE;gBAC1C,MAAME,MAAM,8BAA8BC,IAAI,CAACF,aAAc,CAAC,EAAE;gBAChE,MAAMG,OAAO,CAAC,KAAK,EAAEF,KAAK;gBAC1B,MAAMG,OAAO,GAAGvB,IAAIwB,WAAW,CAAC,OAAO,4LAAE3B,gBAAAA,EAAcsB,eAAe;gBAEtEX,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACC,WAAW,CAC1BJ,MACAD,MACAtB,IAAIe,UAAU,CAACa,WAAW,EAC1B5B,IAAI6B,KAAK;gBAEb;YACF;QACF,OAAO;YACL,IAAI;gBACF,IAAIC,MAAM,IAAIC,IAAI/B,IAAIwB,WAAW;gBACjChB,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACM,UAAU,CAACF,IAAIG,MAAM,EAAE,aAAajC,IAAI6B,KAAK;gBAChE;YACF,EAAE,OAAOK,OAAO;gBACd,mEAAmE;gBACnE,8CAA8C;gBAC9C1B,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACM,UAAU,CAAC,KAAK,aAAahC,IAAI6B,KAAK;gBACzD;YACF;QACF;IACF;IAEA,MAAMpB,iNAASX,oBAAAA,EAAkBY,WAAWV,KAAKQ;IAEjD,MAAMG,UAAUC,aACZA,WAAWuB,GAAG,CAAC,CAACZ,MAAMa;QACpB,MAAMC,UAAU,GAAGrC,IAAIwB,WAAW,CAAC,OAAO,GAAE3B,yMAAAA,EAC1C0B,sNACE3B,sBAAAA,EAAoBI,KAAK,OAAO;QAEpC,OAAA,WAAA,sMACE,MAAA,EAACsC,UAAAA;YACCC,KAAKF;YACLG,OAAO;YAEPX,OAAO7B,IAAI6B,KAAK;WADX,CAAC,OAAO,EAAEO,OAAO;IAI5B,KACA,EAAE;IAEN,OAAO3B,OAAOQ,MAAM,IAAIN,QAAQM,MAAM,GAAG;WAAIR;WAAWE;KAAQ,GAAG;AACrE","ignoreList":[0]}},
    {"offset": {"line": 2626, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type { CacheNodeSeedData, PreloadCallbacks } from './types'\nimport React from 'react'\nimport {\n  isClientReference,\n  isUseCacheFunction,\n} from '../../lib/client-and-server-references'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { AppRenderContext, GetDynamicParamFromSegment } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { Params } from '../request/params'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { OUTLET_BOUNDARY_NAME } from '../../lib/metadata/metadata-constants'\nimport type { UseCachePageComponentProps } from '../use-cache/use-cache-wrapper'\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadata: React.ComponentType | null\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<CacheNodeSeedData> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props)\n  )\n}\n\nfunction errorMissingDefaultExport(\n  pagePath: string,\n  convention: string\n): never {\n  const normalizedPagePath = pagePath === '/' ? '' : pagePath\n  throw new Error(\n    `The default export is not a React Component in \"${normalizedPagePath}/${convention}\"`\n  )\n}\n\nconst cacheNodeKey = 'c'\n\nasync function createComponentTreeInternal({\n  loaderTree: tree,\n  parentParams,\n  rootLayoutIncluded,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  missingSlots,\n  preloadCallbacks,\n  authInterrupts,\n  StreamingMetadata,\n  StreamingMetadataOutlet,\n}: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getViewportReady: () => Promise<void>\n  getMetadataReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadata: React.ComponentType | null\n  StreamingMetadataOutlet: React.ComponentType | null\n}): Promise<CacheNodeSeedData> {\n  const {\n    renderOpts: { nextConfigOutput, experimental },\n    workStore,\n    componentMod: {\n      HTTPAccessFallbackBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      OutletBoundary,\n      ClientPageRoot,\n      ClientSegmentRoot,\n      createServerSearchParamsForServerPage,\n      createPrerenderSearchParamsForClientPage,\n      createServerParamsForServerSegment,\n      createPrerenderParamsForClientSegment,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, layoutOrPagePath, segment, modules, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const {\n    layout,\n    template,\n    error,\n    loading,\n    'not-found': notFound,\n    forbidden,\n    unauthorized,\n  } = modules\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    preloadCallbacks,\n    ctx,\n    layoutOrPagePath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [React.Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const { mod: layoutOrPageMod, modType } = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Forbidden, forbiddenStyles] =\n    authInterrupts && forbidden\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: forbidden[1],\n          getComponent: forbidden[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  const [Unauthorized, unauthorizedStyles] =\n    authInterrupts && unauthorized\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: unauthorized[1],\n          getComponent: unauthorized[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      workStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      workStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (workStore.isStaticGeneration && !experimental.isRoutePPREnabled) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        workStore.dynamicUsageDescription = err.message\n        workStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      workStore.dynamicShouldError = false\n      workStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    workStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, workStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    const defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    if (workUnitStore) {\n      if (\n        workUnitStore.type === 'prerender' ||\n        workUnitStore.type === 'prerender-legacy' ||\n        workUnitStore.type === 'prerender-ppr' ||\n        workUnitStore.type === 'cache'\n      ) {\n        if (workUnitStore.revalidate > defaultRevalidate) {\n          workUnitStore.revalidate = defaultRevalidate\n        }\n      }\n    }\n\n    if (\n      !workStore.forceStatic &&\n      workStore.isStaticGeneration &&\n      defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !experimental.isRoutePPREnabled\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      workStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  const isStaticGeneration = workStore.isStaticGeneration\n\n  // Assume the segment we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // It's OK for this to be `true` when the data is actually fully static, but\n  // it's not OK for this to be `false` when the data possibly contains holes.\n  // Although the value here is overly pessimistic, for prefetches, it will be\n  // replaced by a more specific value when the data is later processed into\n  // per-segment responses (see collect-segment-data.tsx)\n  //\n  // For dynamic requests, this must always be `false` because dynamic responses\n  // are never partial.\n  const isPossiblyPartialResponse =\n    isStaticGeneration && experimental.isRoutePPREnabled === true\n\n  // If there's a dynamic usage error attached to the store, throw it.\n  if (workStore.dynamicUsageErr) {\n    throw workStore.dynamicUsageErr\n  }\n\n  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let MaybeComponent = LayoutOrPage\n\n  if (process.env.NODE_ENV === 'development') {\n    const { isValidElementType } = require('next/dist/compiled/react-is')\n    if (\n      typeof MaybeComponent !== 'undefined' &&\n      !isValidElementType(MaybeComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, modType ?? 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n\n    if (typeof Forbidden !== 'undefined' && !isValidElementType(Forbidden)) {\n      errorMissingDefaultExport(pagePath, 'forbidden')\n    }\n\n    if (\n      typeof Unauthorized !== 'undefined' &&\n      !isValidElementType(Unauthorized)\n    ) {\n      errorMissingDefaultExport(pagePath, 'unauthorized')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  // Create object holding the parent params and current params\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  // Resolve the segment param\n  const actualSegment = segmentParam ? segmentParam.treeSegment : segment\n  const metadata = StreamingMetadata ? <StreamingMetadata /> : undefined\n\n  // Use the same condition to render metadataOutlet as metadata\n  const metadataOutlet = StreamingMetadataOutlet ? (\n    <StreamingMetadataOutlet />\n  ) : undefined\n\n  const notFoundElement = NotFound ? (\n    <>\n      <NotFound />\n      {notFoundStyles}\n    </>\n  ) : undefined\n\n  const forbiddenElement = Forbidden ? (\n    <>\n      <Forbidden />\n      {forbiddenStyles}\n    </>\n  ) : undefined\n\n  const unauthorizedElement = Unauthorized ? (\n    <>\n      <Unauthorized />\n      {unauthorizedStyles}\n    </>\n  ) : undefined\n\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent = isChildrenRouteKey\n          ? notFoundElement\n          : undefined\n\n        const forbiddenComponent = isChildrenRouteKey\n          ? forbiddenElement\n          : undefined\n\n        const unauthorizedComponent = isChildrenRouteKey\n          ? unauthorizedElement\n          : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is deferred until the actual navigation.\n          // It does not take into account whether the data is dynamic  even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different  loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.layoutOrPagePath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const seedData = await createComponentTreeInternal({\n            loaderTree: parallelRoute,\n            parentParams: currentParams,\n            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n            injectedCSS: injectedCSSWithCurrentLayout,\n            injectedJS: injectedJSWithCurrentLayout,\n            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n            // `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            getMetadataReady: isChildrenRouteKey\n              ? getMetadataReady\n              : () => Promise.resolve(),\n            getViewportReady: isChildrenRouteKey\n              ? getViewportReady\n              : () => Promise.resolve(),\n            ctx,\n            missingSlots,\n            preloadCallbacks,\n            authInterrupts,\n            StreamingMetadata: isChildrenRouteKey ? StreamingMetadata : null,\n            // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            StreamingMetadataOutlet: isChildrenRouteKey\n              ? StreamingMetadataOutlet\n              : null,\n          })\n\n          childCacheNodeSeedData = seedData\n        }\n\n        // This is turned back into an object below.\n        return [\n          parallelRouteKey,\n          <LayoutRouter\n            parallelRouterKey={parallelRouteKey}\n            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n            error={ErrorComponent}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n            template={\n              <Template>\n                <RenderFromTemplateContext />\n              </Template>\n            }\n            templateStyles={templateStyles}\n            templateScripts={templateScripts}\n            notFound={notFoundComponent}\n            forbidden={forbiddenComponent}\n            unauthorized={unauthorizedComponent}\n          />,\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  const loadingData: LoadingModuleData = Loading\n    ? [<Loading key=\"l\" />, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!MaybeComponent) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {layerAssets}\n        {parallelRouteProps.children}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n\n  const Component = MaybeComponent\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    workStore.isStaticGeneration &&\n    workStore.forceDynamic &&\n    experimental.isRoutePPREnabled\n  ) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        <Postpone\n          reason='dynamic = \"force-dynamic\" was used'\n          route={workStore.route}\n        />\n        {layerAssets}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      true,\n    ]\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n\n  if (isPage) {\n    const PageComponent = Component\n    // Assign searchParams to props if this is a page\n    let pageElement: React.ReactNode\n    if (isClientComponent) {\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n        const promiseOfSearchParams =\n          createPrerenderSearchParamsForClientPage(workStore)\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n            promises={[promiseOfSearchParams, promiseOfParams]}\n          />\n        )\n      } else {\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n          />\n        )\n      }\n    } else {\n      // If we are passing params to a server component Page we need to track\n      // their usage in case the current render mode tracks dynamic API usage.\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      // TODO(useCache): Should we use this trick also if dynamicIO is enabled,\n      // instead of relying on the searchParams being a hanging promise?\n      if (!experimental.dynamicIO && isUseCacheFunction(PageComponent)) {\n        const UseCachePageComponent: React.ComponentType<UseCachePageComponentProps> =\n          PageComponent\n\n        // The \"use cache\" wrapper takes care of converting this into an\n        // erroring search params promise when passing it to the original\n        // function.\n        const searchParams = Promise.resolve({})\n\n        pageElement = (\n          <UseCachePageComponent\n            params={params}\n            searchParams={searchParams}\n            $$isPageComponent\n          />\n        )\n      } else {\n        // If we are passing searchParams to a server component Page we need to\n        // track their usage in case the current render mode tracks dynamic API\n        // usage.\n        const searchParams = createServerSearchParamsForServerPage(\n          query,\n          workStore\n        )\n\n        pageElement = (\n          <PageComponent params={params} searchParams={searchParams} />\n        )\n      }\n    }\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {pageElement}\n        {/*\n         * The order here matters since a parent might call findDOMNode().\n         * findDOMNode() will return the first child if multiple children are rendered.\n         * But React will hoist metadata into <head> which breaks scroll handling.\n         */}\n        {metadata}\n        {layerAssets}\n        <OutletBoundary>\n          <MetadataOutlet ready={getViewportReady} />\n          {/* Blocking metadata outlet */}\n          <MetadataOutlet ready={getMetadataReady} />\n          {/* Streaming metadata outlet */}\n          {metadataOutlet}\n        </OutletBoundary>\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  } else {\n    const SegmentComponent = Component\n\n    const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot =\n      rootLayoutAtThisLevel &&\n      'children' in parallelRoutes &&\n      Object.keys(parallelRoutes).length > 1\n\n    let segmentNode: React.ReactNode\n\n    if (isClientComponent) {\n      let clientSegment: React.ReactNode\n\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n            promise={promiseOfParams}\n          />\n        )\n      } else {\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n          />\n        )\n      }\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        let notfoundClientSegment: React.ReactNode\n        let forbiddenClientSegment: React.ReactNode\n        let unauthorizedClientSegment: React.ReactNode\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: NotFound,\n          errorElement: notFoundElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Forbidden,\n          errorElement: forbiddenElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Unauthorized,\n          errorElement: unauthorizedElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        if (\n          notfoundClientSegment ||\n          forbiddenClientSegment ||\n          unauthorizedClientSegment\n        ) {\n          segmentNode = (\n            <HTTPAccessFallbackBoundary\n              key={cacheNodeKey}\n              notFound={notfoundClientSegment}\n              forbidden={forbiddenClientSegment}\n              unauthorized={unauthorizedClientSegment}\n            >\n              {layerAssets}\n              {clientSegment}\n            </HTTPAccessFallbackBoundary>\n          )\n        } else {\n          segmentNode = (\n            <React.Fragment key={cacheNodeKey}>\n              {layerAssets}\n              {clientSegment}\n            </React.Fragment>\n          )\n        }\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {clientSegment}\n          </React.Fragment>\n        )\n      }\n    } else {\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      let serverSegment = (\n        <SegmentComponent {...parallelRouteProps} params={params} />\n      )\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        segmentNode = (\n          <HTTPAccessFallbackBoundary\n            key={cacheNodeKey}\n            notFound={\n              NotFound ? (\n                <>\n                  {layerAssets}\n                  <SegmentComponent params={params}>\n                    {notFoundStyles}\n                    <NotFound />\n                  </SegmentComponent>\n                </>\n              ) : undefined\n            }\n          >\n            {layerAssets}\n            {serverSegment}\n          </HTTPAccessFallbackBoundary>\n        )\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {serverSegment}\n          </React.Fragment>\n        )\n      }\n    }\n    // For layouts we just render the component\n    return [\n      actualSegment,\n      segmentNode,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n}\n\nasync function MetadataOutlet({\n  ready,\n}: {\n  ready: () => Promise<void> & { status?: string; value?: unknown }\n}) {\n  const r = ready()\n  // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n  if (r.status === 'rejected') {\n    throw r.value\n  } else if (r.status !== 'fulfilled') {\n    await r\n  }\n  return null\n}\nMetadataOutlet.displayName = OUTLET_BOUNDARY_NAME\n\nfunction createErrorBoundaryClientSegmentRoot({\n  ErrorBoundaryComponent,\n  errorElement,\n  ClientSegmentRoot,\n  layerAssets,\n  SegmentComponent,\n  currentParams,\n}: {\n  ErrorBoundaryComponent: React.ComponentType<any> | undefined\n  errorElement: React.ReactNode\n  ClientSegmentRoot: React.ComponentType<any>\n  layerAssets: React.ReactNode\n  SegmentComponent: React.ComponentType<any>\n  currentParams: Params\n}) {\n  if (ErrorBoundaryComponent) {\n    const notFoundParallelRouteProps = {\n      children: errorElement,\n    }\n    return (\n      <>\n        {layerAssets}\n        <ClientSegmentRoot\n          Component={SegmentComponent}\n          slots={notFoundParallelRouteProps}\n          params={currentParams}\n        />\n      </>\n    )\n  }\n  return null\n}\n\nexport function getRootParams(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment)\n}\n\nfunction getRootParamsImpl(\n  parentParams: Params,\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  const {\n    segment,\n    modules: { layout },\n    parallelRoutes,\n  } = parseLoaderTree(loaderTree)\n\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const isRootLayout = typeof layout !== 'undefined'\n\n  if (isRootLayout) {\n    return currentParams\n  } else if (!parallelRoutes.children) {\n    // This should really be an error but there are bugs in Turbopack that cause\n    // the _not-found LoaderTree to not have any layouts. For rootParams sake\n    // this is somewhat irrelevant when you are not customizing the 404 page.\n    // If you are customizing 404\n    // TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined\n    return currentParams\n  } else {\n    return getRootParamsImpl(\n      currentParams,\n      // We stop looking for root params as soon as we hit the first layout\n      // and it is not possible to use parallel route children above the root layout\n      // so every parallelRoutes object that this function can visit will necessarily\n      // have a single `children` prop and no others.\n      parallelRoutes.children,\n      getDynamicParamFromSegment\n    )\n  }\n}\n"],"names":["React","isClientReference","isUseCacheFunction","getLayoutOrPageModule","interopDefault","parseLoaderTree","createComponentStylesAndScripts","getLayerAssets","hasLoadingComponentInTree","validateRevalidate","PARALLEL_ROUTE_DEFAULT_PATH","getTracer","NextNodeServerSpan","StaticGenBailoutError","workUnitAsyncStorage","OUTLET_BOUNDARY_NAME","createComponentTree","props","trace","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","normalizedPagePath","Error","cacheNodeKey","loaderTree","tree","parentParams","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","getViewportReady","getMetadataReady","ctx","missingSlots","preloadCallbacks","authInterrupts","StreamingMetadata","StreamingMetadataOutlet","renderOpts","nextConfigOutput","experimental","workStore","componentMod","HTTPAccessFallbackBoundary","LayoutRouter","RenderFromTemplateContext","OutletBoundary","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createPrerenderParamsForClientSegment","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","layoutOrPagePath","segment","modules","parallelRoutes","layout","template","error","loading","notFound","forbidden","unauthorized","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","Template","templateStyles","templateScripts","filePath","getComponent","Fragment","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","mod","layoutOrPageMod","modType","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","Forbidden","forbiddenStyles","Unauthorized","unauthorizedStyles","dynamic","dynamicShouldError","forceDynamic","isStaticGeneration","isRoutePPREnabled","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","route","defaultRevalidate","workUnitStore","getStore","type","isPossiblyPartialResponse","dynamicUsageErr","LayoutOrPage","undefined","MaybeComponent","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","actualSegment","treeSegment","metadata","metadataOutlet","notFoundElement","forbiddenElement","unauthorizedElement","parallelRouteMap","Promise","all","Object","keys","map","parallelRouteKey","isChildrenRouteKey","parallelRoute","notFoundComponent","forbiddenComponent","unauthorizedComponent","childCacheNodeSeedData","parsedTree","endsWith","add","seedData","resolve","parallelRouterKey","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingData","children","Component","reason","isClientComponent","console","PageComponent","pageElement","promiseOfParams","promiseOfSearchParams","searchParams","params","promises","dynamicIO","UseCachePageComponent","$$isPageComponent","MetadataOutlet","ready","SegmentComponent","isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot","length","segmentNode","clientSegment","slots","promise","notfoundClientSegment","forbiddenClientSegment","unauthorizedClientSegment","createErrorBoundaryClientSegmentRoot","ErrorBoundaryComponent","errorElement","serverSegment","r","status","displayName","notFoundParallelRouteProps","getRootParams","getRootParamsImpl","isRootLayout"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3323, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/walk-tree-with-flight-router-state.tsx"],"sourcesContent":["import type {\n  FlightDataPath,\n  FlightDataSegment,\n  FlightRouterState,\n  PreloadCallbacks,\n  Segment,\n} from './types'\nimport { matchSegment } from '../../client/components/match-segments'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport type { AppRenderContext } from './app-render'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  addSearchParamsIfPageSegment,\n} from '../../shared/lib/segment'\nimport { createComponentTree } from './create-component-tree'\nimport type { HeadData } from '../../shared/lib/app-router-context.shared-runtime'\nimport { getSegmentParam } from './get-segment-param'\n\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */\nexport async function walkTreeWithFlightRouterState({\n  loaderTreeToFilter,\n  parentParams,\n  flightRouterState,\n  parentIsInsideSharedLayout,\n  rscHead,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  rootLayoutIncluded,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  preloadCallbacks,\n  StreamingMetadataOutlet,\n}: {\n  loaderTreeToFilter: LoaderTree\n  parentParams: { [key: string]: string | string[] }\n  flightRouterState?: FlightRouterState\n  rscHead: HeadData\n  parentIsInsideSharedLayout?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  rootLayoutIncluded: boolean\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<FlightDataPath[]> {\n  const {\n    renderOpts: { nextFontManifest, experimental },\n    query,\n    isPrefetch,\n    getDynamicParamFromSegment,\n    parsedRequestHeaders,\n  } = ctx\n\n  const [segment, parallelRoutes, modules] = loaderTreeToFilter\n\n  const parallelRoutesKeys = Object.keys(parallelRoutes)\n\n  const { layout } = modules\n  const isLayout = typeof layout !== 'undefined'\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n  const segmentParam = getDynamicParamFromSegment(segment)\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : parentParams\n  const actualSegment: Segment = addSearchParamsIfPageSegment(\n    segmentParam ? segmentParam.treeSegment : segment,\n    query\n  )\n\n  /**\n   * Decide if the current segment is where rendering has to start.\n   */\n  const renderComponentsOnThisLevel =\n    // No further router state available\n    !flightRouterState ||\n    // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) ||\n    // Last item in the tree\n    parallelRoutesKeys.length === 0 ||\n    // Explicit refresh\n    flightRouterState[3] === 'refetch'\n\n  // Pre-PPR, the `loading` component signals to the router how deep to render the component tree\n  // to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,\n  // the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`\n  // somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.\n\n  // Check if we're inside the \"new\" part of the navigation  inside the\n  // shared layout. In the case of a prefetch, this can be true even if the\n  // segment matches, because the client might send a matching segment to\n  // indicate that it already has the data in its cache. But in order to find\n  // the correct loading boundary, we still need to track where the shared\n  // layout begins.\n  //\n  // TODO: We should rethink the protocol for dynamic requests. It might not\n  // make sense for the client to send a FlightRouterState, since that type is\n  // overloaded with other concerns.\n  const isInsideSharedLayout =\n    renderComponentsOnThisLevel ||\n    parentIsInsideSharedLayout ||\n    flightRouterState[3] === 'inside-shared-layout'\n\n  if (\n    isInsideSharedLayout &&\n    !experimental.isRoutePPREnabled &&\n    // If PPR is disabled, and this is a request for the route tree, then we\n    // never render any components. Only send the router state.\n    (parsedRequestHeaders.isRouteTreePrefetchRequest ||\n      // Otherwise, check for the presence of a `loading` component.\n      (isPrefetch &&\n        !Boolean(modules.loading) &&\n        !hasLoadingComponentInTree(loaderTreeToFilter)))\n  ) {\n    // Send only the router state.\n    // TODO: Even for a dynamic route, we should cache these responses,\n    // because they do not contain any render data (neither segment data nor\n    // the head). They can be made even more cacheable once we move the route\n    // params into a separate data structure.\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        null,\n        [null, null],\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  if (renderComponentsOnThisLevel) {\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    // Create component tree using the slice of the loaderTree\n    const seedData = await createComponentTree(\n      // This ensures flightRouterPath is valid and filters down the tree\n      {\n        ctx,\n        loaderTree: loaderTreeToFilter,\n        parentParams: currentParams,\n        injectedCSS,\n        injectedJS,\n        injectedFontPreloadTags,\n        // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n        rootLayoutIncluded,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        authInterrupts: experimental.authInterrupts,\n        StreamingMetadata: null,\n        StreamingMetadataOutlet,\n      }\n    )\n\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        seedData,\n        rscHead,\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  // If we are not rendering on this level we need to check if the current\n  // segment has a layout. If so, we need to track all the used CSS to make\n  // the result consistent.\n  const layoutPath = layout?.[1]\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n  if (layoutPath) {\n    getLinkAndScriptTags(\n      ctx.clientReferenceManifest,\n      layoutPath,\n      injectedCSSWithCurrentLayout,\n      injectedJSWithCurrentLayout,\n      true\n    )\n    getPreloadableFonts(\n      nextFontManifest,\n      layoutPath,\n      injectedFontPreloadTagsWithCurrentLayout\n    )\n  }\n\n  const paths: FlightDataPath[] = []\n\n  // Walk through all parallel routes.\n  for (const parallelRouteKey of parallelRoutesKeys) {\n    const parallelRoute = parallelRoutes[parallelRouteKey]\n\n    const subPaths = await walkTreeWithFlightRouterState({\n      ctx,\n      loaderTreeToFilter: parallelRoute,\n      parentParams: currentParams,\n      flightRouterState:\n        flightRouterState && flightRouterState[1][parallelRouteKey],\n      parentIsInsideSharedLayout: isInsideSharedLayout,\n      rscHead,\n      injectedCSS: injectedCSSWithCurrentLayout,\n      injectedJS: injectedJSWithCurrentLayout,\n      injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n      rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n      getViewportReady,\n      getMetadataReady,\n      preloadCallbacks,\n      StreamingMetadataOutlet,\n    })\n\n    for (const subPath of subPaths) {\n      // we don't need to send over default routes in the flight data\n      // because they are always ignored by the client, unless it's a refetch\n      if (\n        subPath[0] === DEFAULT_SEGMENT_KEY &&\n        flightRouterState &&\n        !!flightRouterState[1][parallelRouteKey][0] &&\n        flightRouterState[1][parallelRouteKey][3] !== 'refetch'\n      ) {\n        continue\n      }\n\n      paths.push([actualSegment, parallelRouteKey, ...subPath])\n    }\n  }\n\n  return paths\n}\n\n/*\n * This function is used to determine if an existing segment can be overridden\n * by the incoming segment.\n */\nconst canSegmentBeOverridden = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n    return false\n  }\n\n  return getSegmentParam(existingSegment)?.param === segment[0]\n}\n"],"names":["matchSegment","getLinkAndScriptTags","getPreloadableFonts","createFlightRouterStateFromLoaderTree","hasLoadingComponentInTree","DEFAULT_SEGMENT_KEY","addSearchParamsIfPageSegment","createComponentTree","getSegmentParam","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","flightRouterState","parentIsInsideSharedLayout","rscHead","injectedCSS","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","getViewportReady","getMetadataReady","ctx","preloadCallbacks","StreamingMetadataOutlet","renderOpts","nextFontManifest","experimental","query","isPrefetch","getDynamicParamFromSegment","parsedRequestHeaders","segment","parallelRoutes","modules","parallelRoutesKeys","Object","keys","layout","isLayout","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","segmentParam","currentParams","value","param","actualSegment","treeSegment","renderComponentsOnThisLevel","length","isInsideSharedLayout","isRoutePPREnabled","isRouteTreePrefetchRequest","Boolean","loading","overriddenSegment","canSegmentBeOverridden","routerState","seedData","loaderTree","authInterrupts","StreamingMetadata","layoutPath","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","clientReferenceManifest","paths","parallelRouteKey","parallelRoute","subPaths","subPath","push","existingSegment","Array","isArray"],"mappings":";;;AAOA,SAASA,YAAY,QAAQ,yCAAwC;AAErE,SAASC,oBAAoB,QAAQ,8BAA6B;AAClE,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,qCAAqC,QAAQ,gDAA+C;AAErG,SAASC,yBAAyB,QAAQ,kCAAiC;AAC3E,SACEC,mBAAmB,EACnBC,4BAA4B,QACvB,2BAA0B;AACjC,SAASC,mBAAmB,QAAQ,0BAAyB;AAE7D,SAASC,eAAe,QAAQ,sBAAqB;;;;;;;;;AAM9C,eAAeC,8BAA8B,EAClDC,kBAAkB,EAClBC,YAAY,EACZC,iBAAiB,EACjBC,0BAA0B,EAC1BC,OAAO,EACPC,WAAW,EACXC,UAAU,EACVC,uBAAuB,EACvBC,kBAAkB,EAClBC,gBAAgB,EAChBC,gBAAgB,EAChBC,GAAG,EACHC,gBAAgB,EAChBC,uBAAuB,EAgBxB;IACC,MAAM,EACJC,YAAY,EAAEC,gBAAgB,EAAEC,YAAY,EAAE,EAC9CC,KAAK,EACLC,UAAU,EACVC,0BAA0B,EAC1BC,oBAAoB,EACrB,GAAGT;IAEJ,MAAM,CAACU,SAASC,gBAAgBC,QAAQ,GAAGvB;IAE3C,MAAMwB,qBAAqBC,OAAOC,IAAI,CAACJ;IAEvC,MAAM,EAAEK,MAAM,EAAE,GAAGJ;IACnB,MAAMK,WAAW,OAAOD,WAAW;IAEnC;;GAEC,GACD,MAAME,wBAAwBD,YAAY,CAACpB;IAC3C;;GAEC,GACD,MAAMsB,uCACJtB,sBAAsBqB;IAExB,8JAA8J;IAC9J,MAAME,eAAeZ,2BAA2BE;IAChD,MAAMW,gBACJ,AACAD,gBAAgBA,aAAaE,KAAK,KAAK,OACnC,KAF+C;QAG7C,GAAGhC,YAAY;QACf,CAAC8B,aAAaG,KAAK,CAAC,EAAEH,aAAaE,KAAK;IAC1C,IACAhC;IACN,MAAMkC,2LAAyBvC,gCAAAA,EAC7BmC,eAAeA,aAAaK,WAAW,GAAGf,SAC1CJ;IAGF;;GAEC,GACD,MAAMoB,8BACJ,AACA,CAACnC,qBACD,cAFoC,2CAEqB;IACzD,CAACZ,4MAAAA,EAAa6C,eAAejC,iBAAiB,CAAC,EAAE,KACjD,wBAAwB;IACxBsB,mBAAmBc,MAAM,KAAK,KAC9B,mBAAmB;IACnBpC,iBAAiB,CAAC,EAAE,KAAK;IAE3B,+FAA+F;IAC/F,yHAAyH;IACzH,wHAAwH;IACxH,kIAAkI;IAElI,sEAAsE;IACtE,yEAAyE;IACzE,uEAAuE;IACvE,2EAA2E;IAC3E,wEAAwE;IACxE,iBAAiB;IACjB,EAAE;IACF,0EAA0E;IAC1E,4EAA4E;IAC5E,kCAAkC;IAClC,MAAMqC,uBACJF,+BACAlC,8BACAD,iBAAiB,CAAC,EAAE,KAAK;IAE3B,IACEqC,wBACA,CAACvB,aAAawB,iBAAiB,IAC/B,wEAAwE;IACxE,2DAA2D;IAC1DpB,CAAAA,qBAAqBqB,0BAA0B,IAC9C,8DAA8D;IAC7DvB,cACC,CAACwB,QAAQnB,QAAQoB,OAAO,KACxB,KAACjD,gPAAAA,EAA0BM,mBAAmB,GAClD;QACA,8BAA8B;QAC9B,mEAAmE;QACnE,wEAAwE;QACxE,yEAAyE;QACzE,yCAAyC;QACzC,MAAM4C,oBACJ1C,qBACA,wEAAwE;QACxE,oEAAoE;QACpE,oEAAoE;QACpE2C,uBAAuBV,eAAejC,iBAAiB,CAAC,EAAE,IACtDA,iBAAiB,CAAC,EAAE,GACpBiC;QAEN,MAAMW,cAAcrD,oRAAAA,CAClB,CACAO,oBACAmB,4BACAF,OAHwD;QAK1D,OAAO;YACL;gBACE2B;gBACAE;gBACA;gBACA;oBAAC;oBAAM;iBAAK;gBACZ;aACD;SACF;IACH;IAEA,IAAIT,6BAA6B;QAC/B,MAAMO,oBACJ1C,qBACA,wEAAwE;QACxE,oEAAoE;QACpE,oEAAoE;QACpE2C,uBAAuBV,eAAejC,iBAAiB,CAAC,EAAE,IACtDA,iBAAiB,CAAC,EAAE,GACpBiC;QAEN,MAAMW,0PAAcrD,wCAAAA,CAClB,CACAO,oBACAmB,4BACAF,OAHwD;QAK1D,0DAA0D;QAC1D,MAAM8B,WAAW,MAAMlD,gOAAAA,CACrB,CACA,kEADmE;YAEjEc;YACAqC,YAAYhD;YACZC,cAAc+B;YACd3B;YACAC;YACAC;YACA,wKAAwK;YACxKC;YACAC;YACAC;YACAE;YACAqC,gBAAgBjC,aAAaiC,cAAc;YAC3CC,mBAAmB;YACnBrC;QACF;QAGF,OAAO;YACL;gBACE+B;gBACAE;gBACAC;gBACA3C;gBACA;aACD;SACF;IACH;IAEA,wEAAwE;IACxE,yEAAyE;IACzE,yBAAyB;IACzB,MAAM+C,aAAaxB,UAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,EAAE;IAC9B,MAAMyB,+BAA+B,IAAIC,IAAIhD;IAC7C,MAAMiD,8BAA8B,IAAID,IAAI/C;IAC5C,MAAMiD,2CAA2C,IAAIF,IACnD9C;IAEF,IAAI4C,YAAY;QACd5D,2OAAAA,EACEoB,IAAI6C,uBAAuB,EAC3BL,YACAC,8BACAE,6BACA;kNAEF9D,sBAAAA,EACEuB,kBACAoC,YACAI;IAEJ;IAEA,MAAME,QAA0B,EAAE;IAElC,oCAAoC;IACpC,KAAK,MAAMC,oBAAoBlC,mBAAoB;QACjD,MAAMmC,gBAAgBrC,cAAc,CAACoC,iBAAiB;QAEtD,MAAME,WAAW,MAAM7D,8BAA8B;YACnDY;YACAX,oBAAoB2D;YACpB1D,cAAc+B;YACd9B,mBACEA,qBAAqBA,iBAAiB,CAAC,EAAE,CAACwD,iBAAiB;YAC7DvD,4BAA4BoC;YAC5BnC;YACAC,aAAa+C;YACb9C,YAAYgD;YACZ/C,yBAAyBgD;YACzB/C,oBAAoBsB;YACpBrB;YACAC;YACAE;YACAC;QACF;QAEA,KAAK,MAAMgD,WAAWD,SAAU;YAC9B,+DAA+D;YAC/D,uEAAuE;YACvE,IACEC,OAAO,CAAC,EAAE,4KAAKlE,uBAAAA,IACfO,qBACA,CAAC,CAACA,iBAAiB,CAAC,EAAE,CAACwD,iBAAiB,CAAC,EAAE,IAC3CxD,iBAAiB,CAAC,EAAE,CAACwD,iBAAiB,CAAC,EAAE,KAAK,WAC9C;gBACA;YACF;YAEAD,MAAMK,IAAI,CAAC;gBAAC3B;gBAAeuB;mBAAqBG;aAAQ;QAC1D;IACF;IAEA,OAAOJ;AACT;AAEA;;;CAGC,GACD,MAAMZ,yBAAyB,CAC7BkB,iBACA1C;QAMOvB;IAJP,IAAIkE,MAAMC,OAAO,CAACF,oBAAoB,CAACC,MAAMC,OAAO,CAAC5C,UAAU;QAC7D,OAAO;IACT;IAEA,OAAOvB,CAAAA,CAAAA,yNAAAA,kBAAAA,EAAgBiE,gBAAAA,KAAAA,OAAAA,KAAAA,IAAhBjE,iBAAkCoC,KAAK,MAAKb,OAAO,CAAC,EAAE;AAC/D","ignoreList":[0]}},
    {"offset": {"line": 3504, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/encryption-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n"],"names":["InvariantError","normalizeAppPath","workAsyncStorage","__next_loaded_action_key","arrayBufferToString","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","stringToUint8Array","length","arr","charCodeAt","encrypt","key","iv","data","crypto","subtle","name","decrypt","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","setReferenceManifestsSingleton","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","getServerModuleMap","serverActionsManifestSingleton","getClientReferenceManifestForRsc","workStore","getStore","mergeClientReferenceManifests","route","getActionEncryptionKey","rawKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3674, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/postponed-state.ts"],"sourcesContent":["import type { FallbackRouteParams } from '../../server/request/fallback-params'\nimport type { Params } from '../request/params'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport enum DynamicState {\n  /**\n   * The dynamic access occurred during the RSC render phase.\n   */\n  DATA = 1,\n\n  /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */\n  HTML = 2,\n}\n\n/**\n * The postponed state for dynamic data.\n */\nexport type DynamicDataPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.DATA\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\n/**\n * The postponed state for dynamic HTML.\n */\nexport type DynamicHTMLPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.HTML\n\n  /**\n   * The postponed data used by React.\n   */\n  readonly data: object\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport async function getDynamicHTMLPostponedState(\n  data: object,\n  fallbackRouteParams: FallbackRouteParams | null,\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n    const postponedString = JSON.stringify(data)\n\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(\n      createRenderResumeDataCache(prerenderResumeDataCache)\n    )}`\n  }\n\n  const replacements: Array<[string, string]> = Array.from(fallbackRouteParams)\n  const replacementsString = JSON.stringify(replacements)\n  const dataString = JSON.stringify(data)\n\n  // Serialized as `<replacements.length><replacements><data>`\n  const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n\n  // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n  return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(prerenderResumeDataCache)}`\n}\n\nexport async function getDynamicDataPostponedState(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(prerenderResumeDataCache))}`\n}\n\nexport function parsePostponedState(\n  state: string,\n  params: Params | undefined\n): PostponedState {\n  try {\n    const postponedStringLengthMatch = state.match(/^([0-9]*):/)?.[1]\n    if (!postponedStringLengthMatch) {\n      throw new Error(`Invariant: invalid postponed state ${state}`)\n    }\n\n    const postponedStringLength = parseInt(postponedStringLengthMatch)\n\n    // We add a `:` to the end of the length as the first character of the\n    // postponed string is the length of the replacement entries.\n    const postponedString = state.slice(\n      postponedStringLengthMatch.length + 1,\n      postponedStringLengthMatch.length + postponedStringLength + 1\n    )\n\n    const renderResumeDataCache = createRenderResumeDataCache(\n      state.slice(postponedStringLengthMatch.length + postponedStringLength + 1)\n    )\n\n    try {\n      if (postponedString === 'null') {\n        return { type: DynamicState.DATA, renderResumeDataCache }\n      }\n\n      if (/^[0-9]/.test(postponedString)) {\n        const match = postponedString.match(/^([0-9]*)/)?.[1]\n        if (!match) {\n          throw new Error(\n            `Invariant: invalid postponed state ${JSON.stringify(postponedString)}`\n          )\n        }\n\n        // This is the length of the replacements entries.\n        const length = parseInt(match)\n        const replacements = JSON.parse(\n          postponedString.slice(\n            match.length,\n            // We then go to the end of the string.\n            match.length + length\n          )\n        ) as ReadonlyArray<[string, string]>\n\n        let postponed = postponedString.slice(match.length + length)\n        for (const [key, searchValue] of replacements) {\n          const value = params?.[key] ?? ''\n          const replaceValue = Array.isArray(value) ? value.join('/') : value\n          postponed = postponed.replaceAll(searchValue, replaceValue)\n        }\n\n        return {\n          type: DynamicState.HTML,\n          data: JSON.parse(postponed),\n          renderResumeDataCache,\n        }\n      }\n\n      return {\n        type: DynamicState.HTML,\n        data: JSON.parse(postponedString),\n        renderResumeDataCache,\n      }\n    } catch (err) {\n      console.error('Failed to parse postponed state', err)\n      return { type: DynamicState.DATA, renderResumeDataCache }\n    }\n  } catch (err) {\n    console.error('Failed to parse postponed state', err)\n    return {\n      type: DynamicState.DATA,\n      renderResumeDataCache: createPrerenderResumeDataCache(),\n    }\n  }\n}\n\nexport function getPostponedFromState(state: PostponedState): any {\n  if (state.type === DynamicState.DATA) {\n    return null\n  }\n\n  return state.data\n}\n"],"names":["createPrerenderResumeDataCache","createRenderResumeDataCache","stringifyResumeDataCache","DynamicState","getDynamicHTMLPostponedState","data","fallbackRouteParams","prerenderResumeDataCache","size","postponedString","JSON","stringify","length","replacements","Array","from","replacementsString","dataString","getDynamicDataPostponedState","parsePostponedState","state","params","postponedStringLengthMatch","match","Error","postponedStringLength","parseInt","slice","renderResumeDataCache","type","test","parse","postponed","key","searchValue","value","replaceValue","isArray","join","replaceAll","err","console","error","getPostponedFromState"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3790, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/use-flight-response.tsx"],"sourcesContent":["import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { BinaryStreamOf } from './app-render'\n\nimport { htmlEscapeJsonString } from '../htmlescape'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2\nconst INLINE_FLIGHT_PAYLOAD_BINARY = 3\n\nconst flightResponses = new WeakMap<BinaryStreamOf<any>, Promise<any>>()\nconst encoder = new TextEncoder()\n\n/**\n * Render Flight stream.\n * This is only used for renderToHTML, the Flight response does not need additional wrappers.\n */\nexport function useFlightStream<T>(\n  flightStream: BinaryStreamOf<T>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  nonce?: string\n): Promise<T> {\n  const response = flightResponses.get(flightStream)\n\n  if (response) {\n    return response\n  }\n\n  // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n  let createFromReadableStream\n  // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  const newResponse = createFromReadableStream(flightStream, {\n    serverConsumerManifest: {\n      moduleLoading: clientReferenceManifest.moduleLoading,\n      moduleMap: isEdgeRuntime\n        ? clientReferenceManifest.edgeSSRModuleMapping\n        : clientReferenceManifest.ssrModuleMapping,\n      serverModuleMap: null,\n    },\n    nonce,\n  })\n\n  flightResponses.set(flightStream, newResponse)\n\n  return newResponse\n}\n\n/**\n * Creates a ReadableStream provides inline script tag chunks for writing hydration\n * data to the client outside the React render itself.\n *\n * @param flightStream The RSC render stream\n * @param nonce optionally a nonce used during this particular render\n * @param formState optionally the formState used with this particular render\n * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream\n */\nexport function createInlinedDataReadableStream(\n  flightStream: ReadableStream<Uint8Array>,\n  nonce: string | undefined,\n  formState: unknown | null\n): ReadableStream<Uint8Array> {\n  const startScriptTag = nonce\n    ? `<script nonce=${JSON.stringify(nonce)}>`\n    : '<script>'\n\n  const flightReader = flightStream.getReader()\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n\n  const readable = new ReadableStream({\n    type: 'bytes',\n    start(controller) {\n      try {\n        writeInitialInstructions(controller, startScriptTag, formState)\n      } catch (error) {\n        // during encoding or enqueueing forward the error downstream\n        controller.error(error)\n      }\n    },\n    async pull(controller) {\n      try {\n        const { done, value } = await flightReader.read()\n\n        if (value) {\n          try {\n            const decodedString = decoder.decode(value, { stream: !done })\n\n            // The chunk cannot be decoded as valid UTF-8 string as it might\n            // have arbitrary binary data.\n            writeFlightDataInstruction(\n              controller,\n              startScriptTag,\n              decodedString\n            )\n          } catch {\n            // The chunk cannot be decoded as valid UTF-8 string.\n            writeFlightDataInstruction(controller, startScriptTag, value)\n          }\n        }\n\n        if (done) {\n          controller.close()\n        }\n      } catch (error) {\n        // There was a problem in the upstream reader or during decoding or enqueuing\n        // forward the error downstream\n        controller.error(error)\n      }\n    },\n  })\n\n  return readable\n}\n\nfunction writeInitialInstructions(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  formState: unknown | null\n) {\n  if (formState != null) {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )});self.__next_f.push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_FORM_STATE, formState])\n        )})</script>`\n      )\n    )\n  } else {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )})</script>`\n      )\n    )\n  }\n}\n\nfunction writeFlightDataInstruction(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  chunk: string | Uint8Array\n) {\n  let htmlInlinedData: string\n\n  if (typeof chunk === 'string') {\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_DATA, chunk])\n    )\n  } else {\n    // The chunk cannot be embedded as a UTF-8 string in the script tag.\n    // Instead let's inline it in base64.\n    // Credits to Devon Govett (devongovett) for the technique.\n    // https://github.com/devongovett/rsc-html-stream\n    const base64 = btoa(String.fromCodePoint(...chunk))\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_BINARY, base64])\n    )\n  }\n\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}self.__next_f.push(${htmlInlinedData})</script>`\n    )\n  )\n}\n"],"names":["htmlEscapeJsonString","isEdgeRuntime","process","env","NEXT_RUNTIME","INLINE_FLIGHT_PAYLOAD_BOOTSTRAP","INLINE_FLIGHT_PAYLOAD_DATA","INLINE_FLIGHT_PAYLOAD_FORM_STATE","INLINE_FLIGHT_PAYLOAD_BINARY","flightResponses","WeakMap","encoder","TextEncoder","useFlightStream","flightStream","clientReferenceManifest","nonce","response","get","createFromReadableStream","TURBOPACK","require","newResponse","serverConsumerManifest","moduleLoading","moduleMap","edgeSSRModuleMapping","ssrModuleMapping","serverModuleMap","set","createInlinedDataReadableStream","formState","startScriptTag","JSON","stringify","flightReader","getReader","decoder","TextDecoder","fatal","readable","ReadableStream","type","start","controller","writeInitialInstructions","error","pull","done","value","read","decodedString","decode","stream","writeFlightDataInstruction","close","scriptStart","enqueue","encode","chunk","htmlInlinedData","base64","btoa","String","fromCodePoint"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3911, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render-prerender-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function prerenderAndAbortInSequentialTasks<R>(\n  prerender: () => Promise<R>,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        abort()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let result: ServerPrerenderStreamResult\n\n      signal.addEventListener(\n        'abort',\n        () => {\n          if (isPrerenderInterruptedError(signal.reason)) {\n            result.markInterrupted()\n          } else {\n            result.markComplete()\n          }\n        },\n        {\n          once: true,\n        }\n      )\n\n      setImmediate(() => {\n        try {\n          result = new ServerPrerenderStreamResult(render())\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          if (result) {\n            result.markComplete()\n            this()\n          }\n          resolve(result)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          if (result) {\n            result.markPhase()\n            this()\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\nconst PENDING = 0\nconst COMPLETE = 1\nconst INTERRUPTED = 2\nconst ERRORED = 3\n\nexport class ServerPrerenderStreamResult {\n  private currentChunks: Array<Uint8Array>\n  private chunksByPhase: Array<Array<Uint8Array>>\n  private trailingChunks: Array<Uint8Array>\n  private status: 0 | 1 | 2 | 3\n  private reason: null | unknown\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this.status = PENDING\n    this.reason = null\n\n    this.trailingChunks = []\n    this.currentChunks = []\n    this.chunksByPhase = [this.currentChunks]\n\n    const reader = stream.getReader()\n\n    const progress = ({\n      done,\n      value,\n    }: ReadableStreamReadResult<Uint8Array>) => {\n      if (done) {\n        if (this.status === PENDING) {\n          this.status = COMPLETE\n        }\n        return\n      }\n      if (this.status === PENDING || this.status === INTERRUPTED) {\n        this.currentChunks.push(value)\n      } else {\n        this.trailingChunks.push(value)\n      }\n      reader.read().then(progress, error)\n    }\n    const error = (reason: unknown) => {\n      this.status = ERRORED\n      this.reason = reason\n    }\n\n    reader.read().then(progress, error)\n  }\n\n  markPhase() {\n    this.currentChunks = []\n    this.chunksByPhase.push(this.currentChunks)\n  }\n\n  markComplete() {\n    if (this.status === PENDING) {\n      this.status = COMPLETE\n    }\n  }\n\n  markInterrupted() {\n    this.status = INTERRUPTED\n  }\n\n  /**\n   * Returns a stream which only releases chunks when `releasePhase` is called. This stream will never \"complete\" because\n   * we rely upon the stream remaining open when prerendering to avoid triggering errors for incomplete chunks in the client.\n   *\n   * asPhasedStream is expected to be called once per result however it is safe to call multiple times as long as we have not\n   * transferred the underlying data. Generally this will only happen when streaming to a response\n   */\n  asPhasedStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        return new PhasedStream(this.chunksByPhase)\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n\n  /**\n   * Returns a stream which will release all chunks immediately. This stream will \"complete\" synchronously. It should be used outside\n   * of render use cases like loading client chunks ahead of SSR or writing the streamed content to disk.\n   */\n  asStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        const chunksByPhase = this.chunksByPhase\n        const trailingChunks = this.trailingChunks\n        return new ReadableStream({\n          start(controller) {\n            for (let i = 0; i < chunksByPhase.length; i++) {\n              const chunks = chunksByPhase[i]\n              for (let j = 0; j < chunks.length; j++) {\n                controller.enqueue(chunks[j])\n              }\n            }\n            for (let i = 0; i < trailingChunks.length; i++) {\n              controller.enqueue(trailingChunks[i])\n            }\n            controller.close()\n          },\n        })\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n}\n\nclass PhasedStream<T> extends ReadableStream<T> {\n  private nextPhase: number\n  private chunksByPhase: Array<Array<T>>\n  private destination: ReadableStreamDefaultController<T>\n\n  constructor(chunksByPhase: Array<Array<T>>) {\n    if (chunksByPhase.length === 0) {\n      throw new InvariantError(\n        'PhasedStream expected at least one phase but none were found.'\n      )\n    }\n\n    let destination: ReadableStreamDefaultController<T>\n    super({\n      start(controller) {\n        destination = controller\n      },\n    })\n\n    // the start function above is called synchronously during construction so we will always have a destination\n    // We wait to assign it until after the super call because we cannot access `this` before calling super\n    this.destination = destination!\n    this.nextPhase = 0\n    this.chunksByPhase = chunksByPhase\n    this.releasePhase()\n  }\n\n  releasePhase() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      const chunks = this.chunksByPhase[this.nextPhase++]\n      for (let i = 0; i < chunks.length; i++) {\n        this.destination.enqueue(chunks[i])\n      }\n    } else {\n      throw new InvariantError(\n        'PhasedStream expected more phases to release but none were found.'\n      )\n    }\n  }\n\n  assertExhausted() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      throw new InvariantError(\n        'PhasedStream expected no more phases to release but some were found.'\n      )\n    }\n  }\n}\n\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  ...remainingPhases: Array<() => void>\n): Promise<T> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<T>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n          pendingResult.catch((err) => reject(err))\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          this()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          this()\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\n// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream\n// in one that doesn't close even when the underlying is complete.\nexport class ReactServerResult {\n  private _stream: null | ReadableStream<Uint8Array>\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this._stream = stream\n  }\n\n  tee() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot tee a ReactServerResult that has already been consumed'\n      )\n    }\n    const tee = this._stream.tee()\n    this._stream = tee[0]\n    return tee[1]\n  }\n\n  consume() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot consume a ReactServerResult that has already been consumed'\n      )\n    }\n    const stream = this._stream\n    this._stream = null\n    return stream\n  }\n}\n\nexport type ReactServerPrerenderResolveToType = {\n  prelude: ReadableStream<Uint8Array>\n}\n\nexport async function createReactServerPrerenderResult(\n  underlying: Promise<ReactServerPrerenderResolveToType>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const { prelude } = await underlying\n  const reader = prelude.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      return new ReactServerPrerenderResult(chunks)\n    } else {\n      chunks.push(value)\n    }\n  }\n}\n\nexport async function createReactServerPrerenderResultFromRender(\n  underlying: ReadableStream<Uint8Array>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const reader = underlying.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    } else {\n      chunks.push(value)\n    }\n  }\n  return new ReactServerPrerenderResult(chunks)\n}\nexport class ReactServerPrerenderResult {\n  private _chunks: null | Array<Uint8Array>\n\n  private assertChunks(expression: string): Array<Uint8Array> {\n    if (this._chunks === null) {\n      throw new InvariantError(\n        `Cannot \\`${expression}\\` on a ReactServerPrerenderResult that has already been consumed.`\n      )\n    }\n    return this._chunks\n  }\n\n  private consumeChunks(expression: string): Array<Uint8Array> {\n    const chunks = this.assertChunks(expression)\n    this.consume()\n    return chunks\n  }\n\n  consume(): void {\n    this._chunks = null\n  }\n\n  constructor(chunks: Array<Uint8Array>) {\n    this._chunks = chunks\n  }\n\n  asUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  consumeAsUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  asStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asStream()')\n    return createClosingStream(chunks)\n  }\n\n  consumeAsStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsStream()')\n    return createClosingStream(chunks)\n  }\n}\n\nfunction createUnclosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      }\n      // we intentionally keep the stream open. The consumer will clear\n      // out chunks once finished and the remaining memory will be GC'd\n      // when this object goes out of scope\n    },\n  })\n}\n\nfunction createClosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      } else {\n        controller.close()\n      }\n    },\n  })\n}\n"],"names":["InvariantError","isPrerenderInterruptedError","prerenderAndAbortInSequentialTasks","prerender","abort","process","env","NEXT_RUNTIME","Promise","resolve","reject","pendingResult","setImmediate","catch","err","prerenderServerWithPhases","signal","render","remainingPhases","result","addEventListener","reason","markInterrupted","markComplete","once","ServerPrerenderStreamResult","runFinalTask","runNextTask","markPhase","i","length","phase","bind","finalPhase","PENDING","COMPLETE","INTERRUPTED","ERRORED","constructor","stream","status","trailingChunks","currentChunks","chunksByPhase","reader","getReader","progress","done","value","push","read","then","error","asPhasedStream","PhasedStream","asStream","ReadableStream","start","controller","chunks","j","enqueue","close","destination","nextPhase","releasePhase","assertExhausted","prerenderClientWithPhases","ReactServerResult","_stream","tee","Error","consume","createReactServerPrerenderResult","underlying","prelude","ReactServerPrerenderResult","createReactServerPrerenderResultFromRender","assertChunks","expression","_chunks","consumeChunks","asUnclosingStream","createUnclosingStream","consumeAsUnclosingStream","createClosingStream","consumeAsStream","pull"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4226, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/prospective-render-utils.ts"],"sourcesContent":["import { getDigestForWellKnownError } from './create-error-handler'\n\nexport function printDebugThrownValueForProspectiveRender(\n  thrownValue: unknown,\n  route: string\n) {\n  // We don't need to print well-known Next.js errors.\n  if (getDigestForWellKnownError(thrownValue)) {\n    return\n  }\n\n  let message: undefined | string\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    typeof (thrownValue as any).message === 'string'\n  ) {\n    message = (thrownValue as any).message\n    if (typeof (thrownValue as any).stack === 'string') {\n      const originalErrorStack: string = (thrownValue as any).stack\n      const stackStart = originalErrorStack.indexOf('\\n')\n      if (stackStart > -1) {\n        const error = new Error(\n          `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.\n          \nOriginal Error: ${message}`\n        )\n        error.stack =\n          'Error: ' + error.message + originalErrorStack.slice(stackStart)\n        console.error(error)\n        return\n      }\n    }\n  } else if (typeof thrownValue === 'string') {\n    message = thrownValue\n  }\n\n  if (message) {\n    console.error(`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.\n          \nOriginal Message: ${message}`)\n    return\n  }\n\n  console.error(\n    `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`\n  )\n  console.error(thrownValue)\n  return\n}\n"],"names":["getDigestForWellKnownError","printDebugThrownValueForProspectiveRender","thrownValue","route","message","stack","originalErrorStack","stackStart","indexOf","error","Error","slice","console"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,yBAAwB;;AAE5D,SAASC,0CACdC,WAAoB,EACpBC,KAAa;IAEb,oDAAoD;IACpD,6MAAIH,6BAAAA,EAA2BE,cAAc;QAC3C;IACF;IAEA,IAAIE;IACJ,IACE,OAAOF,gBAAgB,YACvBA,gBAAgB,QAChB,OAAQA,YAAoBE,OAAO,KAAK,UACxC;QACAA,UAAWF,YAAoBE,OAAO;QACtC,IAAI,OAAQF,YAAoBG,KAAK,KAAK,UAAU;YAClD,MAAMC,qBAA8BJ,YAAoBG,KAAK;YAC7D,MAAME,aAAaD,mBAAmBE,OAAO,CAAC;YAC9C,IAAID,aAAa,CAAC,GAAG;gBACnB,MAAME,QAAQ,OAAA,cAIb,CAJa,IAAIC,MAChB,CAAC,MAAM,EAAEP,MAAM;;gBAET,EAAEC,SAAS,GAHL,qBAAA;2BAAA;gCAAA;kCAAA;gBAId;gBACAK,MAAMJ,KAAK,GACT,YAAYI,MAAML,OAAO,GAAGE,mBAAmBK,KAAK,CAACJ;gBACvDK,QAAQH,KAAK,CAACA;gBACd;YACF;QACF;IACF,OAAO,IAAI,OAAOP,gBAAgB,UAAU;QAC1CE,UAAUF;IACZ;IAEA,IAAIE,SAAS;QACXQ,QAAQH,KAAK,CAAC,CAAC,MAAM,EAAEN,MAAM;;kBAEf,EAAEC,SAAS;QACzB;IACF;IAEAQ,QAAQH,KAAK,CACX,CAAC,MAAM,EAAEN,MAAM,wOAAwO,CAAC;IAE1PS,QAAQH,KAAK,CAACP;IACd;AACF","ignoreList":[0]}},
    {"offset": {"line": 4274, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render-render-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function scheduleInSequentialTasks<R>(\n  render: () => R | Promise<R>,\n  followup: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`scheduleInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: R | Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        followup()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n"],"names":["InvariantError","scheduleInSequentialTasks","render","followup","process","env","NEXT_RUNTIME","Promise","resolve","reject","pendingResult","setImmediate","err"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;;AAM1D,SAASC,0BACdC,MAA4B,EAC5BC,QAAoB;IAEpB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIN,iBAAAA,CACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAeP;AACF","ignoreList":[0]}},
    {"offset": {"line": 4296, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the dynamicIO flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nexport class CacheSignal {\n  private count: number\n  private earlyListeners: Array<() => void>\n  private listeners: Array<() => void>\n  private tickPending: boolean\n  private taskPending: boolean\n\n  constructor() {\n    this.count = 0\n    this.earlyListeners = []\n    this.listeners = []\n    this.tickPending = false\n    this.taskPending = false\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      process.nextTick(() => {\n        this.tickPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.earlyListeners.length; i++) {\n            this.earlyListeners[i]()\n          }\n          this.earlyListeners.length = 0\n        }\n      })\n    }\n    if (!this.taskPending) {\n      this.taskPending = true\n      setTimeout(() => {\n        this.taskPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.listeners.length; i++) {\n            this.listeners[i]()\n          }\n          this.listeners.length = 0\n        }\n      }, 0)\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n  }\n\n  endRead() {\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n  }\n}\n"],"names":["CacheSignal","constructor","count","earlyListeners","listeners","tickPending","taskPending","noMorePendingCaches","process","nextTick","i","length","setTimeout","inputReady","Promise","resolve","push","cacheReady","beginRead","endRead"],"mappings":"AAAA;;;;;CAKC,GAED;;;AAAO,MAAMA;IAOXC,aAAc;QACZ,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,cAAc,GAAG,EAAE;QACxB,IAAI,CAACC,SAAS,GAAG,EAAE;QACnB,IAAI,CAACC,WAAW,GAAG;QACnB,IAAI,CAACC,WAAW,GAAG;IACrB;IAEQC,sBAAsB;QAC5B,IAAI,CAAC,IAAI,CAACF,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBG,QAAQC,QAAQ,CAAC;gBACf,IAAI,CAACJ,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACH,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACP,cAAc,CAACQ,MAAM,EAAED,IAAK;wBACnD,IAAI,CAACP,cAAc,CAACO,EAAE;oBACxB;oBACA,IAAI,CAACP,cAAc,CAACQ,MAAM,GAAG;gBAC/B;YACF;QACF;QACA,IAAI,CAAC,IAAI,CAACL,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBM,WAAW;gBACT,IAAI,CAACN,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACJ,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAED,IAAK;wBAC9C,IAAI,CAACN,SAAS,CAACM,EAAE;oBACnB;oBACA,IAAI,CAACN,SAAS,CAACO,MAAM,GAAG;gBAC1B;YACF,GAAG;QACL;IACF;IAEA;;;GAGC,GACDE,aAAa;QACX,OAAO,IAAIC,QAAc,CAACC;YACxB,IAAI,CAACZ,cAAc,CAACa,IAAI,CAACD;YACzB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEA;;;;GAIC,GACDU,aAAa;QACX,OAAO,IAAIH,QAAc,CAACC;YACxB,IAAI,CAACX,SAAS,CAACY,IAAI,CAACD;YACpB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEAW,YAAY;QACV,IAAI,CAAChB,KAAK;IACZ;IAEAiB,UAAU;QACR,4FAA4F;QAC5F,kGAAkG;QAClG,gGAAgG;QAChG,2BAA2B;QAC3B,+GAA+G;QAC/G,mHAAmH;QACnH,IAAI,CAACjB,KAAK;QACV,IAAI,IAAI,CAACA,KAAK,KAAK,GAAG;YACpB,IAAI,CAACK,mBAAmB;QAC1B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4383, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/clean-async-snapshot-instance.ts"],"sourcesContent":["import { createSnapshot } from '../app-render/async-local-storage'\n\nexport const runInCleanSnapshot: <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R = createSnapshot()\n"],"names":["createSnapshot","runInCleanSnapshot"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,oCAAmC;;AAE3D,MAAMC,gOAGJD,iBAAAA,GAAgB","ignoreList":[0]}},
    {"offset": {"line": 4395, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/clean-async-snapshot.external.ts"],"sourcesContent":["// Share the instance module in the next-shared layer\nimport { runInCleanSnapshot } from './clean-async-snapshot-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport { runInCleanSnapshot }\n"],"names":["runInCleanSnapshot"],"mappings":"AAAA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 4415, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/render-to-string.tsx"],"sourcesContent":["import { streamToString } from '../stream-utils/node-web-streams-helper'\n\nexport async function renderToString({\n  renderToReadableStream,\n  element,\n}: {\n  // `renderToReadableStream()` method could come from different react-dom/server implementations\n  // such as `react-dom/server.edge` or `react-dom/server.node`, etc.\n  renderToReadableStream: typeof import('react-dom/server.edge').renderToReadableStream\n  element: React.ReactElement\n}): Promise<string> {\n  const renderStream = await renderToReadableStream(element)\n  await renderStream.allReady\n  return streamToString(renderStream)\n}\n"],"names":["streamToString","renderToString","renderToReadableStream","element","renderStream","allReady"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,0CAAyC;;AAEjE,eAAeC,eAAe,EACnCC,sBAAsB,EACtBC,OAAO,EAMR;IACC,MAAMC,eAAe,MAAMF,uBAAuBC;IAClD,MAAMC,aAAaC,QAAQ;IAC3B,wNAAOL,iBAAAA,EAAeI;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4431, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/metadata-insertion/create-server-inserted-metadata.tsx"],"sourcesContent":["import React from 'react'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport {\n  ServerInsertedMetadataContext,\n  type MetadataResolver,\n} from '../../../shared/lib/server-inserted-metadata.shared-runtime'\nimport { renderToString } from '../render-to-string'\n\n/**\n * For chromium based browsers (Chrome, Edge, etc.) and Safari,\n * icons need to stay under <head> to be picked up by the browser.\n *\n */\nconst REINSERT_ICON_SCRIPT = `\\\ndocument.querySelectorAll('body link[rel=\"icon\"], body link[rel=\"apple-touch-icon\"]').forEach(el => document.head.appendChild(el))`\n\nexport function createServerInsertedMetadata(nonce: string | undefined) {\n  let metadataResolver: MetadataResolver | null = null\n  let metadataToFlush: React.ReactNode = null\n  const setMetadataResolver = (resolver: MetadataResolver): void => {\n    metadataResolver = resolver\n  }\n\n  return {\n    ServerInsertedMetadataProvider: ({\n      children,\n    }: {\n      children: React.ReactNode\n    }) => {\n      return (\n        <ServerInsertedMetadataContext.Provider value={setMetadataResolver}>\n          {children}\n        </ServerInsertedMetadataContext.Provider>\n      )\n    },\n\n    async getServerInsertedMetadata(): Promise<string> {\n      if (!metadataResolver || metadataToFlush) {\n        return ''\n      }\n\n      metadataToFlush = metadataResolver()\n      const html = await renderToString({\n        renderToReadableStream,\n        element: (\n          <>\n            {metadataToFlush}\n            <script nonce={nonce}>{REINSERT_ICON_SCRIPT}</script>\n          </>\n        ),\n      })\n\n      return html\n    },\n  }\n}\n"],"names":["React","renderToReadableStream","ServerInsertedMetadataContext","renderToString","REINSERT_ICON_SCRIPT","createServerInsertedMetadata","nonce","metadataResolver","metadataToFlush","setMetadataResolver","resolver","ServerInsertedMetadataProvider","children","Provider","value","getServerInsertedMetadata","html","element","script"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SACEC,6BAA6B,QAExB,8DAA6D;AACpE,SAASC,cAAc,QAAQ,sBAAqB;;;;;;AAEpD;;;;CAIC,GACD,MAAMC,uBAAuB,CAAC;kIACoG,CAAC;AAE5H,SAASC,6BAA6BC,KAAyB;IACpE,IAAIC,mBAA4C;IAChD,IAAIC,kBAAmC;IACvC,MAAMC,sBAAsB,CAACC;QAC3BH,mBAAmBG;IACrB;IAEA,OAAO;QACLC,gCAAgC,CAAC,EAC/BC,QAAQ,EAGT;YACC,OAAA,WAAA,IACE,wMAAA,+MAACV,gCAAAA,CAA8BW,QAAQ,EAAA;gBAACC,OAAOL;0BAC5CG;;QAGP;QAEA,MAAMG;YACJ,IAAI,CAACR,oBAAoBC,iBAAiB;gBACxC,OAAO;YACT;YAEAA,kBAAkBD;YAClB,MAAMS,OAAO,2MAAMb,iBAAAA,EAAe;2NAChCF,yBAAAA;gBACAgB,SAAAA,WAAAA,sMACE,OAAA,EAAA,8LAAA,CAAA,WAAA,EAAA;;wBACGT;yOACD,MAAA,EAACU,UAAAA;4BAAOZ,OAAOA;sCAAQF;;;;YAG7B;YAEA,OAAOY;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4490, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from './types'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  ClientReferenceManifest,\n  ManifestNode,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  getFirstDynamicReason,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  consumeDynamicAccess,\n  type DynamicAccess,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../shared/lib/router/action-queue'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { ServerPrerenderStreamResult } from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n  prerenderServerWithPhases,\n  prerenderClientWithPhases,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport './clean-async-snapshot.external'\nimport { INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n}\n\nconst flightDataPathHeadKey = 'h'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isPrefetchRequest =\n    isDevWarmupRequest ||\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest =\n    isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\nfunction createDivergedMetadataComponents(\n  Metadata: React.ComponentType,\n  serveStreamingMetadata: boolean\n): {\n  StaticMetadata: React.ComponentType<{}>\n  StreamingMetadata: React.ComponentType<{}> | null\n} {\n  function EmptyMetadata() {\n    return null\n  }\n  const StreamingMetadata: React.ComponentType | null = serveStreamingMetadata\n    ? Metadata\n    : null\n\n  const StaticMetadata: React.ComponentType<{}> = serveStreamingMetadata\n    ? EmptyMetadata\n    : Metadata\n\n  return {\n    StaticMetadata,\n    StreamingMetadata,\n  }\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({ ctx }: { ctx: AppRenderContext }) {\n  const is404Page = ctx.pagePath === '/404'\n  const isInvalidStatusCode =\n    typeof ctx.res.statusCode === 'number' && ctx.res.statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  if (!ctx.isAction && (is404Page || isInvalidStatusCode)) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const searchParams = createServerSearchParamsForMetadata(query, workStore)\n    const {\n      ViewportTree,\n      MetadataTree,\n      getViewportReady,\n      getMetadataReady,\n      StreamingMetadataOutlet,\n    } = createMetadataComponents({\n      tree: loaderTree,\n      searchParams,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        workStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createServerParamsForMetadata,\n      workStore,\n      MetadataBoundary,\n      ViewportBoundary,\n      serveStreamingMetadata,\n    })\n\n    const { StreamingMetadata, StaticMetadata } =\n      createDivergedMetadataComponents(() => {\n        return (\n          // Adding requestId as react key to make metadata remount for each render\n          <MetadataTree key={requestId} />\n        )\n      }, serveStreamingMetadata)\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            {/* noindex needs to be blocking */}\n            <NonIndex ctx={ctx} />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <ViewportTree key={requestId} />\n            {StreamingMetadata ? <StreamingMetadata /> : null}\n            <StaticMetadata />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        StreamingMetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    routeType: ctx.isAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during dynamicIO development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  if (\n    // We only want this behavior when running `next dev`\n    renderOpts.dev &&\n    // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' &&\n    // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO\n  ) {\n    const [resolveValidation, validationOutlet] = createValidationOutlet()\n    RSCPayload._validation = validationOutlet\n\n    spawnDynamicValidationInDev(\n      resolveValidation,\n      ctx.componentMod.tree,\n      ctx,\n      false,\n      ctx.clientReferenceManifest,\n      ctx.workStore.route,\n      requestStore\n    )\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    ctx.componentMod.renderToReadableStream,\n    RSCPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n  if (!renderOpts.dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  const rootParams = getRootParams(\n    ctx.componentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  // We're doing a dev warmup, so we should create a new resume data cache so\n  // we can fill it.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const renderController = new AbortController()\n  const prerenderController = new AbortController()\n  const cacheSignal = new CacheSignal()\n\n  const prerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: renderController.signal,\n    controller: prerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const rscPayload = await workUnitAsyncStorage.run(\n    prerenderStore,\n    generateDynamicRSCPayload,\n    ctx\n  )\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  workUnitAsyncStorage.run(\n    prerenderStore,\n    ctx.componentMod.renderToReadableStream,\n    rscPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      signal: renderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling\n  await cacheSignal.cacheReady()\n  // We unset the cache so any late over-run renders aren't able to write into this cache\n  prerenderStore.prerenderResumeDataCache = null\n  // Abort the render\n  renderController.abort()\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n    devRenderResumeDataCache: createRenderResumeDataCache(\n      prerenderResumeDataCache\n    ),\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const {\n    ViewportTree,\n    MetadataTree,\n    getViewportReady,\n    getMetadataReady,\n    StreamingMetadataOutlet,\n  } = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    searchParams,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      workStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const { StreamingMetadata, StaticMetadata } =\n    createDivergedMetadataComponents(() => {\n      return (\n        // Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed\n        <MetadataTree />\n      )\n    }, serveStreamingMetadata)\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getViewportReady,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    StreamingMetadata,\n    StreamingMetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      <ViewportTree key={ctx.requestId} />\n      <StaticMetadata />\n    </React.Fragment>\n  )\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    requestId,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const { MetadataTree, ViewportTree } = createMetadataComponents({\n    tree,\n    searchParams,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  const { StreamingMetadata, StaticMetadata } =\n    createDivergedMetadataComponents(\n      () => (\n        <React.Fragment key={flightDataPathHeadKey}>\n          {/* Adding requestId as react key to make metadata remount for each render */}\n          <MetadataTree key={requestId} />\n        </React.Fragment>\n      ),\n      serveStreamingMetadata\n    )\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <ViewportTree key={requestId} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n      <StaticMetadata />\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head>{StreamingMetadata ? <StreamingMetadata /> : null}</head>\n      <body>\n        {process.env.NODE_ENV !== 'production' && err ? (\n          <template\n            data-next-error-message={err.message}\n            data-next-error-digest={'digest' in err ? err.digest : ''}\n            data-next-error-stack={err.stack}\n          />\n        ) : null}\n      </body>\n    </html>,\n    {},\n    null,\n    false,\n  ]\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n  ServerInsertedHTMLProvider,\n  ServerInsertedMetadataProvider,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedMetadataProvider>\n        <ServerInsertedHTMLProvider>\n          <AppRouter\n            actionQueue={actionQueue}\n            globalErrorComponentAndStyles={response.G}\n            assetPrefix={response.p}\n          />\n        </ServerInsertedHTMLProvider>\n      </ServerInsertedMetadataProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction AppWithoutContext<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  return (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorComponentAndStyles={response.G}\n      assetPrefix={response.p}\n    />\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null,\n  implicitTags: Array<string>,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n\n  setReferenceManifestsSingleton({\n    page: workStore.page,\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = workStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isActionRequest = getServerActionRequestMetadata(req).isServerAction\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isAction: isActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      workStore,\n      loaderTree,\n      implicitTags\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      const pendingPromise = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ]).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    if (response.collectedTags) {\n      metadata.fetchTags = response.collectedTags.join(',')\n    }\n\n    // Let the client router know how long to keep the cached entry around.\n    const staleHeader = String(response.collectedStale)\n    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n    metadata.headers ??= {}\n    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n      metadata.cacheControl = { revalidate: 0, expire: undefined }\n    } else {\n      // Copy the cache control value onto the render result metadata.\n      metadata.cacheControl = {\n        revalidate:\n          response.collectedRevalidate >= INFINITE_CACHE\n            ? false\n            : response.collectedRevalidate,\n        expire:\n          response.collectedExpire >= INFINITE_CACHE\n            ? undefined\n            : response.collectedExpire,\n      }\n    }\n\n    // provide bailout info for debugging\n    if (metadata.cacheControl?.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: workStore.dynamicUsageDescription,\n        stack: workStore.dynamicUsageStack,\n      }\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.devRenderResumeDataCache ??\n      postponedState?.renderResumeDataCache\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const requestStore = createRequestStoreForRender(\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache\n    )\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req) &&\n      !isDevWarmupRequest\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        if (!requestStore.usedDynamic && !workStore.forceDynamic) {\n          // only node can be ISR so we only need to update the status here\n          const { pathname } = new URL(req.url || '/', 'http://n')\n          setIsrStatus(pathname, true)\n        }\n      })\n    }\n\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx, requestStore)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            workStore,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      workStore,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      const pendingPromise = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ]).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  isDevWarmup: boolean,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  isDevWarmup,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n  })\n\n  const { isPrefetchRequest } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.devRenderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const implicitTags = getImplicitTags(\n    renderOpts.routeModule.definition.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    requestEndedState,\n    postponedState,\n    implicitTags,\n    serverComponentsHmrCache,\n    sharedContext\n  )\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n  const appendHeader = res.appendHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      renderOpts.dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into dynamicIO\n      renderOpts.experimental.dynamicIO\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during dynamicIO development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n              filterStackFrame(url: string, _functionName: string): boolean {\n                // The default implementation filters out <anonymous> stack frames\n                // but we want to retain them because current Server Components and\n                // built-in Components in parent stacks don't have source location.\n                return !url.startsWith('node:') && !url.includes('node_modules')\n              },\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      spawnDynamicValidationInDev(\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        workStore.route,\n        requestStore\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            appendHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        bootstrapScripts: [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML =\n      renderOpts.supportsDynamicResponse !== true ||\n      !!renderOpts.shouldWaitOnAllReady\n\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      getServerInsertedMetadata,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer: require('react-dom/server.edge'),\n          element: (\n            <AppWithoutContext\n              reactServerStream={errorServerStream}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={ctx.nonce}\n            />\n          ),\n          streamOptions: {\n            nonce: ctx.nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        renderOpts.supportsDynamicResponse !== true ||\n        !!renderOpts.shouldWaitOnAllReady\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        getServerInsertedMetadata,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  route: string,\n  requestStore: RequestStore\n): Promise<void> {\n  const { componentMod: ComponentMod } = ctx\n  const rootParams = getRootParams(\n    ComponentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  const cacheSignal = new CacheSignal()\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  const initialServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const initialClientController = new AbortController()\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: initialClientController.signal,\n    controller: initialClientController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  let initialServerStream\n  try {\n    initialServerStream = workUnitAsyncStorage.run(\n      initialServerPrerenderStore,\n      ComponentMod.renderToReadableStream,\n      firstAttemptRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // The render aborted before this error was handled which indicates\n            // the error is caused by unfinished components within the render\n            return\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n        signal: initialServerRenderController.signal,\n      }\n    )\n  } catch (err: unknown) {\n    if (\n      initialServerPrerenderController.signal.aborted ||\n      initialServerRenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, route)\n    }\n  }\n\n  const nonce = '1'\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n\n  if (initialServerStream) {\n    const [warmupStream, renderStream] = initialServerStream.tee()\n    initialServerStream = null\n    // Before we attempt the SSR initial render we need to ensure all client modules\n    // are already loaded.\n    await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    const pendingInitialClientResult = workUnitAsyncStorage.run(\n      initialClientPrerenderStore,\n      prerender,\n      <App\n        reactServerStream={renderStream}\n        preinitScripts={() => {}}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={nonce}\n      />,\n      {\n        signal: initialClientController.signal,\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (initialClientController.signal.aborted) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n      }\n    )\n    pendingInitialClientResult.catch((err: unknown) => {\n      if (initialClientController.signal.aborted) {\n        // We aborted the render normally and can ignore this error\n      } else {\n        // We're going to retry to so we normally would suppress this error but\n        // when verbose logging is on we print it\n        if (process.env.__NEXT_VERBOSE_LOGGING) {\n          printDebugThrownValueForProspectiveRender(err, route)\n        }\n      }\n    })\n  }\n\n  await cacheSignal.cacheReady()\n  // It is important that we abort the SSR render first to avoid\n  // connection closed errors from having an incomplete RSC stream\n  initialClientController.abort()\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We've now filled caches and triggered any inadvertent sync bailouts\n  // due to lazy module initialization. We can restart our render to capture results\n\n  const finalServerController = new AbortController()\n  const serverDynamicTracking = createDynamicTrackingState(false)\n\n  const finalServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const finalClientController = new AbortController()\n  const clientDynamicTracking = createDynamicTrackingState(false)\n  const dynamicValidation = createDynamicValidationState()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: finalClientController.signal,\n    controller: finalClientController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const finalServerPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const serverPrerenderStreamResult = await prerenderServerWithPhases(\n    finalServerController.signal,\n    () =>\n      workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.renderToReadableStream,\n        finalServerPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: (err) => {\n            if (isUseCacheTimeoutError(err)) {\n              return err.digest\n            }\n\n            if (\n              finalServerController.signal.aborted &&\n              isPrerenderInterruptedError(err)\n            ) {\n              return err.digest\n            }\n\n            return getDigestForWellKnownError(err)\n          },\n          signal: finalServerController.signal,\n        }\n      ),\n    () => {\n      finalServerController.abort()\n    }\n  )\n\n  let rootDidError = false\n  const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n  try {\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    await prerenderClientWithPhases(\n      () =>\n        workUnitAsyncStorage.run(\n          finalClientPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={serverPhasedStream}\n            preinitScripts={() => {}}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          {\n            signal: finalClientController.signal,\n            onError: (err, errorInfo) => {\n              if (isUseCacheTimeoutError(err)) {\n                dynamicValidation.dynamicErrors.push(err)\n\n                return\n              }\n\n              if (\n                isPrerenderInterruptedError(err) ||\n                finalClientController.signal.aborted\n              ) {\n                if (!rootDidError) {\n                  // If the root errored before we observe this error then it wasn't caused by something dynamic.\n                  // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n                  // then we are a dynamic route.\n                  requestStore.usedDynamic = true\n                }\n\n                const componentStack = errorInfo.componentStack\n                if (typeof componentStack === 'string') {\n                  trackAllowedDynamicAccess(\n                    route,\n                    componentStack,\n                    dynamicValidation,\n                    serverDynamicTracking,\n                    clientDynamicTracking\n                  )\n                }\n                return\n              }\n\n              return getDigestForWellKnownError(err)\n            },\n          }\n        ),\n      () => {\n        finalClientController.abort()\n        serverPhasedStream.assertExhausted()\n      }\n    )\n  } catch (err) {\n    rootDidError = true\n    if (\n      isPrerenderInterruptedError(err) ||\n      finalClientController.signal.aborted\n    ) {\n      // we don't have a root because the abort errored in the root. We can just ignore this error\n    } else {\n      // If an error is thrown in the root before prerendering is aborted, we\n      // don't want to rethrow it here, otherwise this would lead to a hanging\n      // response and unhandled rejection. We also don't want to log it, because\n      // it's most likely already logged as part of the normal render. So we\n      // just fall through here, to make sure `resolveValidation` is called.\n    }\n  }\n\n  function LogDynamicValidation() {\n    try {\n      throwIfDisallowedDynamic(\n        route,\n        dynamicValidation,\n        serverDynamicTracking,\n        clientDynamicTracking\n      )\n    } catch {}\n    return null\n  }\n\n  resolveValidation(<LogDynamicValidation />)\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  implicitTags: Array<string>\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n  const rootParams = getRootParams(tree, ctx.getDynamicParamFromSegment)\n\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = workStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult:\n    | null\n    | ReactServerPrerenderResult\n    | ServerPrerenderStreamResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        // The cacheSignal helps us track whether caches are still filling or we are ready\n        // to cut the render off.\n        const cacheSignal = new CacheSignal()\n\n        // The resume data cache here should use a fresh instance as it's\n        // performing a fresh prerender. If we get to implementing the\n        // prerendering of an already prerendered page, we should use the passed\n        // resume data cache instead.\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const initialServerPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const pendingInitialServerResult = workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          ComponentMod.prerender,\n          initialServerPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (initialServerPrerenderController.signal.aborted) {\n                // The render aborted before this error was handled which indicates\n                // the error is caused by unfinished components within the render\n                return\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            },\n            // we don't care to track postpones during the prospective render because we need\n            // to always do a final render anyway\n            onPostpone: undefined,\n            // We don't want to stop rendering until the cacheSignal is complete so we pass\n            // a different signal to this render call than is used by dynamic APIs to signify\n            // transitioning out of the prerender environment\n            signal: initialServerRenderController.signal,\n          }\n        )\n\n        await cacheSignal.cacheReady()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        let initialServerResult\n        try {\n          initialServerResult = await createReactServerPrerenderResult(\n            pendingInitialServerResult\n          )\n        } catch (err) {\n          if (\n            initialServerRenderController.signal.aborted ||\n            initialServerPrerenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerResult) {\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(\n            initialServerResult.asStream(),\n            clientReferenceManifest\n          )\n\n          const initialClientController = new AbortController()\n          const initialClientPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            rootParams,\n            implicitTags: implicitTags,\n            renderSignal: initialClientController.signal,\n            controller: initialClientController,\n            cacheSignal: null,\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...implicitTags],\n            prerenderResumeDataCache,\n          }\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                initialClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={initialServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: initialClientController.signal,\n                  onError: (err) => {\n                    const digest = getDigestForWellKnownError(err)\n\n                    if (digest) {\n                      return digest\n                    }\n\n                    if (initialClientController.signal.aborted) {\n                      // These are expected errors that might error the prerender. we ignore them.\n                    } else if (\n                      process.env.NEXT_DEBUG_BUILD ||\n                      process.env.__NEXT_VERBOSE_LOGGING\n                    ) {\n                      // We don't normally log these errors because we are going to retry anyway but\n                      // it can be useful for debugging Next.js itself to get visibility here when needed\n                      printDebugThrownValueForProspectiveRender(\n                        err,\n                        workStore.route\n                      )\n                    }\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              initialClientController.abort()\n            }\n          ).catch((err) => {\n            if (\n              initialServerRenderController.signal.aborted ||\n              isPrerenderInterruptedError(err)\n            ) {\n              // These are expected errors that might error the prerender. we ignore them.\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              // We don't normally log these errors because we are going to retry anyway but\n              // it can be useful for debugging Next.js itself to get visibility here when needed\n              printDebugThrownValueForProspectiveRender(err, workStore.route)\n            }\n          })\n        }\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        let prerenderIsPending = true\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              async () => {\n                const prerenderResult = await workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: (err: unknown) => {\n                      return serverComponentsErrorHandler(err)\n                    },\n                    signal: finalServerController.signal,\n                  }\n                )\n                prerenderIsPending = false\n                return prerenderResult\n              },\n              () => {\n                if (finalServerController.signal.aborted) {\n                  // If the server controller is already aborted we must have called something\n                  // that required aborting the prerender synchronously such as with new Date()\n                  serverIsDynamic = true\n                  return\n                }\n\n                if (prerenderIsPending) {\n                  // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                  // there is something unfinished.\n                  serverIsDynamic = true\n                }\n                finalServerController.abort()\n              }\n            )\n          ))\n\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const finalClientController = new AbortController()\n        const finalClientPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        }\n\n        let clientIsDynamic = false\n        let dynamicValidation = createDynamicValidationState()\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n          () =>\n            workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={ctx.nonce}\n              />,\n              {\n                signal: finalClientController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientController.signal.aborted\n                  ) {\n                    clientIsDynamic = true\n\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore.route,\n                        componentStack,\n                        dynamicValidation,\n                        serverDynamicTracking,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            ),\n          () => {\n            finalClientController.abort()\n          }\n        )\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalRenderPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = await getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams,\n              prerenderResumeDataCache\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = await getDynamicDataPostponedState(\n              prerenderResumeDataCache\n            )\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        } else {\n          // Static case\n          if (workStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={ctx.nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce: ctx.nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                ctx.nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = workStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        const cacheSignal = new CacheSignal()\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const initialClientController = new AbortController()\n        const initialClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialClientController.signal,\n          controller: initialClientController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        let initialServerStream\n        try {\n          initialServerStream = workUnitAsyncStorage.run(\n            initialServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (\n                  initialServerPrerenderController.signal.aborted ||\n                  initialServerRenderController.signal.aborted\n                ) {\n                  // The render aborted before this error was handled which indicates\n                  // the error is caused by unfinished components within the render\n                  return\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              signal: initialServerRenderController.signal,\n            }\n          )\n        } catch (err: unknown) {\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerStream) {\n          const [warmupStream, renderStream] = initialServerStream.tee()\n          initialServerStream = null\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const pendingInitialClientResult = workUnitAsyncStorage.run(\n            initialClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={ctx.nonce}\n            />,\n            {\n              signal: initialClientController.signal,\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (initialClientController.signal.aborted) {\n                  // These are expected errors that might error the prerender. we ignore them.\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  // We don't normally log these errors because we are going to retry anyway but\n                  // it can be useful for debugging Next.js itself to get visibility here when needed\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              bootstrapScripts: [bootstrapScript],\n            }\n          )\n          pendingInitialClientResult.catch((err: unknown) => {\n            if (initialClientController.signal.aborted) {\n              // We aborted the render normally and can ignore this error\n            } else {\n              // We're going to retry to so we normally would suppress this error but\n              // when verbose logging is on we print it\n              if (process.env.__NEXT_VERBOSE_LOGGING) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            }\n          })\n        }\n\n        await cacheSignal.cacheReady()\n        // It is important that we abort the SSR render first to avoid\n        // connection closed errors from having an incomplete RSC stream\n        initialClientController.abort()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        // We've now filled caches and triggered any inadvertant sync bailouts\n        // due to lazy module initialization. We can restart our render to capture results\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        let clientIsDynamic = false\n        const finalClientController = new AbortController()\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const dynamicValidation = createDynamicValidationState()\n\n        const finalClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const finalServerPayload = await workUnitAsyncStorage.run(\n          finalServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const serverPrerenderStreamResult = (reactServerPrerenderResult =\n          await prerenderServerWithPhases(\n            finalServerController.signal,\n            () =>\n              workUnitAsyncStorage.run(\n                finalServerPrerenderStore,\n                ComponentMod.renderToReadableStream,\n                finalServerPayload,\n                clientReferenceManifest.clientModules,\n                {\n                  onError: (err: unknown) => {\n                    if (finalServerController.signal.aborted) {\n                      serverIsDynamic = true\n                      if (isPrerenderInterruptedError(err)) {\n                        return err.digest\n                      }\n                      return getDigestForWellKnownError(err)\n                    }\n\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerController.signal,\n                }\n              ),\n            () => {\n              finalServerController.abort()\n            }\n          ))\n\n        let htmlStream\n        const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n        try {\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const result = await prerenderClientWithPhases(\n            () =>\n              workUnitAsyncStorage.run(\n                finalClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={serverPhasedStream}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: finalClientController.signal,\n                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n                    if (\n                      isPrerenderInterruptedError(err) ||\n                      finalClientController.signal.aborted\n                    ) {\n                      clientIsDynamic = true\n\n                      const componentStack: string | undefined = (\n                        errorInfo as any\n                      ).componentStack\n                      if (typeof componentStack === 'string') {\n                        trackAllowedDynamicAccess(\n                          workStore.route,\n                          componentStack,\n                          dynamicValidation,\n                          serverDynamicTracking,\n                          clientDynamicTracking\n                        )\n                      }\n                      return\n                    }\n\n                    return htmlRendererErrorHandler(err, errorInfo)\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              finalClientController.abort()\n              serverPhasedStream.assertExhausted()\n            }\n          )\n          htmlStream = result.prelude\n        } catch (err) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            finalClientController.signal.aborted\n          ) {\n            // we don't have a root because the abort errored in the root. We can just ignore this error\n          } else {\n            // This error is something else and should bubble up\n            throw err\n          }\n        }\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          const dynamicReason = serverIsDynamic\n            ? getFirstDynamicReason(serverDynamicTracking)\n            : getFirstDynamicReason(clientDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          }\n        }\n\n        const flightData = await streamToBuffer(\n          serverPrerenderStreamResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalClientPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream!, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              serverPrerenderStreamResult.asStream(),\n              ctx.nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            validateRootLayout,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: finalServerPrerenderStore.stale,\n          collectedTags: finalServerPrerenderStore.tags,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n        prerenderResumeDataCache,\n      }\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await workUnitAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams,\n            prerenderResumeDataCache\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={ctx.nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce: ctx.nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: prerenderLegacyStore.stale,\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <AppWithoutContext\n            reactServerStream={errorServerStream}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={ctx.nonce}\n          />\n        ),\n        streamOptions: {\n          nonce: ctx.nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream =\n        reactServerPrerenderResult instanceof ServerPrerenderStreamResult\n          ? reactServerPrerenderResult.asStream()\n          : reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale:\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE,\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: ReadableStream<Uint8Array>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  let createFromReadableStream\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  try {\n    createFromReadableStream(flightStream, {\n      serverConsumerManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n        serverModuleMap: null,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<React.ReactNode | undefined> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n\n  return globalErrorStyles\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const clientReferenceManifest = renderOpts.clientReferenceManifest\n  if (!clientReferenceManifest || !renderOpts.experimental.clientSegmentCache) {\n    return\n  }\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: null,\n  }\n\n  // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n  // promise, the absence of which we use to determine if a segment is fully\n  // static or partially static. However, when dynamicIO is not enabled, this\n  // trick doesn't work.\n  //\n  // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n  // assume all segments are partial.\n  //\n  // TODO: When PPR is on, we can at least optimize the case where the entire\n  // page is static. Either by passing that as an argument to this function, or\n  // by setting a header on the response like the we do for full page RSC\n  // prefetches today. The latter approach might be simpler since it requires\n  // less plumbing, and the client has to check the header regardless to see if\n  // PPR is enabled.\n  const shouldAssumePartialData =\n    renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n\n  const staleTime = prerenderStore.stale\n  return await ComponentMod.collectSegmentData(\n    shouldAssumePartialData,\n    fullPageDataBuffer,\n    staleTime,\n    clientReferenceManifest.clientModules as ManifestNode,\n    serverConsumerManifest,\n    fallbackRouteParams\n  )\n}\n"],"names":["workAsyncStorage","React","RenderResult","chainStreams","renderToInitialFizzStream","createDocumentClosingStream","continueFizzStream","continueDynamicPrerender","continueStaticPrerender","continueDynamicHTMLResume","streamToBuffer","streamToString","stripInternalQueries","NEXT_HMR_REFRESH_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_URL","RSC_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","createTrackedMetadataContext","createMetadataContext","createRequestStoreForRender","createWorkStore","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","getImplicitTags","AppRenderSpan","NextNodeServerSpan","getTracer","FlightRenderResult","createFlightReactServerErrorHandler","createHTMLReactServerErrorHandler","createHTMLErrorHandler","isUserLandError","getDigestForWellKnownError","getShortDynamicParamType","dynamicParamTypes","getSegmentParam","getScriptNonceFromHeader","parseAndValidateFlightRouterState","createFlightRouterStateFromLoaderTree","handleAction","isBailoutToCSRError","warn","error","appendMutableCookies","createServerInsertedHTML","getRequiredScripts","addPathPrefix","makeGetServerInsertedHTML","walkTreeWithFlightRouterState","createComponentTree","getRootParams","getAssetQueryString","setReferenceManifestsSingleton","DynamicState","parsePostponedState","getDynamicDataPostponedState","getDynamicHTMLPostponedState","getPostponedFromState","isDynamicServerError","useFlightStream","createInlinedDataReadableStream","StaticGenBailoutError","isStaticGenBailoutError","getStackWithoutErrorMessage","accessedDynamicData","createPostponedAbortSignal","formatDynamicAPIAccesses","isPrerenderInterruptedError","createDynamicTrackingState","createDynamicValidationState","getFirstDynamicReason","trackAllowedDynamicAccess","throwIfDisallowedDynamic","consumeDynamicAccess","getClientComponentLoaderMetrics","wrapClientComponentLoader","createServerModuleMap","isNodeNextRequest","parseParameter","parseRelativeUrl","AppRouter","getServerActionRequestMetadata","createInitialRouterState","createMutableActionQueue","getRevalidateReason","PAGE_SEGMENT_KEY","DynamicServerError","ServerPrerenderStreamResult","ReactServerResult","createReactServerPrerenderResult","createReactServerPrerenderResultFromRender","prerenderAndAbortInSequentialTasks","prerenderServerWithPhases","prerenderClientWithPhases","printDebugThrownValueForProspectiveRender","scheduleInSequentialTasks","waitAtLeastOneReactRenderTask","workUnitAsyncStorage","CacheSignal","getTracedMetadata","InvariantError","INFINITE_CACHE","createComponentStylesAndScripts","parseLoaderTree","createPrerenderResumeDataCache","createRenderResumeDataCache","isError","isUseCacheTimeoutError","createServerInsertedMetadata","flightDataPathHeadKey","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","toLowerCase","undefined","isHmrRefresh","isRSCRequest","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","isRouteTreePrefetchRequest","csp","nonce","createNotFoundLoaderTree","loaderTree","components","children","page","createDivergedMetadataComponents","Metadata","serveStreamingMetadata","EmptyMetadata","StreamingMetadata","StaticMetadata","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","treeSegment","split","slice","flatMap","pathSegment","join","NonIndex","ctx","is404Page","isInvalidStatusCode","res","statusCode","isAction","meta","name","content","generateDynamicRSCPayload","flightData","componentMod","tree","createServerSearchParamsForMetadata","createServerParamsForMetadata","createMetadataComponents","MetadataBoundary","ViewportBoundary","appUsingSizeAdjustment","query","requestId","workStore","url","renderOpts","skipFlight","preloadCallbacks","searchParams","ViewportTree","MetadataTree","getViewportReady","getMetadataReady","StreamingMetadataOutlet","metadataContext","pathname","loaderTreeToFilter","parentParams","rscHead","Fragment","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","sharedContext","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","generateDynamicFlightRenderResult","req","requestStore","onFlightDataRenderError","err","onInstrumentationRequestError","onError","dev","RSCPayload","run","process","env","NODE_ENV","experimental","dynamicIO","resolveValidation","validationOutlet","createValidationOutlet","_validation","spawnDynamicValidationInDev","clientReferenceManifest","route","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","fetchMetrics","warmupDevRender","rootParams","prerenderResumeDataCache","renderController","AbortController","prerenderController","cacheSignal","prerenderStore","phase","implicitTags","renderSignal","signal","controller","dynamicTracking","revalidate","expire","stale","tags","rscPayload","cacheReady","abort","devRenderResumeDataCache","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","GlobalError","initialTree","errorType","seedData","authInterrupts","varyHeader","getHeader","couldBeIntercepted","includes","initialHead","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","ssrError","Error","html","id","head","body","template","data-next-error-message","message","data-next-error-digest","digest","data-next-error-stack","stack","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","ServerInsertedMetadataProvider","response","use","initialState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","Map","location","prerendered","actionQueue","HeadManagerContext","require","Provider","appDir","globalErrorComponentAndStyles","AppWithoutContext","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setIsrStatus","NEXT_RUNTIME","originalRequest","on","ended","metrics","reset","startSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","patchFetch","taintObjectReference","crypto","randomUUID","nanoid","isActionRequest","isServerAction","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","getBodyResult","spanName","prerenderToStream","dynamicAccess","isDebugDynamicAccesses","access","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","length","find","pendingRevalidates","pendingRevalidateWrites","revalidatedTags","pendingPromise","Promise","all","incrementalCache","revalidateTag","Object","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","waitUntil","collectedTags","fetchTags","staleHeader","String","collectedStale","setHeader","forceStatic","collectedRevalidate","cacheControl","collectedExpire","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","stream","renderResumeDataCache","onUpdateCookies","previewProps","usedDynamic","forceDynamic","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","generateFlight","notFoundLoaderTree","result","assignMetadata","renderToHTMLOrFlight","routeModule","definition","renderServerInsertedHTML","getServerInsertedMetadata","tracingMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","reactServerResult","bind","appendHeader","prerenderPhase","environmentName","filterStackFrame","_functionName","startsWith","DATA","inlinedReactServerDataStream","tee","resume","htmlStream","getServerInsertedHTML","serverCapturedErrors","basePath","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","generateStaticHTML","supportsDynamicResponse","shouldWaitOnAllReady","validateRootLayout","shouldBailoutToCSR","reason","redirectUrl","Headers","mutableCookies","from","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","outlet","resolve","isNotFound","initialServerPrerenderController","initialServerRenderController","initialServerPrerenderStore","initialClientController","initialClientPrerenderStore","firstAttemptRSCPayload","initialServerStream","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","warmupStream","renderStream","warmFlightResponse","prerender","pendingInitialClientResult","catch","finalServerController","serverDynamicTracking","finalServerPrerenderStore","finalClientController","clientDynamicTracking","dynamicValidation","finalClientPrerenderStore","finalServerPayload","serverPrerenderStreamResult","rootDidError","serverPhasedStream","asPhasedStream","errorInfo","dynamicErrors","push","componentStack","assertExhausted","LogDynamicValidation","shouldGenerateStaticFlightData","reactServerPrerenderResult","setMetadataHeader","item","initialServerPayload","pendingInitialServerResult","onPostpone","initialServerResult","asStream","asUnclosingStream","serverIsDynamic","finalRenderPrerenderStore","finalAttemptRSCPayload","prerenderIsPending","prerenderResult","clientIsDynamic","prelude","segmentData","collectSegmentData","foreverStream","ReadableStream","resumeStream","JSON","parse","stringify","consumeAsStream","cache","dynamicReason","reactServerPrerenderStore","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","flightStream","loadingChunks","chunkListeners","load","add","delete","createFromReadableStream","TURBOPACK","serverConsumerManifest","moduleLoading","moduleMap","ssrModuleMapping","r","modules","globalErrorModule","styles","filePath","getComponent","fullPageDataBuffer","clientSegmentCache","isEdgeRuntime","edgeRscModuleMapping","rscModuleMapping","shouldAssumePartialData","staleTime"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7173, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aAAgBL,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 7231, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,sOACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 7243, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { DynamicServerError } from '../../client/components/hooks-server-context'\nimport type { FetchMetrics } from '../base-http'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isPrerendering?: boolean\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n  dynamicUsageErr?: DynamicServerError\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  revalidatedTags?: string[]\n  fetchMetrics?: FetchMetrics\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  requestEndedState?: { ended?: boolean }\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  dynamicIOEnabled: boolean\n  dev: boolean\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorageInstance","workAsyncStorage"],"mappings":"AAUA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 7273, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","workUnitAsyncStorageInstance"],"mappings":";;;AAAA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAGxD,MAAMC,0OACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 7285, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\n\ntype WorkUnitPhase = 'action' | 'render' | 'after'\n\ntype PhasePartial = {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n}\n\nexport type RequestStore = {\n  type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly implicitTags: string[]\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n} & PhasePartial\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern = {\n  type: 'prerender'\n  readonly implicitTags: string[]\n\n  /**\n   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n   */\n  readonly renderSignal: AbortSignal\n  /**\n   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n   * a sync API which requires the prerender to end immediately\n   */\n  readonly controller: AbortController\n\n  /**\n   * when not null this signal is used to track cache reads during prerendering and\n   * to await all cache reads completing before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  // DEV ONLY\n  // When used this flag informs certain APIs to skip logging because we're\n  // not part of the primary render path and are just prerendering to produce\n  // validation results\n  validating?: boolean\n} & PhasePartial\n\nexport type PrerenderStorePPR = {\n  type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  readonly dynamicTracking: null | DynamicTrackingState\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n} & PhasePartial\n\nexport type PrerenderStoreLegacy = {\n  type: 'prerender-legacy'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n} & PhasePartial\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\nexport type UseCacheStore = {\n  type: 'cache'\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this cache entry during the cache render.\n  revalidate: number // implicit revalidate time from inner caches / fetches\n  expire: number // server expiration time\n  stale: number // client expiration time\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  tags: null | string[]\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n} & PhasePartial\n\nexport type UnstableCacheStore = {\n  type: 'unstable-cache'\n} & PhasePartial\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n * Inside this context we should never expose any request or page specific information.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function getExpectedRequestStore(\n  callingExpression: string\n): RequestStore {\n  const workUnitStore = workUnitAsyncStorageInstance.getStore()\n  if (workUnitStore) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      // This should not happen because we should have checked it already.\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`\n      )\n    }\n    if (workUnitStore.type === 'cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n    } else if (workUnitStore.type === 'unstable-cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n    }\n  }\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  if (\n    workUnitStore.type === 'prerender' ||\n    workUnitStore.type === 'prerender-ppr'\n  ) {\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  if (\n    workUnitStore.type !== 'prerender-legacy' &&\n    workUnitStore.type !== 'cache' &&\n    workUnitStore.type !== 'unstable-cache'\n  ) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore.renderResumeDataCache\n    }\n\n    // We return the mutable resume data cache here as an immutable version of\n    // the cache as it can also be used for reading.\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getHmrRefreshHash(\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  return workUnitStore.type === 'cache'\n    ? workUnitStore.hmrRefreshHash\n    : workUnitStore.type === 'request'\n      ? workUnitStore.cookies.get('__next_hmr_refresh_hash__')?.value\n      : undefined\n}\n"],"names":["workUnitAsyncStorageInstance","workUnitAsyncStorage","getExpectedRequestStore","callingExpression","workUnitStore","getStore","type","Error","getPrerenderResumeDataCache","prerenderResumeDataCache","getRenderResumeDataCache","renderResumeDataCache","getHmrRefreshHash","hmrRefreshHash","cookies","get","value","undefined"],"mappings":"AAQA,qDAAqD;;;;;;;AACrD,SAASA,4BAA4B,QAAQ,0CAA0C;;;AAqLhF,SAASE,wBACdC,iBAAyB;IAEzB,MAAMC,0OAAgBJ,+BAAAA,CAA6BK,QAAQ;IAC3D,IAAID,eAAe;QACjB,IAAIA,cAAcE,IAAI,KAAK,WAAW;YACpC,OAAOF;QACT;QACA,IACEA,cAAcE,IAAI,KAAK,eACvBF,cAAcE,IAAI,KAAK,mBACvBF,cAAcE,IAAI,KAAK,oBACvB;YACA,oEAAoE;YACpE,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,iEAAiE,CAAC,GADrF,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,IAAIC,cAAcE,IAAI,KAAK,SAAS;YAClC,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,2JAA2J,CAAC,GAD/K,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,OAAO,IAAIC,cAAcE,IAAI,KAAK,kBAAkB;YAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,EAAE,EAAEJ,kBAAkB,sKAAsK,CAAC,GAD1L,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IACA,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,CAAC,EAAE,EAAEJ,kBAAkB,iHAAiH,CAAC,GADrI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASK,4BACdJ,aAA4B;IAE5B,IACEA,cAAcE,IAAI,KAAK,eACvBF,cAAcE,IAAI,KAAK,iBACvB;QACA,OAAOF,cAAcK,wBAAwB;IAC/C;IAEA,OAAO;AACT;AAEO,SAASC,yBACdN,aAA4B;IAE5B,IACEA,cAAcE,IAAI,KAAK,sBACvBF,cAAcE,IAAI,KAAK,WACvBF,cAAcE,IAAI,KAAK,kBACvB;QACA,IAAIF,cAAcE,IAAI,KAAK,WAAW;YACpC,OAAOF,cAAcO,qBAAqB;QAC5C;QAEA,0EAA0E;QAC1E,gDAAgD;QAChD,OAAOP,cAAcK,wBAAwB;IAC/C;IAEA,OAAO;AACT;AAEO,SAASG,kBACdR,aAA4B;QAKtBA;IAHN,OAAOA,cAAcE,IAAI,KAAK,UAC1BF,cAAcS,cAAc,GAC5BT,cAAcE,IAAI,KAAK,YAAA,CACrBF,6BAAAA,cAAcU,OAAO,CAACC,GAAG,CAAC,4BAAA,KAAA,OAAA,KAAA,IAA1BX,2BAAwDY,KAAK,GAC7DC;AACR","ignoreList":[0]}},
    {"offset": {"line": 7375, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicExpression: undefined | string\n  syncDynamicErrorWithStack: null | Error\n  // Dev only\n  syncDynamicLogged?: boolean\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspendedDynamic: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasSyncDynamicErrors: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicExpression: undefined,\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspendedDynamic: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasSyncDynamicErrors: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n  return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      if (prerenderStore.validating === true) {\n        // We always log Request Access in dev at the point of calling the function\n        // So we mark the dynamic validation as not requiring it to be printed\n        dynamicTracking.syncDynamicLogged = true\n      }\n    }\n  }\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  if (\n    workStore &&\n    workStore.isStaticGeneration &&\n    workStore.fallbackRouteParams &&\n    workStore.fallbackRouteParams.size > 0\n  ) {\n    // There are fallback route params, we should track these as dynamic\n    // accesses.\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      // We're prerendering with dynamicIO or PPR or both\n      if (workUnitStore.type === 'prerender') {\n        // We are in a prerender with dynamicIO semantics\n        // We are going to hang here and never resolve. This will cause the currently\n        // rendering component to effectively be a dynamic hole\n        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // We're prerendering with PPR\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    dynamicValidation.hasSuspendedDynamic = true\n    return\n  } else if (\n    serverDynamic.syncDynamicErrorWithStack ||\n    clientDynamic.syncDynamicErrorWithStack\n  ) {\n    dynamicValidation.hasSyncDynamicErrors = true\n    return\n  } else {\n    const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport function throwIfDisallowedDynamic(\n  route: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): void {\n  let syncError: null | Error\n  let syncExpression: undefined | string\n  let syncLogged: boolean\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    syncError = serverDynamic.syncDynamicErrorWithStack\n    syncExpression = serverDynamic.syncDynamicExpression!\n    syncLogged = serverDynamic.syncDynamicLogged === true\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    syncError = clientDynamic.syncDynamicErrorWithStack\n    syncExpression = clientDynamic.syncDynamicExpression!\n    syncLogged = clientDynamic.syncDynamicLogged === true\n  } else {\n    syncError = null\n    syncExpression = undefined\n    syncLogged = false\n  }\n\n  if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n    if (!syncLogged) {\n      // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n      // the offending sync error is logged before we exit the build\n      console.error(syncError)\n    }\n    // The actual error should have been logged when the sync access ocurred\n    throw new StaticGenBailoutError()\n  }\n\n  const dynamicErrors = dynamicValidation.dynamicErrors\n  if (dynamicErrors.length) {\n    for (let i = 0; i < dynamicErrors.length; i++) {\n      console.error(dynamicErrors[i])\n    }\n\n    throw new StaticGenBailoutError()\n  }\n\n  if (!dynamicValidation.hasSuspendedDynamic) {\n    if (dynamicValidation.hasDynamicMetadata) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    } else if (dynamicValidation.hasDynamicViewport) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    }\n  }\n}\n"],"names":["React","DynamicServerError","StaticGenBailoutError","workUnitAsyncStorage","workAsyncStorage","makeHangingPromise","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","scheduleOnNextTick","hasPostpone","unstable_postpone","createDynamicTrackingState","isDebugDynamicAccesses","dynamicAccesses","syncDynamicExpression","undefined","syncDynamicErrorWithStack","createDynamicValidationState","hasSuspendedDynamic","hasDynamicMetadata","hasDynamicViewport","hasSyncDynamicErrors","dynamicErrors","getFirstDynamicReason","trackingState","expression","markCurrentScopeAsDynamic","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","route","postponeWithTracking","dynamicTracking","revalidate","err","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","trackFallbackParamAccessed","prerenderStore","getStore","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","_store","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","abortOnSynchronousPlatformIOAccess","errorWithStack","trackSynchronousPlatformIOAccessInDev","requestStore","prerenderPhase","abortAndThrowOnSynchronousRequestDataAccess","validating","syncDynamicLogged","trackSynchronousRequestDataAccessInDev","Postpone","assertPostpone","createPostponeReason","isDynamicPostpone","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","isPrerenderInterruptedError","accessedDynamicData","length","consumeDynamicAccess","serverDynamic","clientDynamic","formatDynamicAPIAccesses","filter","access","map","split","slice","line","join","createPostponedAbortSignal","AbortController","x","signal","createHangingInputAbortSignal","cacheSignal","inputReady","then","annotateDynamicAccess","useDynamicRouteParams","workStore","isStaticGeneration","fallbackRouteParams","size","use","renderSignal","hasSuspenseRegex","hasMetadataRegex","RegExp","hasViewportRegex","hasOutletRegex","trackAllowedDynamicAccess","componentStack","dynamicValidation","test","createErrorWithComponentStack","throwIfDisallowedDynamic","syncError","syncExpression","syncLogged","console","i"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7842, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","createAsyncLocalStorage","bindSnapshot","createSnapshot","snapshot","args"],"mappings":";;;;;AAEA,MAAMA,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASC;IAGd,IAAIH,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASa,aAAgBL,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASM;IAId,IAAIL,8BAA8B;QAChC,OAAOA,6BAA6BM,QAAQ;IAC9C;IACA,OAAO,SAAUP,EAAO,EAAE,GAAGQ,IAAW;QACtC,OAAOR,MAAMQ;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 7900, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","afterTaskAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,2OACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 7912, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorageInstance","afterTaskAsyncStorage"],"mappings":"AAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 7942, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-async-storage-instance.ts"],"sourcesContent":["import type { ActionAsyncStorage } from './action-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const actionAsyncStorageInstance: ActionAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["createAsyncLocalStorage","actionAsyncStorageInstance"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,wBAAuB;;AAExD,MAAMC,wOACXD,0BAAAA,GAAyB","ignoreList":[0]}},
    {"offset": {"line": 7954, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n"],"names":["actionAsyncStorageInstance","actionAsyncStorage"],"mappings":"AAEA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 7996, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/flight-render-result.ts"],"sourcesContent":["import { RSC_CONTENT_TYPE_HEADER } from '../../client/components/app-router-headers'\nimport RenderResult, { type RenderResultMetadata } from '../render-result'\n\n/**\n * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.\n */\nexport class FlightRenderResult extends RenderResult {\n  constructor(\n    response: string | ReadableStream<Uint8Array>,\n    metadata: RenderResultMetadata = {}\n  ) {\n    super(response, { contentType: RSC_CONTENT_TYPE_HEADER, metadata })\n  }\n}\n"],"names":["RSC_CONTENT_TYPE_HEADER","RenderResult","FlightRenderResult","constructor","response","metadata","contentType"],"mappings":";;;AAAA,SAASA,uBAAuB,QAAQ,6CAA4C;AACpF,OAAOC,kBAAiD,mBAAkB;;;AAKnE,MAAMC,qMAA2BD,UAAAA;IACtCE,YACEC,QAA6C,EAC7CC,WAAiC,CAAC,CAAC,CACnC;QACA,KAAK,CAACD,UAAU;YAAEE,6MAAaN,0BAAAA;YAAyBK;QAAS;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 8017, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import type { ErrorInfo } from 'react'\n\nimport stringHash from 'next/dist/compiled/string-hash'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createFlightReactServerErrorHandler(\n  shouldFormatError: boolean,\n  onReactServerRenderError: (err: DigestedError) => void\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + err.stack || '').toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Record exception in an active span, if available.\n    const span = getTracer().getActiveScopeSpan()\n    if (span) {\n      span.recordException(err)\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      })\n    }\n\n    onReactServerRenderError(err)\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  silenceLogger: boolean,\n  onReactServerRenderError: undefined | ((err: DigestedError) => void)\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + (err.stack || '')).toString()\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (!silenceLogger) {\n        onReactServerRenderError?.(err)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  silenceLogger: boolean,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = stringHash(\n        err.message + (errorInfo?.componentStack || err.stack || '')\n      ).toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (\n        !silenceLogger &&\n        // HTML errors contain RSC errors as well, filter them out before reporting\n        isSSRError\n      ) {\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["stringHash","formatServerError","SpanStatusCode","getTracer","isAbortError","isBailoutToCSRError","isDynamicServerError","isNextRouterError","getProperError","createDigestWithErrorCode","getDigestForWellKnownError","error","digest","undefined","createFlightReactServerErrorHandler","shouldFormatError","onReactServerRenderError","thrownValue","toString","err","message","stack","span","getActiveScopeSpan","recordException","setStatus","code","ERROR","createHTMLReactServerErrorHandler","isNextExport","reactServerErrors","silenceLogger","has","set","includes","createHTMLErrorHandler","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","get","componentStack","isUserLandError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8196, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type { DynamicParamTypes, DynamicParamTypesShort } from './types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted': 'ci',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted': 'di',\n}\n\n/**\n * Shorten the dynamic param in order to make it smaller when transmitted to the browser.\n */\nexport function getShortDynamicParamType(\n  type: DynamicParamTypes\n): DynamicParamTypesShort {\n  const short = dynamicParamTypes[type]\n  if (!short) {\n    throw new Error('Unknown dynamic param type')\n  }\n  return short\n}\n"],"names":["dynamicParamTypes","catchall","dynamic","getShortDynamicParamType","type","short","Error"],"mappings":";;;;AAEO,MAAMA,oBAGT;IACFC,UAAU;IACV,wBAAwB;IACxB,qBAAqB;IACrBC,SAAS;IACT,uBAAuB;AACzB,EAAC;AAKM,SAASC,yBACdC,IAAuB;IAEvB,MAAMC,QAAQL,iBAAiB,CAACI,KAAK;IACrC,IAAI,CAACC,OAAO;QACV,MAAM,OAAA,cAAuC,CAAvC,IAAIC,MAAM,+BAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAsC;IAC9C;IACA,OAAOD;AACT","ignoreList":[0]}},
    {"offset": {"line": 8224, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-segment-param.tsx"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\nimport type { DynamicParamTypes } from './types'\n\n/**\n * Parse dynamic route segment to type of parameter\n */\nexport function getSegmentParam(segment: string): {\n  param: string\n  type: DynamicParamTypes\n} | null {\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n    segment.startsWith(marker)\n  )\n\n  // if an interception marker is part of the path segment, we need to jump ahead\n  // to the relevant portion for param parsing\n  if (interceptionMarker) {\n    segment = segment.slice(interceptionMarker.length)\n  }\n\n  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n    return {\n      // TODO-APP: Optional catchall does not currently work with parallel routes,\n      // so for now aren't handling a potential interception marker.\n      type: 'optional-catchall',\n      param: segment.slice(5, -2),\n    }\n  }\n\n  if (segment.startsWith('[...') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'catchall-intercepted' : 'catchall',\n      param: segment.slice(4, -1),\n    }\n  }\n\n  if (segment.startsWith('[') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'dynamic-intercepted' : 'dynamic',\n      param: segment.slice(1, -1),\n    }\n  }\n\n  return null\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","getSegmentParam","segment","interceptionMarker","find","marker","startsWith","slice","length","endsWith","type","param"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,oDAAmD;;AAMvF,SAASC,gBAAgBC,OAAe;IAI7C,MAAMC,+NAAqBH,6BAAAA,CAA2BI,IAAI,CAAC,CAACC,SAC1DH,QAAQI,UAAU,CAACD;IAGrB,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAIF,oBAAoB;QACtBD,UAAUA,QAAQK,KAAK,CAACJ,mBAAmBK,MAAM;IACnD;IAEA,IAAIN,QAAQI,UAAU,CAAC,YAAYJ,QAAQO,QAAQ,CAAC,OAAO;QACzD,OAAO;YACL,4EAA4E;YAC5E,8DAA8D;YAC9DC,MAAM;YACNC,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,WAAWJ,QAAQO,QAAQ,CAAC,MAAM;QACvD,OAAO;YACLC,MAAMP,qBAAqB,yBAAyB;YACpDQ,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,QAAQJ,QAAQO,QAAQ,CAAC,MAAM;QACpD,OAAO;YACLC,MAAMP,qBAAqB,wBAAwB;YACnDQ,OAAOT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 8264, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-script-nonce-from-header.tsx"],"sourcesContent":["import { ESCAPE_REGEX } from '../htmlescape'\n\nexport function getScriptNonceFromHeader(\n  cspHeaderValue: string\n): string | undefined {\n  const directives = cspHeaderValue\n    // Directives are split by ';'.\n    .split(';')\n    .map((directive) => directive.trim())\n\n  // First try to find the directive for the 'script-src', otherwise try to\n  // fallback to the 'default-src'.\n  const directive =\n    directives.find((dir) => dir.startsWith('script-src')) ||\n    directives.find((dir) => dir.startsWith('default-src'))\n\n  // If no directive could be found, then we're done.\n  if (!directive) {\n    return\n  }\n\n  // Extract the nonce from the directive\n  const nonce = directive\n    .split(' ')\n    // Remove the 'strict-src'/'default-src' string, this can't be the nonce.\n    .slice(1)\n    .map((source) => source.trim())\n    // Find the first source with the 'nonce-' prefix.\n    .find(\n      (source) =>\n        source.startsWith(\"'nonce-\") &&\n        source.length > 8 &&\n        source.endsWith(\"'\")\n    )\n    // Grab the nonce by trimming the 'nonce-' prefix.\n    ?.slice(7, -1)\n\n  // If we could't find the nonce, then we're done.\n  if (!nonce) {\n    return\n  }\n\n  // Don't accept the nonce value if it contains HTML escape characters.\n  // Technically, the spec requires a base64'd value, but this is just an\n  // extra layer.\n  if (ESCAPE_REGEX.test(nonce)) {\n    throw new Error(\n      'Nonce value from Content-Security-Policy contained HTML escape characters.\\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters'\n    )\n  }\n\n  return nonce\n}\n"],"names":["ESCAPE_REGEX","getScriptNonceFromHeader","cspHeaderValue","directive","directives","split","map","trim","find","dir","startsWith","nonce","slice","source","length","endsWith","test","Error"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,gBAAe;;AAErC,SAASC,yBACdC,cAAsB;QAmBRC;IAjBd,MAAMC,aAAaF,eACjB,+BAA+B;KAC9BG,KAAK,CAAC,KACNC,GAAG,CAAC,CAACH,YAAcA,UAAUI,IAAI;IAEpC,yEAAyE;IACzE,iCAAiC;IACjC,MAAMJ,YACJC,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC,kBACxCN,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC;IAE1C,mDAAmD;IACnD,IAAI,CAACP,WAAW;QACd;IACF;IAEA,uCAAuC;IACvC,MAAMQ,QAAAA,CAAQR,kCAAAA,UACXE,KAAK,CAAC,KACP,yEAAyE;KACxEO,KAAK,CAAC,GACNN,GAAG,CAAC,CAACO,SAAWA,OAAON,IAAI,IAC5B,kDAAkD;KACjDC,IAAI,CACH,CAACK,SACCA,OAAOH,UAAU,CAAC,cAClBG,OAAOC,MAAM,GAAG,KAChBD,OAAOE,QAAQ,CAAC,KAAA,KAAA,OAAA,KAAA,IAVRZ,gCAaVS,KAAK,CAAC,GAAG,CAAC;IAEd,iDAAiD;IACjD,IAAI,CAACD,OAAO;QACV;IACF;IAEA,sEAAsE;IACtE,uEAAuE;IACvE,eAAe;IACf,wKAAIX,eAAAA,CAAagB,IAAI,CAACL,QAAQ;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,gKADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAON;AACT","ignoreList":[0]}},
    {"offset": {"line": 8306, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { InstrumentationOnRequestError } from '../instrumentation/types'\nimport type { NextRequestHint } from '../web/adapter'\nimport type { BaseNextRequest } from '../base-http'\nimport type { IncomingMessage } from 'http'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nconst dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])\n\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n\nconst segmentSchema = s.union([\n  s.string(),\n  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n])\n\nexport type Segment = s.Infer<typeof segmentSchema>\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(\n    s.nullable(\n      s.union([\n        s.literal('refetch'),\n        s.literal('refresh'),\n        s.literal('inside-shared-layout'),\n      ])\n    )\n  ),\n  s.optional(s.boolean()),\n])\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation  inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case  during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?: 'refetch' | 'refresh' | 'inside-shared-layout' | null,\n  isRootLayout?: boolean,\n]\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  segment: Segment,\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type ServerOnInstrumentationRequestError = (\n  error: unknown,\n  // The request could be middleware, node server or web server request,\n  // we normalized them into an aligned format to `onRequestError` API later.\n  request: NextRequestHint | BaseNextRequest | IncomingMessage,\n  errorContext: Parameters<InstrumentationOnRequestError>[2]\n) => void | Promise<void>\n\nexport interface RenderOptsPartial {\n  previewProps: __ApiPreviewProps | undefined\n  err?: Error | null\n  dev?: boolean\n  basePath: string\n  trailingSlash: boolean\n  clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  supportsDynamicResponse: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  botType?: 'dom' | 'html' | undefined\n  serveStreamingMetadata?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  cacheLifeProfiles?: {\n    [profile: string]: import('../use-cache/cache-life').CacheLife\n  }\n  setIsrStatus?: (key: string, value: boolean | null) => void\n  isRevalidate?: boolean\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  onInstrumentationRequestError?: ServerOnInstrumentationRequestError\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  htmlLimitedBots: string | undefined\n  experimental: {\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    expireTime: number | undefined\n    clientTraceMetadata: string[] | undefined\n    dynamicIO: boolean\n    clientSegmentCache: boolean\n    inlineCss: boolean\n    authInterrupts: boolean\n  }\n  postponed?: string\n\n  /**\n   * Should wait for react stream allReady to resolve all suspense boundaries,\n   * in order to perform a full page render.\n   */\n  shouldWaitOnAllReady?: boolean\n\n  /**\n   * The resume data cache that was generated for this partially prerendered\n   * page during dev warmup.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n\n  /**\n   * When true, the page will be rendered using the static rendering to detect\n   * any dynamic API's that would have stopped the page from being fully\n   * statically generated.\n   */\n  isDebugDynamicAccesses?: boolean\n\n  /**\n   * The maximum length of the headers that are emitted by React and added to\n   * the response.\n   */\n  reactMaxHeadersLength: number | undefined\n\n  isStaticGeneration?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n\nexport type PreloadCallbacks = (() => void)[]\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** assetPrefix */\n  p: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** postponed */\n  s: boolean\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n"],"names":["s","dynamicParamTypesSchema","enums","segmentSchema","union","string","tuple","flightRouterStateSchema","record","lazy","optional","nullable","literal","boolean"],"mappings":";;;AAcA,OAAOA,OAAO,iCAAgC;;AAe9C,MAAMC,oMAA0BD,UAAAA,CAAEE,KAAK,CAAC;IAAC;IAAK;IAAM;IAAM;IAAK;CAAK;AAIpE,MAAMC,0LAAgBH,UAAAA,CAAEI,KAAK,CAAC;8KAC5BJ,UAAAA,CAAEK,MAAM;8KACRL,UAAAA,CAAEM,KAAK,CAAC;kLAACN,UAAAA,CAAEK,MAAM;kLAAIL,UAAAA,CAAEK,MAAM;QAAIJ;KAAwB;CAC1D;AAOM,MAAMM,oMAA2CP,UAAAA,CAAEM,KAAK,CAAC;IAC9DH;8KACAH,UAAAA,CAAEQ,MAAM,2KACNR,UAAAA,CAAEK,MAAM,8KACRL,UAAAA,CAAES,IAAI,CAAC,IAAMF;8KAEfP,UAAAA,CAAEU,QAAQ,2KAACV,UAAAA,CAAEW,QAAQ,2KAACX,UAAAA,CAAEK,MAAM;8KAC9BL,UAAAA,CAAEU,QAAQ,2KACRV,UAAAA,CAAEW,QAAQ,2KACRX,UAAAA,CAAEI,KAAK,CAAC;kLACNJ,UAAAA,CAAEY,OAAO,CAAC;kLACVZ,UAAAA,CAAEY,OAAO,CAAC;kLACVZ,UAAAA,CAAEY,OAAO,CAAC;KACX;8KAGLZ,UAAAA,CAAEU,QAAQ,2KAACV,UAAAA,CAAEa,OAAO;CACrB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8343, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/parse-and-validate-flight-router-state.tsx"],"sourcesContent":["import type { FlightRouterState } from './types'\nimport { flightRouterStateSchema } from './types'\nimport { assert } from 'next/dist/compiled/superstruct'\n\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[]\n): FlightRouterState\nexport function parseAndValidateFlightRouterState(\n  stateHeader: undefined\n): undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined {\n  if (typeof stateHeader === 'undefined') {\n    return undefined\n  }\n  if (Array.isArray(stateHeader)) {\n    throw new Error(\n      'Multiple router state headers were sent. This is not allowed.'\n    )\n  }\n\n  // We limit the size of the router state header to ~40kb. This is to prevent\n  // a malicious user from sending a very large header and slowing down the\n  // resolving of the router state.\n  // This is around 2,000 nested or parallel route segment states:\n  // '{\"children\":[\"\",{}]}'.length === 20.\n  if (stateHeader.length > 20 * 2000) {\n    throw new Error('The router state header was too large.')\n  }\n\n  try {\n    const state = JSON.parse(decodeURIComponent(stateHeader))\n    assert(state, flightRouterStateSchema)\n    return state\n  } catch {\n    throw new Error('The router state header was sent but could not be parsed.')\n  }\n}\n"],"names":["flightRouterStateSchema","assert","parseAndValidateFlightRouterState","stateHeader","undefined","Array","isArray","Error","length","state","JSON","parse","decodeURIComponent"],"mappings":";;;AACA,SAASA,uBAAuB,QAAQ,UAAS;AACjD,SAASC,MAAM,QAAQ,iCAAgC;;;AAWhD,SAASC,kCACdC,WAA0C;IAE1C,IAAI,OAAOA,gBAAgB,aAAa;QACtC,OAAOC;IACT;IACA,IAAIC,MAAMC,OAAO,CAACH,cAAc;QAC9B,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4EAA4E;IAC5E,yEAAyE;IACzE,iCAAiC;IACjC,gEAAgE;IAChE,wCAAwC;IACxC,IAAIJ,YAAYK,MAAM,GAAG,KAAK,MAAM;QAClC,MAAM,OAAA,cAAmD,CAAnD,IAAID,MAAM,2CAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkD;IAC1D;IAEA,IAAI;QACF,MAAME,QAAQC,KAAKC,KAAK,CAACC,mBAAmBT;sLAC5CF,SAAAA,EAAOQ,uLAAOT,0BAAAA;QACd,OAAOS;IACT,EAAE,OAAM;QACN,MAAM,OAAA,cAAsE,CAAtE,IAAIF,MAAM,8DAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAqE;IAC7E;AACF","ignoreList":[0]}},
    {"offset": {"line": 8391, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-flight-router-state-from-loader-tree.ts"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\nimport type { FlightRouterState } from './types'\nimport type { GetDynamicParamFromSegment } from './app-render'\nimport { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\n\nexport function createFlightRouterStateFromLoaderTree(\n  [segment, parallelRoutes, { layout }]: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  searchParams: any,\n  rootLayoutIncluded = false\n): FlightRouterState {\n  const dynamicParam = getDynamicParamFromSegment(segment)\n  const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment\n\n  const segmentTree: FlightRouterState = [\n    addSearchParamsIfPageSegment(treeSegment, searchParams),\n    {},\n  ]\n\n  if (!rootLayoutIncluded && typeof layout !== 'undefined') {\n    rootLayoutIncluded = true\n    segmentTree[4] = true\n  }\n\n  segmentTree[1] = Object.keys(parallelRoutes).reduce(\n    (existingValue, currentValue) => {\n      existingValue[currentValue] = createFlightRouterStateFromLoaderTree(\n        parallelRoutes[currentValue],\n        getDynamicParamFromSegment,\n        searchParams,\n        rootLayoutIncluded\n      )\n      return existingValue\n    },\n    {} as FlightRouterState[1]\n  )\n\n  return segmentTree\n}\n"],"names":["addSearchParamsIfPageSegment","createFlightRouterStateFromLoaderTree","segment","parallelRoutes","layout","getDynamicParamFromSegment","searchParams","rootLayoutIncluded","dynamicParam","treeSegment","segmentTree","Object","keys","reduce","existingValue","currentValue"],"mappings":";;;AAGA,SAASA,4BAA4B,QAAQ,2BAA0B;;AAEhE,SAASC,sCACd,CAACC,SAASC,gBAAgB,EAAEC,MAAM,EAAE,CAAa,EACjDC,0BAAsD,EACtDC,YAAiB,EACjBC,qBAAqB,KAAK;IAE1B,MAAMC,eAAeH,2BAA2BH;IAChD,MAAMO,cAAcD,eAAeA,aAAaC,WAAW,GAAGP;IAE9D,MAAMQ,cAAiC;oLACrCV,+BAAAA,EAA6BS,aAAaH;QAC1C,CAAC;KACF;IAED,IAAI,CAACC,sBAAsB,OAAOH,WAAW,aAAa;QACxDG,qBAAqB;QACrBG,WAAW,CAAC,EAAE,GAAG;IACnB;IAEAA,WAAW,CAAC,EAAE,GAAGC,OAAOC,IAAI,CAACT,gBAAgBU,MAAM,CACjD,CAACC,eAAeC;QACdD,aAAa,CAACC,aAAa,GAAGd,sCAC5BE,cAAc,CAACY,aAAa,EAC5BV,4BACAC,cACAC;QAEF,OAAOO;IACT,GACA,CAAC;IAGH,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 8419, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/csrf-protection.ts"],"sourcesContent":["// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function\n// can be run from edge. This is a simple implementation that safely achieves the required functionality.\n// the goal is to match the functionality for remotePatterns as defined here -\n// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns\n// TODO - retrofit micromatch to work in edge and use that instead\nfunction matchWildcardDomain(domain: string, pattern: string) {\n  const domainParts = domain.split('.')\n  const patternParts = pattern.split('.')\n\n  if (patternParts.length < 1) {\n    // pattern is empty and therefore invalid to match against\n    return false\n  }\n\n  if (domainParts.length < patternParts.length) {\n    // domain has too few segments and thus cannot match\n    return false\n  }\n\n  let depth = 0\n  while (patternParts.length && depth++ < 2) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '':\n      case '*':\n      case '**': {\n        // invalid pattern. pattern segments must be non empty\n        // Additionally wildcards are only supported below the domain level\n        return false\n      }\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  while (patternParts.length) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '': {\n        // invalid pattern. pattern segments must be non empty\n        return false\n      }\n      case '*': {\n        // wildcard matches anything so we continue if the domain part is non-empty\n        if (domainPart) {\n          continue\n        } else {\n          return false\n        }\n      }\n      case '**': {\n        // if this is not the last item in the pattern the pattern is invalid\n        if (patternParts.length > 0) {\n          return false\n        }\n        // recursive wildcard matches anything so we terminate here if the domain part is non empty\n        return domainPart !== undefined\n      }\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  // We exhausted the pattern. If we also exhausted the domain we have a match\n  return domainParts.length === 0\n}\n\nexport const isCsrfOriginAllowed = (\n  originDomain: string,\n  allowedOrigins: string[] = []\n): boolean => {\n  return allowedOrigins.some(\n    (allowedOrigin) =>\n      allowedOrigin &&\n      (allowedOrigin === originDomain ||\n        matchWildcardDomain(originDomain, allowedOrigin))\n  )\n}\n"],"names":["matchWildcardDomain","domain","pattern","domainParts","split","patternParts","length","depth","patternPart","pop","domainPart","undefined","isCsrfOriginAllowed","originDomain","allowedOrigins","some","allowedOrigin"],"mappings":"AAAA,uHAAuH;AACvH,yGAAyG;AACzG,8EAA8E;AAC9E,4EAA4E;AAC5E,kEAAkE;;;;AAClE,SAASA,oBAAoBC,MAAc,EAAEC,OAAe;IAC1D,MAAMC,cAAcF,OAAOG,KAAK,CAAC;IACjC,MAAMC,eAAeH,QAAQE,KAAK,CAAC;IAEnC,IAAIC,aAAaC,MAAM,GAAG,GAAG;QAC3B,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAIH,YAAYG,MAAM,GAAGD,aAAaC,MAAM,EAAE;QAC5C,oDAAoD;QACpD,OAAO;IACT;IAEA,IAAIC,QAAQ;IACZ,MAAOF,aAAaC,MAAM,IAAIC,UAAU,EAAG;QACzC,MAAMC,cAAcH,aAAaI,GAAG;QACpC,MAAMC,aAAaP,YAAYM,GAAG;QAElC,OAAQD;YACN,KAAK;YACL,KAAK;YACL,KAAK;gBAAM;oBACT,sDAAsD;oBACtD,mEAAmE;oBACnE,OAAO;gBACT;YACA;gBAAS;oBACP,IAAIE,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,MAAOH,aAAaC,MAAM,CAAE;QAC1B,MAAME,cAAcH,aAAaI,GAAG;QACpC,MAAMC,aAAaP,YAAYM,GAAG;QAElC,OAAQD;YACN,KAAK;gBAAI;oBACP,sDAAsD;oBACtD,OAAO;gBACT;YACA,KAAK;gBAAK;oBACR,2EAA2E;oBAC3E,IAAIE,YAAY;wBACd;oBACF,OAAO;wBACL,OAAO;oBACT;gBACF;YACA,KAAK;gBAAM;oBACT,qEAAqE;oBACrE,IAAIL,aAAaC,MAAM,GAAG,GAAG;wBAC3B,OAAO;oBACT;oBACA,2FAA2F;oBAC3F,OAAOI,eAAeC;gBACxB;YACA;gBAAS;oBACP,IAAID,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,4EAA4E;IAC5E,OAAOL,YAAYG,MAAM,KAAK;AAChC;AAEO,MAAMM,sBAAsB,CACjCC,cACAC,iBAA2B,EAAE;IAE7B,OAAOA,eAAeC,IAAI,CACxB,CAACC,gBACCA,iBACCA,CAAAA,kBAAkBH,gBACjBb,oBAAoBa,cAAcG,cAAa;AAEvD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 8506, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\n// This function creates a Flight-acceptable server module map proxy from our\n// Server Reference Manifest similar to our client module map.\n// This is because our manifest contains a lot of internal Next.js data that\n// are relevant to the runtime, workers, etc. that React doesn't need to know.\nexport function createServerModuleMap({\n  serverActionsManifest,\n}: {\n  serverActionsManifest: ActionManifest\n}) {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          serverActionsManifest[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ][id].workers\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string,\n  serverActionsManifest: ActionManifest\n) {\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n  const workerName = normalizeWorkerPageName(pageName)\n\n  // no workers, nothing to forward to\n  if (!workers) return\n\n  // if there is a worker for this page, no need to forward it.\n  if (workers[workerName]) {\n    return\n  }\n\n  // otherwise, grab the first worker that has a handler for this action id\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\n/**\n * The flight entry loader keys actions by bundlePath.\n * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n"],"names":["normalizeAppPath","pathHasPrefix","removePathPrefix","workAsyncStorage","createServerModuleMap","serverActionsManifest","Proxy","get","_","id","workers","process","env","NEXT_RUNTIME","workStore","getStore","workerEntry","normalizeWorkerPageName","page","Object","values","at","undefined","moduleId","async","name","chunks","selectWorkerForForwarding","actionId","pageName","workerName","denormalizeWorkerPageName","keys","bundlePath"],"mappings":";;;;AACA,SAASA,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,aAAa,QAAQ,gDAA+C;AAC7E,SAASC,gBAAgB,QAAQ,mDAAkD;AACnF,SAASC,gBAAgB,QAAQ,gCAA+B;;;;;;AAMzD,SAASC,sBAAsB,EACpCC,qBAAqB,EAGtB;IACC,OAAO,IAAIC,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;YACP,MAAMC,UACJL,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,UAAS,SAAS,qCAChD,CAACJ,GAAG,CAACC,OAAO;YAEf,MAAMI,8RAAYX,mBAAAA,CAAiBY,QAAQ;YAE3C,IAAIC;YAIJ,IAAIF,WAAW;gBACbE,cAAcN,OAAO,CAACO,wBAAwBH,UAAUI,IAAI,EAAE;YAChE,OAAO;gBACL,gEAAgE;gBAChE,kEAAkE;gBAClE,sEAAsE;gBACtE,qEAAqE;gBACrE,qEAAqE;gBACrE,qEAAqE;gBACrE,oCAAoC;gBACpCF,cAAcG,OAAOC,MAAM,CAACV,SAASW,EAAE,CAAC;YAC1C;YAEA,IAAI,CAACL,aAAa;gBAChB,OAAOM;YACT;YAEA,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE,GAAGR;YAE5B,OAAO;gBAAEP,IAAIc;gBAAUE,MAAMhB;gBAAIiB,QAAQ,EAAE;gBAAEF;YAAM;QACrD;IACF;AAEJ;AAMO,SAASG,0BACdC,QAAgB,EAChBC,QAAgB,EAChBxB,qBAAqC;QAGnCA;IADF,MAAMK,UAAAA,CACJL,mCAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,UAAS,SAAS,qCAChD,CAACe,SAAS,KAAA,OAAA,KAAA,IAFXvB,iCAEaK,OAAO;IACtB,MAAMoB,aAAab,wBAAwBY;IAE3C,oCAAoC;IACpC,IAAI,CAACnB,SAAS;IAEd,6DAA6D;IAC7D,IAAIA,OAAO,CAACoB,WAAW,EAAE;QACvB;IACF;IAEA,yEAAyE;IACzE,OAAOC,0BAA0BZ,OAAOa,IAAI,CAACtB,QAAQ,CAAC,EAAE;AAC1D;AAEA;;;CAGC,GACD,SAASO,wBAAwBY,QAAgB;IAC/C,iNAAI5B,gBAAAA,EAAc4B,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;CAEC,GACD,SAASE,0BAA0BE,UAAkB;IACnD,2MAAOjC,mBAAAA,kNAAiBE,mBAAAA,EAAiB+B,YAAY;AACvD","ignoreList":[0]}},
    {"offset": {"line": 8583, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport { selectWorkerForForwarding } from './action-utils'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server.edge'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\nfunction formDataFromSearchQueryString(query: string) {\n  const searchParams = new URLSearchParams(query)\n  const formData = new FormData()\n  for (const [key, value] of searchParams) {\n    formData.append(key, value)\n  }\n  return formData\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nasync function addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  await Promise.all([\n    workStore.incrementalCache?.revalidateTag(workStore.revalidatedTags || []),\n    ...Object.values(workStore.pendingRevalidates || {}),\n    ...(workStore.pendingRevalidateWrites || []),\n  ])\n\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // To keep the header size small, we use a tuple of\n  // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]\n  // instead of a JSON object.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.revalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  res.setHeader(\n    'x-action-revalidated',\n    JSON.stringify([[], isTagRevalidated, isCookieRevalidated])\n  )\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string,\n  workStore: WorkStore\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string\n): URL | null {\n  if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {\n    // Make sure we are appending the basePath to relative URLS\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.revalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.revalidatedTags.join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\nexport function parseHostHeader(\n  headers: IncomingHttpHeaders,\n  originDomain?: string\n) {\n  const forwardedHostHeader = headers['x-forwarded-host']\n  const forwardedHostHeaderValue =\n    forwardedHostHeader && Array.isArray(forwardedHostHeader)\n      ? forwardedHostHeader[0]\n      : forwardedHostHeader?.split(',')?.[0]?.trim()\n  const hostHeader = headers['host']\n\n  if (originDomain) {\n    return forwardedHostHeaderValue === originDomain\n      ? {\n          type: HostType.XForwardedHost,\n          value: forwardedHostHeaderValue,\n        }\n      : hostHeader === originDomain\n        ? {\n            type: HostType.Host,\n            value: hostHeader,\n          }\n        : undefined\n  }\n\n  return forwardedHostHeaderValue\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeaderValue,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n}\n\ntype ServerModuleMap = Record<\n  string,\n  {\n    id: string\n    chunks: string[]\n    name: string\n  }\n>\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  serverModuleMap,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  serverModuleMap: ServerModuleMap\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n}): Promise<\n  | undefined\n  | {\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n> {\n  const contentType = req.headers['content-type']\n  const { serverActionsManifest, page } = ctx.renderOpts\n\n  const {\n    actionId,\n    isURLEncodedAction,\n    isMultipartAction,\n    isFetchAction,\n    isServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  // If it's not a Server Action, skip handling.\n  if (!isServerAction) {\n    return\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  const finalizeAndGenerateFlight: GenerateFlight = (...args) => {\n    // When we switch to the render phase, cookies() will return\n    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n    // We want the render to see any cookie writes that we performed during the action,\n    // so we need to update the immutable cookies to reflect the changes.\n    synchronizeMutableCookies(requestStore)\n    requestStore.phase = 'render'\n    return generateFlight(...args)\n  }\n\n  requestStore.phase = 'action'\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originDomain =\n    typeof req.headers['origin'] === 'string'\n      ? new URL(req.headers['origin']).host\n      : undefined\n  const host = parseHostHeader(req.headers)\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        await Promise.all([\n          workStore.incrementalCache?.revalidateTag(\n            workStore.revalidatedTags || []\n          ),\n          ...Object.values(workStore.pendingRevalidates || {}),\n          ...(workStore.pendingRevalidateWrites || []),\n        ])\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // if the page was not revalidated, we can skip the rendering the flight tree\n            skipFlight: !workStore.pathWasRevalidated,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  let boundActionArguments: unknown[] = []\n\n  const { actionAsyncStorage } = ComponentMod\n\n  let actionResult: RenderResult | undefined\n  let formState: any | undefined\n  let actionModId: string | undefined\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(\n      actionId,\n      page,\n      serverActionsManifest\n    )\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath,\n          workStore\n        ),\n      }\n    }\n  }\n\n  try {\n    await actionAsyncStorage.run({ isAction: true }, async () => {\n      if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' &&\n        isWebNextRequest(req)\n      ) {\n        if (!req.body) {\n          throw new Error('invariant: Missing request body.')\n        }\n\n        // TODO: add body limit\n\n        // Use react-server-dom-webpack/server.edge\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeAction,\n          decodeFormState,\n        } = ComponentMod\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        if (isMultipartAction) {\n          // TODO-APP: Add streaming support\n          const formData = await req.request.formData()\n          if (isFetchAction) {\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              const actionReturnedState = await workUnitAsyncStorage.run(\n                requestStore,\n                action\n              )\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n\n              requestStore.phase = 'render'\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          const reader = req.body.getReader()\n          while (true) {\n            const { done, value } = await reader.read()\n            if (done) {\n              break\n            }\n\n            chunks.push(value)\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        isNodeNextRequest(req)\n      ) {\n        // Use react-server-dom-webpack/server.node which supports streaming\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeReplyFromBusboy,\n          decodeAction,\n          decodeFormState,\n        } = require(\n          `./react-server.node`\n        ) as typeof import('./react-server.node')\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        const { Transform } =\n          require('node:stream') as typeof import('node:stream')\n\n        const defaultBodySizeLimit = '1 MB'\n        const bodySizeLimit =\n          serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n        const bodySizeLimitBytes =\n          bodySizeLimit !== defaultBodySizeLimit\n            ? (\n                require('next/dist/compiled/bytes') as typeof import('bytes')\n              ).parse(bodySizeLimit)\n            : 1024 * 1024 // 1 MB\n\n        let size = 0\n        const body = req.body.pipe(\n          new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } = require('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\n                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n        )\n\n        if (isMultipartAction) {\n          if (isFetchAction) {\n            const busboy = (require('busboy') as typeof import('busboy'))({\n              defParamCharset: 'utf8',\n              headers: req.headers,\n              limits: { fieldSize: bodySizeLimitBytes },\n            })\n\n            body.pipe(busboy)\n\n            boundActionArguments = await decodeReplyFromBusboy(\n              busboy,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            // React doesn't yet publish a busboy version of decodeAction\n            // so we polyfill the parsing of FormData.\n            const fakeRequest = new Request('http://localhost', {\n              method: 'POST',\n              // @ts-expect-error\n              headers: { 'Content-Type': contentType },\n              body: new ReadableStream({\n                start: (controller) => {\n                  body.on('data', (chunk) => {\n                    controller.enqueue(new Uint8Array(chunk))\n                  })\n                  body.on('end', () => {\n                    controller.close()\n                  })\n                  body.on('error', (err) => {\n                    controller.error(err)\n                  })\n                },\n              }),\n              duplex: 'half',\n            })\n            const formData = await fakeRequest.formData()\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              const actionReturnedState = await workUnitAsyncStorage.run(\n                requestStore,\n                action\n              )\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n\n              requestStore.phase = 'render'\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          for await (const chunk of req.body) {\n            chunks.push(Buffer.from(chunk))\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else {\n        throw new Error('Invariant: Unknown request type.')\n      }\n\n      // actions.js\n      // app/page.js\n      //   action worker1\n      //     appRender1\n\n      // app/foo/page.js\n      //   action worker2\n      //     appRender\n\n      // / -> fire action -> POST / -> appRender1 -> modId for the action file\n      // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n      try {\n        actionModId =\n          actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n      } catch (err) {\n        if (actionId !== null) {\n          console.error(err)\n        }\n        return {\n          type: 'not-found',\n        }\n      }\n\n      const actionMod = (await ComponentMod.__next_app__.require(\n        actionModId\n      )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n      const actionHandler =\n        actionMod[\n          // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n          actionId!\n        ]\n\n      const returnVal = await workUnitAsyncStorage.run(requestStore, () =>\n        actionHandler.apply(null, boundActionArguments)\n      )\n\n      // For form actions, we need to continue rendering the page.\n      if (isFetchAction) {\n        await addRevalidationHeader(res, {\n          workStore,\n          requestStore,\n        })\n\n        actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n          actionResult: Promise.resolve(returnVal),\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        })\n      }\n    })\n\n    return {\n      type: 'done',\n      result: actionResult,\n      formState,\n    }\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore\n          ),\n        }\n      }\n\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.fromStatic(''),\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            skipFlight: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n      return {\n        type: 'not-found',\n      }\n    }\n\n    if (isFetchAction) {\n      res.statusCode = 500\n      await Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ])\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      requestStore.phase = 'render'\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    throw err\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string {\n  try {\n    // if we're missing the action ID header, we can't do any further processing\n    if (!actionId) {\n      throw new Error(\"Invariant: Missing 'next-action' header.\")\n    }\n\n    const actionModId = serverModuleMap?.[actionId]?.id\n\n    if (!actionModId) {\n      throw new Error(\n        \"Invariant: Couldn't find action module ID from module map.\"\n      )\n    }\n\n    return actionModId\n  } catch (err) {\n    throw new Error(\n      `Failed to find Server Action \"${actionId}\". This request might be from an older or newer deployment. ${\n        err instanceof Error ? `Original error: ${err.message}` : ''\n      }\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n}\n"],"names":["RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RenderResult","FlightRenderResult","filterReqHeaders","actionsForbiddenHeaders","getModifiedCookieValues","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","getServerActionRequestMetadata","isCsrfOriginAllowed","warn","RequestCookies","ResponseCookies","HeadersAdapter","fromNodeOutgoingHttpHeaders","selectWorkerForForwarding","isNodeNextRequest","isWebNextRequest","RedirectStatusCode","synchronizeMutableCookies","workUnitAsyncStorage","formDataFromSearchQueryString","query","searchParams","URLSearchParams","formData","FormData","key","value","append","nodeHeadersToRecord","headers","record","Object","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","from","responseHeaders","getHeaders","responseCookies","mergedHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","Promise","all","incrementalCache","revalidateTag","revalidatedTags","values","pendingRevalidates","pendingRevalidateWrites","isTagRevalidated","length","isCookieRevalidated","mutableCookies","setHeader","JSON","stringify","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","requestProtocol","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","includes","cancel","err","console","error","fromStatic","getAppRelativeRedirectUrl","redirectUrl","parsedRedirectUrl","pathname","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","search","prerenderManifest","preview","previewModeId","limitUntrustedHeaderValueForLogs","slice","parseHostHeader","originDomain","forwardedHostHeader","forwardedHostHeaderValue","split","trim","hostHeader","type","handleAction","ComponentMod","serverModuleMap","generateFlight","serverActions","ctx","contentType","serverActionsManifest","page","renderOpts","actionId","isURLEncodedAction","isMultipartAction","isFetchAction","isServerAction","isStaticGeneration","temporaryReferences","finalizeAndGenerateFlight","args","phase","fetchCache","warning","warnBadServerActionRequest","allowedOrigins","statusCode","promise","reject","result","actionResult","skipFlight","pathWasRevalidated","boundActionArguments","actionAsyncStorage","formState","actionModId","actionWasForwarded","Boolean","forwardedWorker","run","isAction","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","request","action","actionReturnedState","getActionModIdOrError","chunks","reader","getReader","done","read","push","actionData","Buffer","concat","decodeReplyFromBusboy","require","Transform","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","pipe","transform","chunk","encoding","callback","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","fakeRequest","Request","ReadableStream","start","controller","on","enqueue","Uint8Array","close","actionMod","__next_app__","actionHandler","returnVal","apply","resolve","SeeOther","id","message"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9235, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/server-inserted-html.tsx"],"sourcesContent":["// Provider for the `useServerInsertedHTML` API to register callbacks to insert\n// elements into the HTML stream.\n\nimport React, { type JSX } from 'react'\nimport { ServerInsertedHTMLContext } from '../../shared/lib/server-inserted-html.shared-runtime'\n\nexport function createServerInsertedHTML() {\n  const serverInsertedHTMLCallbacks: (() => React.ReactNode)[] = []\n  const addInsertedHtml = (handler: () => React.ReactNode) => {\n    serverInsertedHTMLCallbacks.push(handler)\n  }\n\n  return {\n    ServerInsertedHTMLProvider({ children }: { children: JSX.Element }) {\n      return (\n        <ServerInsertedHTMLContext.Provider value={addInsertedHtml}>\n          {children}\n        </ServerInsertedHTMLContext.Provider>\n      )\n    },\n    renderServerInsertedHTML() {\n      return serverInsertedHTMLCallbacks.map((callback, index) => (\n        <React.Fragment key={'__next_server_inserted__' + index}>\n          {callback()}\n        </React.Fragment>\n      ))\n    },\n  }\n}\n"],"names":["React","ServerInsertedHTMLContext","createServerInsertedHTML","serverInsertedHTMLCallbacks","addInsertedHtml","handler","push","ServerInsertedHTMLProvider","children","Provider","value","renderServerInsertedHTML","map","callback","index","Fragment"],"mappings":"AAAA,+EAA+E;AAC/E,iCAAiC;;;;;AAEjC,OAAOA,WAAyB,QAAO;AACvC,SAASC,yBAAyB,QAAQ,uDAAsD;;;;AAEzF,SAASC;IACd,MAAMC,8BAAyD,EAAE;IACjE,MAAMC,kBAAkB,CAACC;QACvBF,4BAA4BG,IAAI,CAACD;IACnC;IAEA,OAAO;QACLE,4BAA2B,EAAEC,QAAQ,EAA6B;YAChE,OAAA,WAAA,mLACE,MAAA,2MAACP,4BAAAA,CAA0BQ,QAAQ,EAAA;gBAACC,OAAON;0BACxCI;;QAGP;QACAG;YACE,OAAOR,4BAA4BS,GAAG,CAAC,CAACC,UAAUC,QAAAA,WAAAA,mLAChD,MAAA,qKAACd,UAAAA,CAAMe,QAAQ,EAAA;8BACZF;mBADkB,6BAA6BC;QAItD;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 9271, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/required-scripts.tsx"],"sourcesContent":["import { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { BuildManifest } from '../get-page-files'\n\nimport ReactDOM from 'react-dom'\n\nexport function getRequiredScripts(\n  buildManifest: BuildManifest,\n  assetPrefix: string,\n  crossOrigin: undefined | '' | 'anonymous' | 'use-credentials',\n  SRIManifest: undefined | Record<string, string>,\n  qs: string,\n  nonce: string | undefined,\n  pagePath: string\n): [\n  () => void,\n  { src: string; integrity?: string; crossOrigin?: string | undefined },\n] {\n  let preinitScripts: () => void\n  let preinitScriptCommands: string[] = []\n  const bootstrapScript: {\n    src: string\n    integrity?: string\n    crossOrigin?: string | undefined\n  } = {\n    src: '',\n    crossOrigin,\n  }\n\n  const files = (\n    buildManifest.rootMainFilesTree?.[pagePath] || buildManifest.rootMainFiles\n  ).map(encodeURIPath)\n  if (files.length === 0) {\n    throw new Error(\n      'Invariant: missing bootstrap script. This is a bug in Next.js'\n    )\n  }\n  if (SRIManifest) {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n    bootstrapScript.integrity = SRIManifest[files[0]]\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      const integrity = SRIManifest[files[i]]\n      preinitScriptCommands.push(src, integrity)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a double indexed array of src/integrity pairs\n      for (let i = 0; i < preinitScriptCommands.length; i += 2) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          integrity: preinitScriptCommands[i + 1],\n          crossOrigin,\n          nonce,\n        })\n      }\n    }\n  } else {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      preinitScriptCommands.push(src)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a singled indexed array of src values\n      for (let i = 0; i < preinitScriptCommands.length; i++) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          nonce,\n          crossOrigin,\n        })\n      }\n    }\n  }\n\n  return [preinitScripts, bootstrapScript]\n}\n"],"names":["encodeURIPath","ReactDOM","getRequiredScripts","buildManifest","assetPrefix","crossOrigin","SRIManifest","qs","nonce","pagePath","preinitScripts","preinitScriptCommands","bootstrapScript","src","files","rootMainFilesTree","rootMainFiles","map","length","Error","integrity","i","push","preinit","as"],"mappings":";;;AAAA,SAASA,aAAa,QAAQ,mCAAkC;AAGhE,OAAOC,cAAc,YAAW;;;AAEzB,SAASC,mBACdC,aAA4B,EAC5BC,WAAmB,EACnBC,WAA6D,EAC7DC,WAA+C,EAC/CC,EAAU,EACVC,KAAyB,EACzBC,QAAgB;QAiBdN;IAZF,IAAIO;IACJ,IAAIC,wBAAkC,EAAE;IACxC,MAAMC,kBAIF;QACFC,KAAK;QACLR;IACF;IAEA,MAAMS,QACJX,CAAAA,CAAAA,CAAAA,mCAAAA,cAAcY,iBAAiB,KAAA,OAAA,KAAA,IAA/BZ,gCAAiC,CAACM,SAAS,KAAIN,cAAca,aAAY,EACzEC,GAAG,uLAACjB,gBAAAA;IACN,IAAIc,MAAMI,MAAM,KAAK,GAAG;QACtB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,IAAIb,aAAa;QACfM,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAC3DK,gBAAgBQ,SAAS,GAAGd,WAAW,CAACQ,KAAK,CAAC,EAAE,CAAC;QAEjD,IAAK,IAAIO,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjD,MAAMa,YAAYd,WAAW,CAACQ,KAAK,CAACO,EAAE,CAAC;YACvCV,sBAAsBW,IAAI,CAACT,KAAKO;QAClC;QACAV,iBAAiB;YACf,yEAAyE;YACzE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,KAAK,EAAG;0LACxDpB,UAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJJ,WAAWT,qBAAqB,CAACU,IAAI,EAAE;oBACvChB;oBACAG;gBACF;YACF;QACF;IACF,OAAO;QACLI,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAE3D,IAAK,IAAIc,IAAI,GAAGA,IAAIP,MAAMI,MAAM,EAAEG,IAAK;YACrC,MAAMR,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACO,EAAE,GAAGd;YACjDI,sBAAsBW,IAAI,CAACT;QAC7B;QACAH,iBAAiB;YACf,iEAAiE;YACjE,IAAK,IAAIW,IAAI,GAAGA,IAAIV,sBAAsBO,MAAM,EAAEG,IAAK;0LACrDpB,UAAAA,CAASsB,OAAO,CAACZ,qBAAqB,CAACU,EAAE,EAAE;oBACzCG,IAAI;oBACJhB;oBACAH;gBACF;YACF;QACF;IACF;IAEA,OAAO;QAACK;QAAgBE;KAAgB;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 9341, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/make-get-server-inserted-html.tsx"],"sourcesContent":["import React, { type JSX } from 'react'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport type { ClientTraceDataEntry } from '../lib/trace/tracer'\n\nexport function makeGetServerInsertedHTML({\n  polyfills,\n  renderServerInsertedHTML,\n  serverCapturedErrors,\n  tracingMetadata,\n  basePath,\n}: {\n  polyfills: JSX.IntrinsicElements['script'][]\n  renderServerInsertedHTML: () => React.ReactNode\n  tracingMetadata: ClientTraceDataEntry[] | undefined\n  serverCapturedErrors: Array<unknown>\n  basePath: string\n}) {\n  let flushedErrorMetaTagsUntilIndex = 0\n  // flag for static content that only needs to be flushed once\n  let hasFlushedInitially = false\n\n  const polyfillTags = polyfills.map((polyfill) => {\n    return <script key={polyfill.src} {...polyfill} />\n  })\n\n  return async function getServerInsertedHTML() {\n    // Loop through all the errors that have been captured but not yet\n    // flushed.\n    const errorMetaTags = []\n    while (flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length) {\n      const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex]\n      flushedErrorMetaTagsUntilIndex++\n\n      if (isHTTPAccessFallbackError(error)) {\n        errorMetaTags.push(\n          <meta name=\"robots\" content=\"noindex\" key={error.digest} />,\n          process.env.NODE_ENV === 'development' ? (\n            <meta name=\"next-error\" content=\"not-found\" key=\"next-error\" />\n          ) : null\n        )\n      } else if (isRedirectError(error)) {\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(error),\n          basePath\n        )\n        const statusCode = getRedirectStatusCodeFromError(error)\n        const isPermanent =\n          statusCode === RedirectStatusCode.PermanentRedirect ? true : false\n        if (redirectUrl) {\n          errorMetaTags.push(\n            <meta\n              id=\"__next-page-redirect\"\n              httpEquiv=\"refresh\"\n              content={`${isPermanent ? 0 : 1};url=${redirectUrl}`}\n              key={error.digest}\n            />\n          )\n        }\n      }\n    }\n\n    const traceMetaTags = (tracingMetadata || []).map(\n      ({ key, value }, index) => (\n        <meta key={`next-trace-data-${index}`} name={key} content={value} />\n      )\n    )\n\n    const serverInsertedHTML = renderServerInsertedHTML()\n\n    // Skip React rendering if we know the content is empty.\n    if (\n      polyfillTags.length === 0 &&\n      traceMetaTags.length === 0 &&\n      errorMetaTags.length === 0 &&\n      Array.isArray(serverInsertedHTML) &&\n      serverInsertedHTML.length === 0\n    ) {\n      return ''\n    }\n\n    const stream = await renderToReadableStream(\n      <>\n        {\n          /* Insert the polyfills if they haven't been flushed yet. */\n          hasFlushedInitially ? null : polyfillTags\n        }\n        {serverInsertedHTML}\n        {hasFlushedInitially ? null : traceMetaTags}\n        {errorMetaTags}\n      </>,\n      {\n        // Larger chunk because this isn't sent over the network.\n        // Let's set it to 1MB.\n        progressiveChunkSize: 1024 * 1024,\n      }\n    )\n\n    hasFlushedInitially = true\n\n    // There's no need to wait for the stream to be ready\n    // e.g. calling `await stream.allReady` because `streamToString` will\n    // wait and decode the stream progressively with better parallelism.\n    return streamToString(stream)\n  }\n}\n"],"names":["React","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","renderToReadableStream","streamToString","RedirectStatusCode","addPathPrefix","makeGetServerInsertedHTML","polyfills","renderServerInsertedHTML","serverCapturedErrors","tracingMetadata","basePath","flushedErrorMetaTagsUntilIndex","hasFlushedInitially","polyfillTags","map","polyfill","script","src","getServerInsertedHTML","errorMetaTags","length","error","push","meta","name","content","digest","process","env","NODE_ENV","redirectUrl","statusCode","isPermanent","PermanentRedirect","id","httpEquiv","traceMetaTags","key","value","index","serverInsertedHTML","Array","isArray","stream","progressiveChunkSize"],"mappings":";;;;AAAA,OAAOA,WAAyB,QAAO;AACvC,SAASC,yBAAyB,QAAQ,oEAAmE;AAC7G,SACEC,uBAAuB,EACvBC,8BAA8B,QACzB,mCAAkC;AACzC,SAASC,eAAe,QAAQ,yCAAwC;AACxE,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SAASC,cAAc,QAAQ,0CAAyC;AACxE,SAASC,kBAAkB,QAAQ,+CAA8C;AACjF,SAASC,aAAa,QAAQ,gDAA+C;;;;;;;;;;AAGtE,SAASC,0BAA0B,EACxCC,SAAS,EACTC,wBAAwB,EACxBC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EAOT;IACC,IAAIC,iCAAiC;IACrC,6DAA6D;IAC7D,IAAIC,sBAAsB;IAE1B,MAAMC,eAAeP,UAAUQ,GAAG,CAAC,CAACC;QAClC,OAAA,WAAA,mLAAO,MAAA,EAACC,UAAAA;YAA2B,GAAGD,QAAQ;WAA1BA,SAASE,GAAG;IAClC;IAEA,OAAO,eAAeC;QACpB,kEAAkE;QAClE,WAAW;QACX,MAAMC,gBAAgB,EAAE;QACxB,MAAOR,iCAAiCH,qBAAqBY,MAAM,CAAE;YACnE,MAAMC,QAAQb,oBAAoB,CAACG,+BAA+B;YAClEA;YAEA,IAAId,gQAAAA,EAA0BwB,QAAQ;gBACpCF,cAAcG,IAAI,CAAA,WAAA,mLAChB,MAAA,EAACC,QAAAA;oBAAKC,MAAK;oBAASC,SAAQ;mBAAeJ,MAAMK,MAAM,GACvDC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAA,WAAA,mLACvB,MAAA,EAACN,QAAAA;oBAAKC,MAAK;oBAAaC,SAAQ;mBAAgB,gBAC9C;YAER,OAAO,IAAIzB,+MAAAA,EAAgBqB,QAAQ;gBACjC,MAAMS,2NAAc1B,gBAAAA,GAClBN,6MAAAA,EAAwBuB,QACxBX;gBAEF,MAAMqB,iMAAahC,iCAAAA,EAA+BsB;gBAClD,MAAMW,cACJD,gNAAe5B,sBAAAA,CAAmB8B,iBAAiB,GAAG,OAAO;gBAC/D,IAAIH,aAAa;oBACfX,cAAcG,IAAI,CAAA,WAAA,mLAChB,MAAA,EAACC,QAAAA;wBACCW,IAAG;wBACHC,WAAU;wBACVV,SAAS,GAAGO,cAAc,IAAI,EAAE,KAAK,EAAEF,aAAa;uBAC/CT,MAAMK,MAAM;gBAGvB;YACF;QACF;QAEA,MAAMU,gBAAiB3B,CAAAA,mBAAmB,EAAC,EAAGK,GAAG,CAC/C,CAAC,EAAEuB,GAAG,EAAEC,KAAK,EAAE,EAAEC,QAAAA,WAAAA,IACf,qLAAA,EAAChB,QAAAA;gBAAsCC,MAAMa;gBAAKZ,SAASa;eAAhD,CAAC,gBAAgB,EAAEC,OAAO;QAIzC,MAAMC,qBAAqBjC;QAE3B,wDAAwD;QACxD,IACEM,aAAaO,MAAM,KAAK,KACxBgB,cAAchB,MAAM,KAAK,KACzBD,cAAcC,MAAM,KAAK,KACzBqB,MAAMC,OAAO,CAACF,uBACdA,mBAAmBpB,MAAM,KAAK,GAC9B;YACA,OAAO;QACT;QAEA,MAAMuB,SAAS,6LAAM1C,yBAAAA,EAAAA,WAAAA,IACnB,sLAAA,EAAA,2KAAA,CAAA,WAAA,EAAA;;gBAEI,0DAA0D,GAC1DW,sBAAsB,OAAOC;gBAE9B2B;gBACA5B,sBAAsB,OAAOwB;gBAC7BjB;;YAEH;YACE,yDAAyD;YACzD,uBAAuB;YACvByB,sBAAsB,OAAO;QAC/B;QAGFhC,sBAAsB;QAEtB,qDAAqD;QACrD,qEAAqE;QACrE,oEAAoE;QACpE,wNAAOV,iBAAAA,EAAeyC;IACxB;AACF","ignoreList":[0]}},
    {"offset": {"line": 9433, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-css-inlined-link-tags.tsx"],"sourcesContent":["import type {\n  ClientReferenceManifest,\n  CssResource,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get external stylesheet link hrefs based on server CSS manifest.\n */\nexport function getLinkAndScriptTags(\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  filePath: string,\n  injectedCSS: Set<string>,\n  injectedScripts: Set<string>,\n  collectNewImports?: boolean\n): { styles: CssResource[]; scripts: string[] } {\n  const filePathWithoutExt = filePath.replace(/\\.[^.]+$/, '')\n  const cssChunks = new Set<CssResource>()\n  const jsChunks = new Set<string>()\n\n  const entryCSSFiles =\n    clientReferenceManifest.entryCSSFiles[filePathWithoutExt]\n  const entryJSFiles =\n    clientReferenceManifest.entryJSFiles?.[filePathWithoutExt] ?? []\n\n  if (entryCSSFiles) {\n    for (const css of entryCSSFiles) {\n      if (!injectedCSS.has(css.path)) {\n        if (collectNewImports) {\n          injectedCSS.add(css.path)\n        }\n        cssChunks.add(css)\n      }\n    }\n  }\n\n  if (entryJSFiles) {\n    for (const file of entryJSFiles) {\n      if (!injectedScripts.has(file)) {\n        if (collectNewImports) {\n          injectedScripts.add(file)\n        }\n        jsChunks.add(file)\n      }\n    }\n  }\n\n  return { styles: [...cssChunks], scripts: [...jsChunks] }\n}\n"],"names":["getLinkAndScriptTags","clientReferenceManifest","filePath","injectedCSS","injectedScripts","collectNewImports","filePathWithoutExt","replace","cssChunks","Set","jsChunks","entryCSSFiles","entryJSFiles","css","has","path","add","file","styles","scripts"],"mappings":"AAMA;;CAEC,GACD;;;AAAO,SAASA,qBACdC,uBAA8D,EAC9DC,QAAgB,EAChBC,WAAwB,EACxBC,eAA4B,EAC5BC,iBAA2B;QASzBJ;IAPF,MAAMK,qBAAqBJ,SAASK,OAAO,CAAC,YAAY;IACxD,MAAMC,YAAY,IAAIC;IACtB,MAAMC,WAAW,IAAID;IAErB,MAAME,gBACJV,wBAAwBU,aAAa,CAACL,mBAAmB;IAC3D,MAAMM,eACJX,CAAAA,CAAAA,wCAAAA,wBAAwBW,YAAY,KAAA,OAAA,KAAA,IAApCX,qCAAsC,CAACK,mBAAmB,KAAI,EAAE;IAElE,IAAIK,eAAe;QACjB,KAAK,MAAME,OAAOF,cAAe;YAC/B,IAAI,CAACR,YAAYW,GAAG,CAACD,IAAIE,IAAI,GAAG;gBAC9B,IAAIV,mBAAmB;oBACrBF,YAAYa,GAAG,CAACH,IAAIE,IAAI;gBAC1B;gBACAP,UAAUQ,GAAG,CAACH;YAChB;QACF;IACF;IAEA,IAAID,cAAc;QAChB,KAAK,MAAMK,QAAQL,aAAc;YAC/B,IAAI,CAACR,gBAAgBU,GAAG,CAACG,OAAO;gBAC9B,IAAIZ,mBAAmB;oBACrBD,gBAAgBY,GAAG,CAACC;gBACtB;gBACAP,SAASM,GAAG,CAACC;YACf;QACF;IACF;IAEA,OAAO;QAAEC,QAAQ;eAAIV;SAAU;QAAEW,SAAS;eAAIT;SAAS;IAAC;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 9480, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-preloadable-fonts.tsx"],"sourcesContent":["import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get hrefs for fonts to preload\n * Returns null if there are no fonts at all.\n * Returns string[] if there are fonts to preload (font paths)\n * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded\n * Returns null if there are fonts but none to preload and at least some were previously preloaded\n */\nexport function getPreloadableFonts(\n  nextFontManifest: DeepReadonly<NextFontManifest> | undefined,\n  filePath: string | undefined,\n  injectedFontPreloadTags: Set<string>\n): string[] | null {\n  if (!nextFontManifest || !filePath) {\n    return null\n  }\n  const filepathWithoutExtension = filePath.replace(/\\.[^.]+$/, '')\n  const fontFiles = new Set<string>()\n  let foundFontUsage = false\n\n  const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension]\n  if (preloadedFontFiles) {\n    foundFontUsage = true\n    for (const fontFile of preloadedFontFiles) {\n      if (!injectedFontPreloadTags.has(fontFile)) {\n        fontFiles.add(fontFile)\n        injectedFontPreloadTags.add(fontFile)\n      }\n    }\n  }\n\n  if (fontFiles.size) {\n    return [...fontFiles].sort()\n  } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {\n    return []\n  } else {\n    return null\n  }\n}\n"],"names":["getPreloadableFonts","nextFontManifest","filePath","injectedFontPreloadTags","filepathWithoutExtension","replace","fontFiles","Set","foundFontUsage","preloadedFontFiles","app","fontFile","has","add","size","sort"],"mappings":"AAGA;;;;;;CAMC,GACD;;;AAAO,SAASA,oBACdC,gBAA4D,EAC5DC,QAA4B,EAC5BC,uBAAoC;IAEpC,IAAI,CAACF,oBAAoB,CAACC,UAAU;QAClC,OAAO;IACT;IACA,MAAME,2BAA2BF,SAASG,OAAO,CAAC,YAAY;IAC9D,MAAMC,YAAY,IAAIC;IACtB,IAAIC,iBAAiB;IAErB,MAAMC,qBAAqBR,iBAAiBS,GAAG,CAACN,yBAAyB;IACzE,IAAIK,oBAAoB;QACtBD,iBAAiB;QACjB,KAAK,MAAMG,YAAYF,mBAAoB;YACzC,IAAI,CAACN,wBAAwBS,GAAG,CAACD,WAAW;gBAC1CL,UAAUO,GAAG,CAACF;gBACdR,wBAAwBU,GAAG,CAACF;YAC9B;QACF;IACF;IAEA,IAAIL,UAAUQ,IAAI,EAAE;QAClB,OAAO;eAAIR;SAAU,CAACS,IAAI;IAC5B,OAAO,IAAIP,kBAAkBL,wBAAwBW,IAAI,KAAK,GAAG;QAC/D,OAAO,EAAE;IACX,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 9522, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/has-loading-component-in-tree.tsx"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\n\nexport function hasLoadingComponentInTree(tree: LoaderTree): boolean {\n  const [, parallelRoutes, { loading }] = tree\n\n  if (loading) {\n    return true\n  }\n\n  return Object.values(parallelRoutes).some((parallelRoute) =>\n    hasLoadingComponentInTree(parallelRoute)\n  ) as boolean\n}\n"],"names":["hasLoadingComponentInTree","tree","parallelRoutes","loading","Object","values","some","parallelRoute"],"mappings":";;;AAEO,SAASA,0BAA0BC,IAAgB;IACxD,MAAM,GAAGC,gBAAgB,EAAEC,OAAO,EAAE,CAAC,GAAGF;IAExC,IAAIE,SAAS;QACX,OAAO;IACT;IAEA,OAAOC,OAAOC,MAAM,CAACH,gBAAgBI,IAAI,CAAC,CAACC,gBACzCP,0BAA0BO;AAE9B","ignoreList":[0]}},
    {"offset": {"line": 9538, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GACD;;;AAAO,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0]}},
    {"offset": {"line": 9552, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/parse-loader-tree.ts"],"sourcesContent":["import { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { LoaderTree } from '../lib/app-dir-module'\n\nexport function parseLoaderTree(tree: LoaderTree) {\n  const [segment, parallelRoutes, modules] = tree\n  const { layout } = modules\n  let { page } = modules\n  // a __DEFAULT__ segment means that this route didn't match any of the\n  // segments in the route, so we should use the default page\n  page = segment === DEFAULT_SEGMENT_KEY ? modules.defaultPage : page\n\n  const layoutOrPagePath = layout?.[1] || page?.[1]\n\n  return {\n    page,\n    segment,\n    modules,\n    layoutOrPagePath,\n    parallelRoutes,\n  }\n}\n"],"names":["DEFAULT_SEGMENT_KEY","parseLoaderTree","tree","segment","parallelRoutes","modules","layout","page","defaultPage","layoutOrPagePath"],"mappings":";;;AAAA,SAASA,mBAAmB,QAAQ,2BAA0B;;AAGvD,SAASC,gBAAgBC,IAAgB;IAC9C,MAAM,CAACC,SAASC,gBAAgBC,QAAQ,GAAGH;IAC3C,MAAM,EAAEI,MAAM,EAAE,GAAGD;IACnB,IAAI,EAAEE,IAAI,EAAE,GAAGF;IACf,sEAAsE;IACtE,2DAA2D;IAC3DE,OAAOJ,oLAAYH,sBAAAA,GAAsBK,QAAQG,WAAW,GAAGD;IAE/D,MAAME,mBAAmBH,CAAAA,UAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,EAAE,KAAA,CAAIC,QAAAA,OAAAA,KAAAA,IAAAA,IAAM,CAAC,EAAE;IAEjD,OAAO;QACLA;QACAJ;QACAE;QACAI;QACAL;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 9579, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-asset-query-string.ts"],"sourcesContent":["import type { AppRenderContext } from './app-render'\n\nconst isDev = process.env.NODE_ENV === 'development'\nconst isTurbopack = !!process.env.TURBOPACK\n\nexport function getAssetQueryString(\n  ctx: AppRenderContext,\n  addTimestamp: boolean\n) {\n  let qs = ''\n\n  // In development we add the request timestamp to allow react to\n  // reload assets when a new RSC response is received.\n  // Turbopack handles HMR of assets itself and react doesn't need to reload them\n  // so this approach is not needed for Turbopack.\n  const shouldAddVersion = isDev && !isTurbopack && addTimestamp\n  if (shouldAddVersion) {\n    qs += `?v=${ctx.requestTimestamp}`\n  }\n\n  if (ctx.renderOpts.deploymentId) {\n    qs += `${shouldAddVersion ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n  }\n  return qs\n}\n"],"names":["isDev","process","env","NODE_ENV","isTurbopack","TURBOPACK","getAssetQueryString","ctx","addTimestamp","qs","shouldAddVersion","requestTimestamp","renderOpts","deploymentId"],"mappings":";;;AAEA,MAAMA,QAAQC,QAAQC,GAAG,CAACC,QAAQ,gCAAK;AACvC,MAAMC,cAAc,CAAC,CAACH,QAAQC,GAAG,CAACG,SAAS;AAEpC,SAASC,oBACdC,GAAqB,EACrBC,YAAqB;IAErB,IAAIC,KAAK;IAET,gEAAgE;IAChE,qDAAqD;IACrD,+EAA+E;IAC/E,gDAAgD;IAChD,MAAMC,mBAAmBV,SAAS,CAACI,eAAeI;IAClD,IAAIE,mCAAkB;;IAEtB;IAEA,IAAIH,IAAIK,UAAU,CAACC,YAAY,EAAE;QAC/BJ,MAAM,GAAGC,mBAAmB,0DAAM,IAAI,IAAI,EAAEH,IAAIK,UAAU,CAACC,YAAY,EAAE;IAC3E;IACA,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 9605, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/render-css-resource.tsx"],"sourcesContent":["import type { CssResource } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport type { PreloadCallbacks } from './types'\n\n/**\n * Abstracts the rendering of CSS files based on whether they are inlined or not.\n * For inlined CSS, renders a <style> tag with the CSS content directly embedded.\n * For external CSS files, renders a <link> tag pointing to the CSS file.\n */\nexport function renderCssResource(\n  entryCssFiles: CssResource[],\n  ctx: AppRenderContext,\n  preloadCallbacks?: PreloadCallbacks\n) {\n  return entryCssFiles.map((entryCssFile, index) => {\n    // `Precedence` is an opt-in signal for React to handle resource\n    // loading and deduplication, etc. It's also used as the key to sort\n    // resources so they will be injected in the correct order.\n    // During HMR, it's critical to use different `precedence` values\n    // for different stylesheets, so their order will be kept.\n    // https://github.com/facebook/react/pull/25060\n    const precedence =\n      process.env.NODE_ENV === 'development'\n        ? 'next_' + entryCssFile.path\n        : 'next'\n\n    // In dev, Safari and Firefox will cache the resource during HMR:\n    // - https://github.com/vercel/next.js/issues/5860\n    // - https://bugs.webkit.org/show_bug.cgi?id=187726\n    // Because of this, we add a `?v=` query to bypass the cache during\n    // development. We need to also make sure that the number is always\n    // increasing.\n    const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(\n      entryCssFile.path\n    )}${getAssetQueryString(ctx, true)}`\n\n    if (entryCssFile.inlined && !ctx.parsedRequestHeaders.isRSCRequest) {\n      return (\n        <style\n          key={index}\n          nonce={ctx.nonce}\n          // @ts-ignore\n          precedence={precedence}\n          href={fullHref}\n        >\n          {entryCssFile.content}\n        </style>\n      )\n    }\n\n    preloadCallbacks?.push(() => {\n      ctx.componentMod.preloadStyle(\n        fullHref,\n        ctx.renderOpts.crossOrigin,\n        ctx.nonce\n      )\n    })\n\n    return (\n      <link\n        key={index}\n        rel=\"stylesheet\"\n        href={fullHref}\n        // @ts-ignore\n        precedence={precedence}\n        crossOrigin={ctx.renderOpts.crossOrigin}\n        nonce={ctx.nonce}\n      />\n    )\n  })\n}\n"],"names":["encodeURIPath","getAssetQueryString","renderCssResource","entryCssFiles","ctx","preloadCallbacks","map","entryCssFile","index","precedence","process","env","NODE_ENV","path","fullHref","assetPrefix","inlined","parsedRequestHeaders","isRSCRequest","style","nonce","href","content","push","componentMod","preloadStyle","renderOpts","crossOrigin","link","rel"],"mappings":";;;;AACA,SAASA,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,mBAAmB,QAAQ,2BAA0B;;;;AAQvD,SAASC,kBACdC,aAA4B,EAC5BC,GAAqB,EACrBC,gBAAmC;IAEnC,OAAOF,cAAcG,GAAG,CAAC,CAACC,cAAcC;QACtC,gEAAgE;QAChE,oEAAoE;QACpE,2DAA2D;QAC3D,iEAAiE;QACjE,0DAA0D;QAC1D,+CAA+C;QAC/C,MAAMC,aACJC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cACrB,UAAUL,aAAaM,IAAI,GAC3B;QAEN,iEAAiE;QACjE,kDAAkD;QAClD,mDAAmD;QACnD,mEAAmE;QACnE,mEAAmE;QACnE,cAAc;QACd,MAAMC,WAAW,GAAGV,IAAIW,WAAW,CAAC,OAAO,4LAAEf,gBAAAA,EAC3CO,aAAaM,IAAI,kNACfZ,sBAAAA,EAAoBG,KAAK,OAAO;QAEpC,IAAIG,aAAaS,OAAO,IAAI,CAACZ,IAAIa,oBAAoB,CAACC,YAAY,EAAE;YAClE,OAAA,WAAA,mLACE,MAAA,EAACC,SAAAA;gBAECC,OAAOhB,IAAIgB,KAAK;gBAChB,aAAa;gBACbX,YAAYA;gBACZY,MAAMP;0BAELP,aAAae,OAAO;eANhBd;QASX;QAEAH,oBAAAA,OAAAA,KAAAA,IAAAA,iBAAkBkB,IAAI,CAAC;YACrBnB,IAAIoB,YAAY,CAACC,YAAY,CAC3BX,UACAV,IAAIsB,UAAU,CAACC,WAAW,EAC1BvB,IAAIgB,KAAK;QAEb;QAEA,OAAA,WAAA,mLACE,MAAA,EAACQ,QAAAA;YAECC,KAAI;YACJR,MAAMP;YACN,aAAa;YACbL,YAAYA;YACZkB,aAAavB,IAAIsB,UAAU,CAACC,WAAW;YACvCP,OAAOhB,IAAIgB,KAAK;WANXZ;IASX;AACF","ignoreList":[0]}},
    {"offset": {"line": 9658, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-component-styles-and-scripts.tsx"],"sourcesContent":["import React from 'react'\nimport { interopDefault } from './interop-default'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport { renderCssResource } from './render-css-resource'\n\nexport async function createComponentStylesAndScripts({\n  filePath,\n  getComponent,\n  injectedCSS,\n  injectedJS,\n  ctx,\n}: {\n  filePath: string\n  getComponent: () => any\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  ctx: AppRenderContext\n}): Promise<[React.ComponentType<any>, React.ReactNode, React.ReactNode]> {\n  const { styles: entryCssFiles, scripts: jsHrefs } = getLinkAndScriptTags(\n    ctx.clientReferenceManifest,\n    filePath,\n    injectedCSS,\n    injectedJS\n  )\n\n  const styles = renderCssResource(entryCssFiles, ctx)\n\n  const scripts = jsHrefs\n    ? jsHrefs.map((href, index) => (\n        <script\n          src={`${ctx.assetPrefix}/_next/${encodeURIPath(\n            href\n          )}${getAssetQueryString(ctx, true)}`}\n          async={true}\n          key={`script-${index}`}\n        />\n      ))\n    : null\n\n  const Comp = interopDefault(await getComponent())\n\n  return [Comp, styles, scripts]\n}\n"],"names":["React","interopDefault","getLinkAndScriptTags","getAssetQueryString","encodeURIPath","renderCssResource","createComponentStylesAndScripts","filePath","getComponent","injectedCSS","injectedJS","ctx","styles","entryCssFiles","scripts","jsHrefs","clientReferenceManifest","map","href","index","script","src","assetPrefix","async","Comp"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,cAAc,QAAQ,oBAAmB;AAClD,SAASC,oBAAoB,QAAQ,8BAA6B;AAElE,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAChE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;;;AAElD,eAAeC,gCAAgC,EACpDC,QAAQ,EACRC,YAAY,EACZC,WAAW,EACXC,UAAU,EACVC,GAAG,EAOJ;IACC,MAAM,EAAEC,QAAQC,aAAa,EAAEC,SAASC,OAAO,EAAE,uNAAGb,uBAAAA,EAClDS,IAAIK,uBAAuB,EAC3BT,UACAE,aACAC;IAGF,MAAME,iNAASP,oBAAAA,EAAkBQ,eAAeF;IAEhD,MAAMG,UAAUC,UACZA,QAAQE,GAAG,CAAC,CAACC,MAAMC,QAAAA,WAAAA,mLACjB,MAAA,EAACC,UAAAA;YACCC,KAAK,GAAGV,IAAIW,WAAW,CAAC,OAAO,4LAAElB,gBAAAA,EAC/Bc,sNACEf,sBAAAA,EAAoBQ,KAAK,OAAO;YACpCY,OAAO;WACF,CAAC,OAAO,EAAEJ,OAAO,KAG1B;IAEJ,MAAMK,wMAAOvB,iBAAAA,EAAe,MAAMO;IAElC,OAAO;QAACgB;QAAMZ;QAAQE;KAAQ;AAChC","ignoreList":[0]}},
    {"offset": {"line": 9695, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/get-layer-assets.tsx"],"sourcesContent":["import React from 'react'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { PreloadCallbacks } from './types'\nimport { renderCssResource } from './render-css-resource'\n\nexport function getLayerAssets({\n  ctx,\n  layoutOrPagePath,\n  injectedCSS: injectedCSSWithCurrentLayout,\n  injectedJS: injectedJSWithCurrentLayout,\n  injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  preloadCallbacks,\n}: {\n  layoutOrPagePath: string | undefined\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n}): React.ReactNode {\n  const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath\n    ? getLinkAndScriptTags(\n        ctx.clientReferenceManifest,\n        layoutOrPagePath,\n        injectedCSSWithCurrentLayout,\n        injectedJSWithCurrentLayout,\n        true\n      )\n    : { styles: [], scripts: [] }\n\n  const preloadedFontFiles = layoutOrPagePath\n    ? getPreloadableFonts(\n        ctx.renderOpts.nextFontManifest,\n        layoutOrPagePath,\n        injectedFontPreloadTagsWithCurrentLayout\n      )\n    : null\n\n  if (preloadedFontFiles) {\n    if (preloadedFontFiles.length) {\n      for (let i = 0; i < preloadedFontFiles.length; i++) {\n        const fontFilename = preloadedFontFiles[i]\n        const ext = /\\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)![1]\n        const type = `font/${ext}`\n        const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`\n\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preloadFont(\n            href,\n            type,\n            ctx.renderOpts.crossOrigin,\n            ctx.nonce\n          )\n        })\n      }\n    } else {\n      try {\n        let url = new URL(ctx.assetPrefix)\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect(url.origin, 'anonymous', ctx.nonce)\n        })\n      } catch (error) {\n        // assetPrefix must not be a fully qualified domain name. We assume\n        // we should preconnect to same origin instead\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect('/', 'anonymous', ctx.nonce)\n        })\n      }\n    }\n  }\n\n  const styles = renderCssResource(styleTags, ctx, preloadCallbacks)\n\n  const scripts = scriptTags\n    ? scriptTags.map((href, index) => {\n        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(\n          href\n        )}${getAssetQueryString(ctx, true)}`\n\n        return (\n          <script\n            src={fullSrc}\n            async={true}\n            key={`script-${index}`}\n            nonce={ctx.nonce}\n          />\n        )\n      })\n    : []\n\n  return styles.length || scripts.length ? [...styles, ...scripts] : null\n}\n"],"names":["React","getLinkAndScriptTags","getPreloadableFonts","getAssetQueryString","encodeURIPath","renderCssResource","getLayerAssets","ctx","layoutOrPagePath","injectedCSS","injectedCSSWithCurrentLayout","injectedJS","injectedJSWithCurrentLayout","injectedFontPreloadTags","injectedFontPreloadTagsWithCurrentLayout","preloadCallbacks","styles","styleTags","scripts","scriptTags","clientReferenceManifest","preloadedFontFiles","renderOpts","nextFontManifest","length","i","fontFilename","ext","exec","type","href","assetPrefix","push","componentMod","preloadFont","crossOrigin","nonce","url","URL","preconnect","origin","error","map","index","fullSrc","script","src","async"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,oBAAoB,QAAQ,8BAA6B;AAClE,SAASC,mBAAmB,QAAQ,0BAAyB;AAE7D,SAASC,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,aAAa,QAAQ,mCAAkC;AAEhE,SAASC,iBAAiB,QAAQ,wBAAuB;;;;;;;;AAElD,SAASC,eAAe,EAC7BC,GAAG,EACHC,gBAAgB,EAChBC,aAAaC,4BAA4B,EACzCC,YAAYC,2BAA2B,EACvCC,yBAAyBC,wCAAwC,EACjEC,gBAAgB,EAQjB;IACC,MAAM,EAAEC,QAAQC,SAAS,EAAEC,SAASC,UAAU,EAAE,GAAGX,uOAC/CP,uBAAAA,EACEM,IAAIa,uBAAuB,EAC3BZ,kBACAE,8BACAE,6BACA,QAEF;QAAEI,QAAQ,EAAE;QAAEE,SAAS,EAAE;IAAC;IAE9B,MAAMG,qBAAqBb,6NACvBN,sBAAAA,EACEK,IAAIe,UAAU,CAACC,gBAAgB,EAC/Bf,kBACAM,4CAEF;IAEJ,IAAIO,oBAAoB;QACtB,IAAIA,mBAAmBG,MAAM,EAAE;YAC7B,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,mBAAmBG,MAAM,EAAEC,IAAK;gBAClD,MAAMC,eAAeL,kBAAkB,CAACI,EAAE;gBAC1C,MAAME,MAAM,8BAA8BC,IAAI,CAACF,aAAc,CAAC,EAAE;gBAChE,MAAMG,OAAO,CAAC,KAAK,EAAEF,KAAK;gBAC1B,MAAMG,OAAO,GAAGvB,IAAIwB,WAAW,CAAC,OAAO,4LAAE3B,gBAAAA,EAAcsB,eAAe;gBAEtEX,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACC,WAAW,CAC1BJ,MACAD,MACAtB,IAAIe,UAAU,CAACa,WAAW,EAC1B5B,IAAI6B,KAAK;gBAEb;YACF;QACF,OAAO;YACL,IAAI;gBACF,IAAIC,MAAM,IAAIC,IAAI/B,IAAIwB,WAAW;gBACjChB,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACM,UAAU,CAACF,IAAIG,MAAM,EAAE,aAAajC,IAAI6B,KAAK;gBAChE;YACF,EAAE,OAAOK,OAAO;gBACd,mEAAmE;gBACnE,8CAA8C;gBAC9C1B,iBAAiBiB,IAAI,CAAC;oBACpBzB,IAAI0B,YAAY,CAACM,UAAU,CAAC,KAAK,aAAahC,IAAI6B,KAAK;gBACzD;YACF;QACF;IACF;IAEA,MAAMpB,iNAASX,oBAAAA,EAAkBY,WAAWV,KAAKQ;IAEjD,MAAMG,UAAUC,aACZA,WAAWuB,GAAG,CAAC,CAACZ,MAAMa;QACpB,MAAMC,UAAU,GAAGrC,IAAIwB,WAAW,CAAC,OAAO,GAAE3B,yMAAAA,EAC1C0B,sNACE3B,sBAAAA,EAAoBI,KAAK,OAAO;QAEpC,OAAA,WAAA,mLACE,MAAA,EAACsC,UAAAA;YACCC,KAAKF;YACLG,OAAO;YAEPX,OAAO7B,IAAI6B,KAAK;WADX,CAAC,OAAO,EAAEO,OAAO;IAI5B,KACA,EAAE;IAEN,OAAO3B,OAAOQ,MAAM,IAAIN,QAAQM,MAAM,GAAG;WAAIR;WAAWE;KAAQ,GAAG;AACrE","ignoreList":[0]}},
    {"offset": {"line": 9764, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type { CacheNodeSeedData, PreloadCallbacks } from './types'\nimport React from 'react'\nimport {\n  isClientReference,\n  isUseCacheFunction,\n} from '../../lib/client-and-server-references'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { AppRenderContext, GetDynamicParamFromSegment } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { Params } from '../request/params'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { OUTLET_BOUNDARY_NAME } from '../../lib/metadata/metadata-constants'\nimport type { UseCachePageComponentProps } from '../use-cache/use-cache-wrapper'\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadata: React.ComponentType | null\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<CacheNodeSeedData> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props)\n  )\n}\n\nfunction errorMissingDefaultExport(\n  pagePath: string,\n  convention: string\n): never {\n  const normalizedPagePath = pagePath === '/' ? '' : pagePath\n  throw new Error(\n    `The default export is not a React Component in \"${normalizedPagePath}/${convention}\"`\n  )\n}\n\nconst cacheNodeKey = 'c'\n\nasync function createComponentTreeInternal({\n  loaderTree: tree,\n  parentParams,\n  rootLayoutIncluded,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  missingSlots,\n  preloadCallbacks,\n  authInterrupts,\n  StreamingMetadata,\n  StreamingMetadataOutlet,\n}: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getViewportReady: () => Promise<void>\n  getMetadataReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadata: React.ComponentType | null\n  StreamingMetadataOutlet: React.ComponentType | null\n}): Promise<CacheNodeSeedData> {\n  const {\n    renderOpts: { nextConfigOutput, experimental },\n    workStore,\n    componentMod: {\n      HTTPAccessFallbackBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      OutletBoundary,\n      ClientPageRoot,\n      ClientSegmentRoot,\n      createServerSearchParamsForServerPage,\n      createPrerenderSearchParamsForClientPage,\n      createServerParamsForServerSegment,\n      createPrerenderParamsForClientSegment,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, layoutOrPagePath, segment, modules, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const {\n    layout,\n    template,\n    error,\n    loading,\n    'not-found': notFound,\n    forbidden,\n    unauthorized,\n  } = modules\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    preloadCallbacks,\n    ctx,\n    layoutOrPagePath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [React.Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const { mod: layoutOrPageMod, modType } = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Forbidden, forbiddenStyles] =\n    authInterrupts && forbidden\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: forbidden[1],\n          getComponent: forbidden[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  const [Unauthorized, unauthorizedStyles] =\n    authInterrupts && unauthorized\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: unauthorized[1],\n          getComponent: unauthorized[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      workStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      workStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (workStore.isStaticGeneration && !experimental.isRoutePPREnabled) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        workStore.dynamicUsageDescription = err.message\n        workStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      workStore.dynamicShouldError = false\n      workStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    workStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, workStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    const defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    if (workUnitStore) {\n      if (\n        workUnitStore.type === 'prerender' ||\n        workUnitStore.type === 'prerender-legacy' ||\n        workUnitStore.type === 'prerender-ppr' ||\n        workUnitStore.type === 'cache'\n      ) {\n        if (workUnitStore.revalidate > defaultRevalidate) {\n          workUnitStore.revalidate = defaultRevalidate\n        }\n      }\n    }\n\n    if (\n      !workStore.forceStatic &&\n      workStore.isStaticGeneration &&\n      defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !experimental.isRoutePPREnabled\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      workStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  const isStaticGeneration = workStore.isStaticGeneration\n\n  // Assume the segment we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // It's OK for this to be `true` when the data is actually fully static, but\n  // it's not OK for this to be `false` when the data possibly contains holes.\n  // Although the value here is overly pessimistic, for prefetches, it will be\n  // replaced by a more specific value when the data is later processed into\n  // per-segment responses (see collect-segment-data.tsx)\n  //\n  // For dynamic requests, this must always be `false` because dynamic responses\n  // are never partial.\n  const isPossiblyPartialResponse =\n    isStaticGeneration && experimental.isRoutePPREnabled === true\n\n  // If there's a dynamic usage error attached to the store, throw it.\n  if (workStore.dynamicUsageErr) {\n    throw workStore.dynamicUsageErr\n  }\n\n  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let MaybeComponent = LayoutOrPage\n\n  if (process.env.NODE_ENV === 'development') {\n    const { isValidElementType } = require('next/dist/compiled/react-is')\n    if (\n      typeof MaybeComponent !== 'undefined' &&\n      !isValidElementType(MaybeComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, modType ?? 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n\n    if (typeof Forbidden !== 'undefined' && !isValidElementType(Forbidden)) {\n      errorMissingDefaultExport(pagePath, 'forbidden')\n    }\n\n    if (\n      typeof Unauthorized !== 'undefined' &&\n      !isValidElementType(Unauthorized)\n    ) {\n      errorMissingDefaultExport(pagePath, 'unauthorized')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  // Create object holding the parent params and current params\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  // Resolve the segment param\n  const actualSegment = segmentParam ? segmentParam.treeSegment : segment\n  const metadata = StreamingMetadata ? <StreamingMetadata /> : undefined\n\n  // Use the same condition to render metadataOutlet as metadata\n  const metadataOutlet = StreamingMetadataOutlet ? (\n    <StreamingMetadataOutlet />\n  ) : undefined\n\n  const notFoundElement = NotFound ? (\n    <>\n      <NotFound />\n      {notFoundStyles}\n    </>\n  ) : undefined\n\n  const forbiddenElement = Forbidden ? (\n    <>\n      <Forbidden />\n      {forbiddenStyles}\n    </>\n  ) : undefined\n\n  const unauthorizedElement = Unauthorized ? (\n    <>\n      <Unauthorized />\n      {unauthorizedStyles}\n    </>\n  ) : undefined\n\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent = isChildrenRouteKey\n          ? notFoundElement\n          : undefined\n\n        const forbiddenComponent = isChildrenRouteKey\n          ? forbiddenElement\n          : undefined\n\n        const unauthorizedComponent = isChildrenRouteKey\n          ? unauthorizedElement\n          : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is deferred until the actual navigation.\n          // It does not take into account whether the data is dynamic  even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different  loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.layoutOrPagePath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const seedData = await createComponentTreeInternal({\n            loaderTree: parallelRoute,\n            parentParams: currentParams,\n            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n            injectedCSS: injectedCSSWithCurrentLayout,\n            injectedJS: injectedJSWithCurrentLayout,\n            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n            // `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            getMetadataReady: isChildrenRouteKey\n              ? getMetadataReady\n              : () => Promise.resolve(),\n            getViewportReady: isChildrenRouteKey\n              ? getViewportReady\n              : () => Promise.resolve(),\n            ctx,\n            missingSlots,\n            preloadCallbacks,\n            authInterrupts,\n            StreamingMetadata: isChildrenRouteKey ? StreamingMetadata : null,\n            // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            StreamingMetadataOutlet: isChildrenRouteKey\n              ? StreamingMetadataOutlet\n              : null,\n          })\n\n          childCacheNodeSeedData = seedData\n        }\n\n        // This is turned back into an object below.\n        return [\n          parallelRouteKey,\n          <LayoutRouter\n            parallelRouterKey={parallelRouteKey}\n            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n            error={ErrorComponent}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n            template={\n              <Template>\n                <RenderFromTemplateContext />\n              </Template>\n            }\n            templateStyles={templateStyles}\n            templateScripts={templateScripts}\n            notFound={notFoundComponent}\n            forbidden={forbiddenComponent}\n            unauthorized={unauthorizedComponent}\n          />,\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  const loadingData: LoadingModuleData = Loading\n    ? [<Loading key=\"l\" />, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!MaybeComponent) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {layerAssets}\n        {parallelRouteProps.children}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n\n  const Component = MaybeComponent\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    workStore.isStaticGeneration &&\n    workStore.forceDynamic &&\n    experimental.isRoutePPREnabled\n  ) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        <Postpone\n          reason='dynamic = \"force-dynamic\" was used'\n          route={workStore.route}\n        />\n        {layerAssets}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      true,\n    ]\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n\n  if (isPage) {\n    const PageComponent = Component\n    // Assign searchParams to props if this is a page\n    let pageElement: React.ReactNode\n    if (isClientComponent) {\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n        const promiseOfSearchParams =\n          createPrerenderSearchParamsForClientPage(workStore)\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n            promises={[promiseOfSearchParams, promiseOfParams]}\n          />\n        )\n      } else {\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n          />\n        )\n      }\n    } else {\n      // If we are passing params to a server component Page we need to track\n      // their usage in case the current render mode tracks dynamic API usage.\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      // TODO(useCache): Should we use this trick also if dynamicIO is enabled,\n      // instead of relying on the searchParams being a hanging promise?\n      if (!experimental.dynamicIO && isUseCacheFunction(PageComponent)) {\n        const UseCachePageComponent: React.ComponentType<UseCachePageComponentProps> =\n          PageComponent\n\n        // The \"use cache\" wrapper takes care of converting this into an\n        // erroring search params promise when passing it to the original\n        // function.\n        const searchParams = Promise.resolve({})\n\n        pageElement = (\n          <UseCachePageComponent\n            params={params}\n            searchParams={searchParams}\n            $$isPageComponent\n          />\n        )\n      } else {\n        // If we are passing searchParams to a server component Page we need to\n        // track their usage in case the current render mode tracks dynamic API\n        // usage.\n        const searchParams = createServerSearchParamsForServerPage(\n          query,\n          workStore\n        )\n\n        pageElement = (\n          <PageComponent params={params} searchParams={searchParams} />\n        )\n      }\n    }\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {pageElement}\n        {/*\n         * The order here matters since a parent might call findDOMNode().\n         * findDOMNode() will return the first child if multiple children are rendered.\n         * But React will hoist metadata into <head> which breaks scroll handling.\n         */}\n        {metadata}\n        {layerAssets}\n        <OutletBoundary>\n          <MetadataOutlet ready={getViewportReady} />\n          {/* Blocking metadata outlet */}\n          <MetadataOutlet ready={getMetadataReady} />\n          {/* Streaming metadata outlet */}\n          {metadataOutlet}\n        </OutletBoundary>\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  } else {\n    const SegmentComponent = Component\n\n    const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot =\n      rootLayoutAtThisLevel &&\n      'children' in parallelRoutes &&\n      Object.keys(parallelRoutes).length > 1\n\n    let segmentNode: React.ReactNode\n\n    if (isClientComponent) {\n      let clientSegment: React.ReactNode\n\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n            promise={promiseOfParams}\n          />\n        )\n      } else {\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n          />\n        )\n      }\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        let notfoundClientSegment: React.ReactNode\n        let forbiddenClientSegment: React.ReactNode\n        let unauthorizedClientSegment: React.ReactNode\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: NotFound,\n          errorElement: notFoundElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Forbidden,\n          errorElement: forbiddenElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Unauthorized,\n          errorElement: unauthorizedElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        if (\n          notfoundClientSegment ||\n          forbiddenClientSegment ||\n          unauthorizedClientSegment\n        ) {\n          segmentNode = (\n            <HTTPAccessFallbackBoundary\n              key={cacheNodeKey}\n              notFound={notfoundClientSegment}\n              forbidden={forbiddenClientSegment}\n              unauthorized={unauthorizedClientSegment}\n            >\n              {layerAssets}\n              {clientSegment}\n            </HTTPAccessFallbackBoundary>\n          )\n        } else {\n          segmentNode = (\n            <React.Fragment key={cacheNodeKey}>\n              {layerAssets}\n              {clientSegment}\n            </React.Fragment>\n          )\n        }\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {clientSegment}\n          </React.Fragment>\n        )\n      }\n    } else {\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      let serverSegment = (\n        <SegmentComponent {...parallelRouteProps} params={params} />\n      )\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        segmentNode = (\n          <HTTPAccessFallbackBoundary\n            key={cacheNodeKey}\n            notFound={\n              NotFound ? (\n                <>\n                  {layerAssets}\n                  <SegmentComponent params={params}>\n                    {notFoundStyles}\n                    <NotFound />\n                  </SegmentComponent>\n                </>\n              ) : undefined\n            }\n          >\n            {layerAssets}\n            {serverSegment}\n          </HTTPAccessFallbackBoundary>\n        )\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {serverSegment}\n          </React.Fragment>\n        )\n      }\n    }\n    // For layouts we just render the component\n    return [\n      actualSegment,\n      segmentNode,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n}\n\nasync function MetadataOutlet({\n  ready,\n}: {\n  ready: () => Promise<void> & { status?: string; value?: unknown }\n}) {\n  const r = ready()\n  // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n  if (r.status === 'rejected') {\n    throw r.value\n  } else if (r.status !== 'fulfilled') {\n    await r\n  }\n  return null\n}\nMetadataOutlet.displayName = OUTLET_BOUNDARY_NAME\n\nfunction createErrorBoundaryClientSegmentRoot({\n  ErrorBoundaryComponent,\n  errorElement,\n  ClientSegmentRoot,\n  layerAssets,\n  SegmentComponent,\n  currentParams,\n}: {\n  ErrorBoundaryComponent: React.ComponentType<any> | undefined\n  errorElement: React.ReactNode\n  ClientSegmentRoot: React.ComponentType<any>\n  layerAssets: React.ReactNode\n  SegmentComponent: React.ComponentType<any>\n  currentParams: Params\n}) {\n  if (ErrorBoundaryComponent) {\n    const notFoundParallelRouteProps = {\n      children: errorElement,\n    }\n    return (\n      <>\n        {layerAssets}\n        <ClientSegmentRoot\n          Component={SegmentComponent}\n          slots={notFoundParallelRouteProps}\n          params={currentParams}\n        />\n      </>\n    )\n  }\n  return null\n}\n\nexport function getRootParams(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment)\n}\n\nfunction getRootParamsImpl(\n  parentParams: Params,\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  const {\n    segment,\n    modules: { layout },\n    parallelRoutes,\n  } = parseLoaderTree(loaderTree)\n\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const isRootLayout = typeof layout !== 'undefined'\n\n  if (isRootLayout) {\n    return currentParams\n  } else if (!parallelRoutes.children) {\n    // This should really be an error but there are bugs in Turbopack that cause\n    // the _not-found LoaderTree to not have any layouts. For rootParams sake\n    // this is somewhat irrelevant when you are not customizing the 404 page.\n    // If you are customizing 404\n    // TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined\n    return currentParams\n  } else {\n    return getRootParamsImpl(\n      currentParams,\n      // We stop looking for root params as soon as we hit the first layout\n      // and it is not possible to use parallel route children above the root layout\n      // so every parallelRoutes object that this function can visit will necessarily\n      // have a single `children` prop and no others.\n      parallelRoutes.children,\n      getDynamicParamFromSegment\n    )\n  }\n}\n"],"names":["React","isClientReference","isUseCacheFunction","getLayoutOrPageModule","interopDefault","parseLoaderTree","createComponentStylesAndScripts","getLayerAssets","hasLoadingComponentInTree","validateRevalidate","PARALLEL_ROUTE_DEFAULT_PATH","getTracer","NextNodeServerSpan","StaticGenBailoutError","workUnitAsyncStorage","OUTLET_BOUNDARY_NAME","createComponentTree","props","trace","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","normalizedPagePath","Error","cacheNodeKey","loaderTree","tree","parentParams","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","getViewportReady","getMetadataReady","ctx","missingSlots","preloadCallbacks","authInterrupts","StreamingMetadata","StreamingMetadataOutlet","renderOpts","nextConfigOutput","experimental","workStore","componentMod","HTTPAccessFallbackBoundary","LayoutRouter","RenderFromTemplateContext","OutletBoundary","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createPrerenderParamsForClientSegment","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","layoutOrPagePath","segment","modules","parallelRoutes","layout","template","error","loading","notFound","forbidden","unauthorized","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","Template","templateStyles","templateScripts","filePath","getComponent","Fragment","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","mod","layoutOrPageMod","modType","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","Forbidden","forbiddenStyles","Unauthorized","unauthorizedStyles","dynamic","dynamicShouldError","forceDynamic","isStaticGeneration","isRoutePPREnabled","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","route","defaultRevalidate","workUnitStore","getStore","type","isPossiblyPartialResponse","dynamicUsageErr","LayoutOrPage","undefined","MaybeComponent","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","actualSegment","treeSegment","metadata","metadataOutlet","notFoundElement","forbiddenElement","unauthorizedElement","parallelRouteMap","Promise","all","Object","keys","map","parallelRouteKey","isChildrenRouteKey","parallelRoute","notFoundComponent","forbiddenComponent","unauthorizedComponent","childCacheNodeSeedData","parsedTree","endsWith","add","seedData","resolve","parallelRouterKey","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingData","children","Component","reason","isClientComponent","console","PageComponent","pageElement","promiseOfParams","promiseOfSearchParams","searchParams","params","promises","dynamicIO","UseCachePageComponent","$$isPageComponent","MetadataOutlet","ready","SegmentComponent","isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot","length","segmentNode","clientSegment","slots","promise","notfoundClientSegment","forbiddenClientSegment","unauthorizedClientSegment","createErrorBoundaryClientSegmentRoot","ErrorBoundaryComponent","errorElement","serverSegment","r","status","displayName","notFoundParallelRouteProps","getRootParams","getRootParamsImpl","isRootLayout"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10461, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/walk-tree-with-flight-router-state.tsx"],"sourcesContent":["import type {\n  FlightDataPath,\n  FlightDataSegment,\n  FlightRouterState,\n  PreloadCallbacks,\n  Segment,\n} from './types'\nimport { matchSegment } from '../../client/components/match-segments'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport type { AppRenderContext } from './app-render'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  addSearchParamsIfPageSegment,\n} from '../../shared/lib/segment'\nimport { createComponentTree } from './create-component-tree'\nimport type { HeadData } from '../../shared/lib/app-router-context.shared-runtime'\nimport { getSegmentParam } from './get-segment-param'\n\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */\nexport async function walkTreeWithFlightRouterState({\n  loaderTreeToFilter,\n  parentParams,\n  flightRouterState,\n  parentIsInsideSharedLayout,\n  rscHead,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  rootLayoutIncluded,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  preloadCallbacks,\n  StreamingMetadataOutlet,\n}: {\n  loaderTreeToFilter: LoaderTree\n  parentParams: { [key: string]: string | string[] }\n  flightRouterState?: FlightRouterState\n  rscHead: HeadData\n  parentIsInsideSharedLayout?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  rootLayoutIncluded: boolean\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<FlightDataPath[]> {\n  const {\n    renderOpts: { nextFontManifest, experimental },\n    query,\n    isPrefetch,\n    getDynamicParamFromSegment,\n    parsedRequestHeaders,\n  } = ctx\n\n  const [segment, parallelRoutes, modules] = loaderTreeToFilter\n\n  const parallelRoutesKeys = Object.keys(parallelRoutes)\n\n  const { layout } = modules\n  const isLayout = typeof layout !== 'undefined'\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n  const segmentParam = getDynamicParamFromSegment(segment)\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : parentParams\n  const actualSegment: Segment = addSearchParamsIfPageSegment(\n    segmentParam ? segmentParam.treeSegment : segment,\n    query\n  )\n\n  /**\n   * Decide if the current segment is where rendering has to start.\n   */\n  const renderComponentsOnThisLevel =\n    // No further router state available\n    !flightRouterState ||\n    // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) ||\n    // Last item in the tree\n    parallelRoutesKeys.length === 0 ||\n    // Explicit refresh\n    flightRouterState[3] === 'refetch'\n\n  // Pre-PPR, the `loading` component signals to the router how deep to render the component tree\n  // to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,\n  // the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`\n  // somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.\n\n  // Check if we're inside the \"new\" part of the navigation  inside the\n  // shared layout. In the case of a prefetch, this can be true even if the\n  // segment matches, because the client might send a matching segment to\n  // indicate that it already has the data in its cache. But in order to find\n  // the correct loading boundary, we still need to track where the shared\n  // layout begins.\n  //\n  // TODO: We should rethink the protocol for dynamic requests. It might not\n  // make sense for the client to send a FlightRouterState, since that type is\n  // overloaded with other concerns.\n  const isInsideSharedLayout =\n    renderComponentsOnThisLevel ||\n    parentIsInsideSharedLayout ||\n    flightRouterState[3] === 'inside-shared-layout'\n\n  if (\n    isInsideSharedLayout &&\n    !experimental.isRoutePPREnabled &&\n    // If PPR is disabled, and this is a request for the route tree, then we\n    // never render any components. Only send the router state.\n    (parsedRequestHeaders.isRouteTreePrefetchRequest ||\n      // Otherwise, check for the presence of a `loading` component.\n      (isPrefetch &&\n        !Boolean(modules.loading) &&\n        !hasLoadingComponentInTree(loaderTreeToFilter)))\n  ) {\n    // Send only the router state.\n    // TODO: Even for a dynamic route, we should cache these responses,\n    // because they do not contain any render data (neither segment data nor\n    // the head). They can be made even more cacheable once we move the route\n    // params into a separate data structure.\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        null,\n        [null, null],\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  if (renderComponentsOnThisLevel) {\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    // Create component tree using the slice of the loaderTree\n    const seedData = await createComponentTree(\n      // This ensures flightRouterPath is valid and filters down the tree\n      {\n        ctx,\n        loaderTree: loaderTreeToFilter,\n        parentParams: currentParams,\n        injectedCSS,\n        injectedJS,\n        injectedFontPreloadTags,\n        // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n        rootLayoutIncluded,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        authInterrupts: experimental.authInterrupts,\n        StreamingMetadata: null,\n        StreamingMetadataOutlet,\n      }\n    )\n\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        seedData,\n        rscHead,\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  // If we are not rendering on this level we need to check if the current\n  // segment has a layout. If so, we need to track all the used CSS to make\n  // the result consistent.\n  const layoutPath = layout?.[1]\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n  if (layoutPath) {\n    getLinkAndScriptTags(\n      ctx.clientReferenceManifest,\n      layoutPath,\n      injectedCSSWithCurrentLayout,\n      injectedJSWithCurrentLayout,\n      true\n    )\n    getPreloadableFonts(\n      nextFontManifest,\n      layoutPath,\n      injectedFontPreloadTagsWithCurrentLayout\n    )\n  }\n\n  const paths: FlightDataPath[] = []\n\n  // Walk through all parallel routes.\n  for (const parallelRouteKey of parallelRoutesKeys) {\n    const parallelRoute = parallelRoutes[parallelRouteKey]\n\n    const subPaths = await walkTreeWithFlightRouterState({\n      ctx,\n      loaderTreeToFilter: parallelRoute,\n      parentParams: currentParams,\n      flightRouterState:\n        flightRouterState && flightRouterState[1][parallelRouteKey],\n      parentIsInsideSharedLayout: isInsideSharedLayout,\n      rscHead,\n      injectedCSS: injectedCSSWithCurrentLayout,\n      injectedJS: injectedJSWithCurrentLayout,\n      injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n      rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n      getViewportReady,\n      getMetadataReady,\n      preloadCallbacks,\n      StreamingMetadataOutlet,\n    })\n\n    for (const subPath of subPaths) {\n      // we don't need to send over default routes in the flight data\n      // because they are always ignored by the client, unless it's a refetch\n      if (\n        subPath[0] === DEFAULT_SEGMENT_KEY &&\n        flightRouterState &&\n        !!flightRouterState[1][parallelRouteKey][0] &&\n        flightRouterState[1][parallelRouteKey][3] !== 'refetch'\n      ) {\n        continue\n      }\n\n      paths.push([actualSegment, parallelRouteKey, ...subPath])\n    }\n  }\n\n  return paths\n}\n\n/*\n * This function is used to determine if an existing segment can be overridden\n * by the incoming segment.\n */\nconst canSegmentBeOverridden = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n    return false\n  }\n\n  return getSegmentParam(existingSegment)?.param === segment[0]\n}\n"],"names":["matchSegment","getLinkAndScriptTags","getPreloadableFonts","createFlightRouterStateFromLoaderTree","hasLoadingComponentInTree","DEFAULT_SEGMENT_KEY","addSearchParamsIfPageSegment","createComponentTree","getSegmentParam","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","flightRouterState","parentIsInsideSharedLayout","rscHead","injectedCSS","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","getViewportReady","getMetadataReady","ctx","preloadCallbacks","StreamingMetadataOutlet","renderOpts","nextFontManifest","experimental","query","isPrefetch","getDynamicParamFromSegment","parsedRequestHeaders","segment","parallelRoutes","modules","parallelRoutesKeys","Object","keys","layout","isLayout","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","segmentParam","currentParams","value","param","actualSegment","treeSegment","renderComponentsOnThisLevel","length","isInsideSharedLayout","isRoutePPREnabled","isRouteTreePrefetchRequest","Boolean","loading","overriddenSegment","canSegmentBeOverridden","routerState","seedData","loaderTree","authInterrupts","StreamingMetadata","layoutPath","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","clientReferenceManifest","paths","parallelRouteKey","parallelRoute","subPaths","subPath","push","existingSegment","Array","isArray"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10642, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/encryption-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n"],"names":["InvariantError","normalizeAppPath","workAsyncStorage","__next_loaded_action_key","arrayBufferToString","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","stringToUint8Array","length","arr","charCodeAt","encrypt","key","iv","data","crypto","subtle","name","decrypt","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","setReferenceManifestsSingleton","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","getServerModuleMap","serverActionsManifestSingleton","getClientReferenceManifestForRsc","workStore","getStore","mergeClientReferenceManifests","route","getActionEncryptionKey","rawKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10812, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/postponed-state.ts"],"sourcesContent":["import type { FallbackRouteParams } from '../../server/request/fallback-params'\nimport type { Params } from '../request/params'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport enum DynamicState {\n  /**\n   * The dynamic access occurred during the RSC render phase.\n   */\n  DATA = 1,\n\n  /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */\n  HTML = 2,\n}\n\n/**\n * The postponed state for dynamic data.\n */\nexport type DynamicDataPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.DATA\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\n/**\n * The postponed state for dynamic HTML.\n */\nexport type DynamicHTMLPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.HTML\n\n  /**\n   * The postponed data used by React.\n   */\n  readonly data: object\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport async function getDynamicHTMLPostponedState(\n  data: object,\n  fallbackRouteParams: FallbackRouteParams | null,\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n    const postponedString = JSON.stringify(data)\n\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(\n      createRenderResumeDataCache(prerenderResumeDataCache)\n    )}`\n  }\n\n  const replacements: Array<[string, string]> = Array.from(fallbackRouteParams)\n  const replacementsString = JSON.stringify(replacements)\n  const dataString = JSON.stringify(data)\n\n  // Serialized as `<replacements.length><replacements><data>`\n  const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n\n  // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n  return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(prerenderResumeDataCache)}`\n}\n\nexport async function getDynamicDataPostponedState(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(prerenderResumeDataCache))}`\n}\n\nexport function parsePostponedState(\n  state: string,\n  params: Params | undefined\n): PostponedState {\n  try {\n    const postponedStringLengthMatch = state.match(/^([0-9]*):/)?.[1]\n    if (!postponedStringLengthMatch) {\n      throw new Error(`Invariant: invalid postponed state ${state}`)\n    }\n\n    const postponedStringLength = parseInt(postponedStringLengthMatch)\n\n    // We add a `:` to the end of the length as the first character of the\n    // postponed string is the length of the replacement entries.\n    const postponedString = state.slice(\n      postponedStringLengthMatch.length + 1,\n      postponedStringLengthMatch.length + postponedStringLength + 1\n    )\n\n    const renderResumeDataCache = createRenderResumeDataCache(\n      state.slice(postponedStringLengthMatch.length + postponedStringLength + 1)\n    )\n\n    try {\n      if (postponedString === 'null') {\n        return { type: DynamicState.DATA, renderResumeDataCache }\n      }\n\n      if (/^[0-9]/.test(postponedString)) {\n        const match = postponedString.match(/^([0-9]*)/)?.[1]\n        if (!match) {\n          throw new Error(\n            `Invariant: invalid postponed state ${JSON.stringify(postponedString)}`\n          )\n        }\n\n        // This is the length of the replacements entries.\n        const length = parseInt(match)\n        const replacements = JSON.parse(\n          postponedString.slice(\n            match.length,\n            // We then go to the end of the string.\n            match.length + length\n          )\n        ) as ReadonlyArray<[string, string]>\n\n        let postponed = postponedString.slice(match.length + length)\n        for (const [key, searchValue] of replacements) {\n          const value = params?.[key] ?? ''\n          const replaceValue = Array.isArray(value) ? value.join('/') : value\n          postponed = postponed.replaceAll(searchValue, replaceValue)\n        }\n\n        return {\n          type: DynamicState.HTML,\n          data: JSON.parse(postponed),\n          renderResumeDataCache,\n        }\n      }\n\n      return {\n        type: DynamicState.HTML,\n        data: JSON.parse(postponedString),\n        renderResumeDataCache,\n      }\n    } catch (err) {\n      console.error('Failed to parse postponed state', err)\n      return { type: DynamicState.DATA, renderResumeDataCache }\n    }\n  } catch (err) {\n    console.error('Failed to parse postponed state', err)\n    return {\n      type: DynamicState.DATA,\n      renderResumeDataCache: createPrerenderResumeDataCache(),\n    }\n  }\n}\n\nexport function getPostponedFromState(state: PostponedState): any {\n  if (state.type === DynamicState.DATA) {\n    return null\n  }\n\n  return state.data\n}\n"],"names":["createPrerenderResumeDataCache","createRenderResumeDataCache","stringifyResumeDataCache","DynamicState","getDynamicHTMLPostponedState","data","fallbackRouteParams","prerenderResumeDataCache","size","postponedString","JSON","stringify","length","replacements","Array","from","replacementsString","dataString","getDynamicDataPostponedState","parsePostponedState","state","params","postponedStringLengthMatch","match","Error","postponedStringLength","parseInt","slice","renderResumeDataCache","type","test","parse","postponed","key","searchValue","value","replaceValue","isArray","join","replaceAll","err","console","error","getPostponedFromState"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10928, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/use-flight-response.tsx"],"sourcesContent":["import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { BinaryStreamOf } from './app-render'\n\nimport { htmlEscapeJsonString } from '../htmlescape'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2\nconst INLINE_FLIGHT_PAYLOAD_BINARY = 3\n\nconst flightResponses = new WeakMap<BinaryStreamOf<any>, Promise<any>>()\nconst encoder = new TextEncoder()\n\n/**\n * Render Flight stream.\n * This is only used for renderToHTML, the Flight response does not need additional wrappers.\n */\nexport function useFlightStream<T>(\n  flightStream: BinaryStreamOf<T>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  nonce?: string\n): Promise<T> {\n  const response = flightResponses.get(flightStream)\n\n  if (response) {\n    return response\n  }\n\n  // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n  let createFromReadableStream\n  // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  const newResponse = createFromReadableStream(flightStream, {\n    serverConsumerManifest: {\n      moduleLoading: clientReferenceManifest.moduleLoading,\n      moduleMap: isEdgeRuntime\n        ? clientReferenceManifest.edgeSSRModuleMapping\n        : clientReferenceManifest.ssrModuleMapping,\n      serverModuleMap: null,\n    },\n    nonce,\n  })\n\n  flightResponses.set(flightStream, newResponse)\n\n  return newResponse\n}\n\n/**\n * Creates a ReadableStream provides inline script tag chunks for writing hydration\n * data to the client outside the React render itself.\n *\n * @param flightStream The RSC render stream\n * @param nonce optionally a nonce used during this particular render\n * @param formState optionally the formState used with this particular render\n * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream\n */\nexport function createInlinedDataReadableStream(\n  flightStream: ReadableStream<Uint8Array>,\n  nonce: string | undefined,\n  formState: unknown | null\n): ReadableStream<Uint8Array> {\n  const startScriptTag = nonce\n    ? `<script nonce=${JSON.stringify(nonce)}>`\n    : '<script>'\n\n  const flightReader = flightStream.getReader()\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n\n  const readable = new ReadableStream({\n    type: 'bytes',\n    start(controller) {\n      try {\n        writeInitialInstructions(controller, startScriptTag, formState)\n      } catch (error) {\n        // during encoding or enqueueing forward the error downstream\n        controller.error(error)\n      }\n    },\n    async pull(controller) {\n      try {\n        const { done, value } = await flightReader.read()\n\n        if (value) {\n          try {\n            const decodedString = decoder.decode(value, { stream: !done })\n\n            // The chunk cannot be decoded as valid UTF-8 string as it might\n            // have arbitrary binary data.\n            writeFlightDataInstruction(\n              controller,\n              startScriptTag,\n              decodedString\n            )\n          } catch {\n            // The chunk cannot be decoded as valid UTF-8 string.\n            writeFlightDataInstruction(controller, startScriptTag, value)\n          }\n        }\n\n        if (done) {\n          controller.close()\n        }\n      } catch (error) {\n        // There was a problem in the upstream reader or during decoding or enqueuing\n        // forward the error downstream\n        controller.error(error)\n      }\n    },\n  })\n\n  return readable\n}\n\nfunction writeInitialInstructions(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  formState: unknown | null\n) {\n  if (formState != null) {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )});self.__next_f.push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_FORM_STATE, formState])\n        )})</script>`\n      )\n    )\n  } else {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )})</script>`\n      )\n    )\n  }\n}\n\nfunction writeFlightDataInstruction(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  chunk: string | Uint8Array\n) {\n  let htmlInlinedData: string\n\n  if (typeof chunk === 'string') {\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_DATA, chunk])\n    )\n  } else {\n    // The chunk cannot be embedded as a UTF-8 string in the script tag.\n    // Instead let's inline it in base64.\n    // Credits to Devon Govett (devongovett) for the technique.\n    // https://github.com/devongovett/rsc-html-stream\n    const base64 = btoa(String.fromCodePoint(...chunk))\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_BINARY, base64])\n    )\n  }\n\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}self.__next_f.push(${htmlInlinedData})</script>`\n    )\n  )\n}\n"],"names":["htmlEscapeJsonString","isEdgeRuntime","process","env","NEXT_RUNTIME","INLINE_FLIGHT_PAYLOAD_BOOTSTRAP","INLINE_FLIGHT_PAYLOAD_DATA","INLINE_FLIGHT_PAYLOAD_FORM_STATE","INLINE_FLIGHT_PAYLOAD_BINARY","flightResponses","WeakMap","encoder","TextEncoder","useFlightStream","flightStream","clientReferenceManifest","nonce","response","get","createFromReadableStream","TURBOPACK","require","newResponse","serverConsumerManifest","moduleLoading","moduleMap","edgeSSRModuleMapping","ssrModuleMapping","serverModuleMap","set","createInlinedDataReadableStream","formState","startScriptTag","JSON","stringify","flightReader","getReader","decoder","TextDecoder","fatal","readable","ReadableStream","type","start","controller","writeInitialInstructions","error","pull","done","value","read","decodedString","decode","stream","writeFlightDataInstruction","close","scriptStart","enqueue","encode","chunk","htmlInlinedData","base64","btoa","String","fromCodePoint"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11071, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render-prerender-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function prerenderAndAbortInSequentialTasks<R>(\n  prerender: () => Promise<R>,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        abort()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let result: ServerPrerenderStreamResult\n\n      signal.addEventListener(\n        'abort',\n        () => {\n          if (isPrerenderInterruptedError(signal.reason)) {\n            result.markInterrupted()\n          } else {\n            result.markComplete()\n          }\n        },\n        {\n          once: true,\n        }\n      )\n\n      setImmediate(() => {\n        try {\n          result = new ServerPrerenderStreamResult(render())\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          if (result) {\n            result.markComplete()\n            this()\n          }\n          resolve(result)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          if (result) {\n            result.markPhase()\n            this()\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\nconst PENDING = 0\nconst COMPLETE = 1\nconst INTERRUPTED = 2\nconst ERRORED = 3\n\nexport class ServerPrerenderStreamResult {\n  private currentChunks: Array<Uint8Array>\n  private chunksByPhase: Array<Array<Uint8Array>>\n  private trailingChunks: Array<Uint8Array>\n  private status: 0 | 1 | 2 | 3\n  private reason: null | unknown\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this.status = PENDING\n    this.reason = null\n\n    this.trailingChunks = []\n    this.currentChunks = []\n    this.chunksByPhase = [this.currentChunks]\n\n    const reader = stream.getReader()\n\n    const progress = ({\n      done,\n      value,\n    }: ReadableStreamReadResult<Uint8Array>) => {\n      if (done) {\n        if (this.status === PENDING) {\n          this.status = COMPLETE\n        }\n        return\n      }\n      if (this.status === PENDING || this.status === INTERRUPTED) {\n        this.currentChunks.push(value)\n      } else {\n        this.trailingChunks.push(value)\n      }\n      reader.read().then(progress, error)\n    }\n    const error = (reason: unknown) => {\n      this.status = ERRORED\n      this.reason = reason\n    }\n\n    reader.read().then(progress, error)\n  }\n\n  markPhase() {\n    this.currentChunks = []\n    this.chunksByPhase.push(this.currentChunks)\n  }\n\n  markComplete() {\n    if (this.status === PENDING) {\n      this.status = COMPLETE\n    }\n  }\n\n  markInterrupted() {\n    this.status = INTERRUPTED\n  }\n\n  /**\n   * Returns a stream which only releases chunks when `releasePhase` is called. This stream will never \"complete\" because\n   * we rely upon the stream remaining open when prerendering to avoid triggering errors for incomplete chunks in the client.\n   *\n   * asPhasedStream is expected to be called once per result however it is safe to call multiple times as long as we have not\n   * transferred the underlying data. Generally this will only happen when streaming to a response\n   */\n  asPhasedStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        return new PhasedStream(this.chunksByPhase)\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n\n  /**\n   * Returns a stream which will release all chunks immediately. This stream will \"complete\" synchronously. It should be used outside\n   * of render use cases like loading client chunks ahead of SSR or writing the streamed content to disk.\n   */\n  asStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        const chunksByPhase = this.chunksByPhase\n        const trailingChunks = this.trailingChunks\n        return new ReadableStream({\n          start(controller) {\n            for (let i = 0; i < chunksByPhase.length; i++) {\n              const chunks = chunksByPhase[i]\n              for (let j = 0; j < chunks.length; j++) {\n                controller.enqueue(chunks[j])\n              }\n            }\n            for (let i = 0; i < trailingChunks.length; i++) {\n              controller.enqueue(trailingChunks[i])\n            }\n            controller.close()\n          },\n        })\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n}\n\nclass PhasedStream<T> extends ReadableStream<T> {\n  private nextPhase: number\n  private chunksByPhase: Array<Array<T>>\n  private destination: ReadableStreamDefaultController<T>\n\n  constructor(chunksByPhase: Array<Array<T>>) {\n    if (chunksByPhase.length === 0) {\n      throw new InvariantError(\n        'PhasedStream expected at least one phase but none were found.'\n      )\n    }\n\n    let destination: ReadableStreamDefaultController<T>\n    super({\n      start(controller) {\n        destination = controller\n      },\n    })\n\n    // the start function above is called synchronously during construction so we will always have a destination\n    // We wait to assign it until after the super call because we cannot access `this` before calling super\n    this.destination = destination!\n    this.nextPhase = 0\n    this.chunksByPhase = chunksByPhase\n    this.releasePhase()\n  }\n\n  releasePhase() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      const chunks = this.chunksByPhase[this.nextPhase++]\n      for (let i = 0; i < chunks.length; i++) {\n        this.destination.enqueue(chunks[i])\n      }\n    } else {\n      throw new InvariantError(\n        'PhasedStream expected more phases to release but none were found.'\n      )\n    }\n  }\n\n  assertExhausted() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      throw new InvariantError(\n        'PhasedStream expected no more phases to release but some were found.'\n      )\n    }\n  }\n}\n\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  ...remainingPhases: Array<() => void>\n): Promise<T> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<T>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n          pendingResult.catch((err) => reject(err))\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          this()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          this()\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\n// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream\n// in one that doesn't close even when the underlying is complete.\nexport class ReactServerResult {\n  private _stream: null | ReadableStream<Uint8Array>\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this._stream = stream\n  }\n\n  tee() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot tee a ReactServerResult that has already been consumed'\n      )\n    }\n    const tee = this._stream.tee()\n    this._stream = tee[0]\n    return tee[1]\n  }\n\n  consume() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot consume a ReactServerResult that has already been consumed'\n      )\n    }\n    const stream = this._stream\n    this._stream = null\n    return stream\n  }\n}\n\nexport type ReactServerPrerenderResolveToType = {\n  prelude: ReadableStream<Uint8Array>\n}\n\nexport async function createReactServerPrerenderResult(\n  underlying: Promise<ReactServerPrerenderResolveToType>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const { prelude } = await underlying\n  const reader = prelude.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      return new ReactServerPrerenderResult(chunks)\n    } else {\n      chunks.push(value)\n    }\n  }\n}\n\nexport async function createReactServerPrerenderResultFromRender(\n  underlying: ReadableStream<Uint8Array>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const reader = underlying.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    } else {\n      chunks.push(value)\n    }\n  }\n  return new ReactServerPrerenderResult(chunks)\n}\nexport class ReactServerPrerenderResult {\n  private _chunks: null | Array<Uint8Array>\n\n  private assertChunks(expression: string): Array<Uint8Array> {\n    if (this._chunks === null) {\n      throw new InvariantError(\n        `Cannot \\`${expression}\\` on a ReactServerPrerenderResult that has already been consumed.`\n      )\n    }\n    return this._chunks\n  }\n\n  private consumeChunks(expression: string): Array<Uint8Array> {\n    const chunks = this.assertChunks(expression)\n    this.consume()\n    return chunks\n  }\n\n  consume(): void {\n    this._chunks = null\n  }\n\n  constructor(chunks: Array<Uint8Array>) {\n    this._chunks = chunks\n  }\n\n  asUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  consumeAsUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  asStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asStream()')\n    return createClosingStream(chunks)\n  }\n\n  consumeAsStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsStream()')\n    return createClosingStream(chunks)\n  }\n}\n\nfunction createUnclosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      }\n      // we intentionally keep the stream open. The consumer will clear\n      // out chunks once finished and the remaining memory will be GC'd\n      // when this object goes out of scope\n    },\n  })\n}\n\nfunction createClosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      } else {\n        controller.close()\n      }\n    },\n  })\n}\n"],"names":["InvariantError","isPrerenderInterruptedError","prerenderAndAbortInSequentialTasks","prerender","abort","process","env","NEXT_RUNTIME","Promise","resolve","reject","pendingResult","setImmediate","catch","err","prerenderServerWithPhases","signal","render","remainingPhases","result","addEventListener","reason","markInterrupted","markComplete","once","ServerPrerenderStreamResult","runFinalTask","runNextTask","markPhase","i","length","phase","bind","finalPhase","PENDING","COMPLETE","INTERRUPTED","ERRORED","constructor","stream","status","trailingChunks","currentChunks","chunksByPhase","reader","getReader","progress","done","value","push","read","then","error","asPhasedStream","PhasedStream","asStream","ReadableStream","start","controller","chunks","j","enqueue","close","destination","nextPhase","releasePhase","assertExhausted","prerenderClientWithPhases","ReactServerResult","_stream","tee","Error","consume","createReactServerPrerenderResult","underlying","prelude","ReactServerPrerenderResult","createReactServerPrerenderResultFromRender","assertChunks","expression","_chunks","consumeChunks","asUnclosingStream","createUnclosingStream","consumeAsUnclosingStream","createClosingStream","consumeAsStream","pull"],"mappings":";;;;;;;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAASC,2BAA2B,QAAQ,sBAAqB;;;AAM1D,SAASC,mCACdC,SAA2B,EAC3BC,KAAiB;IAEjB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,+EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAgBP;AACF;AAoBO,SAASe,0BACdC,MAAmB,EACnBC,MAAwC,EACxC,GAAGC,eAAkC;IAErC,IAAIb,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,+EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IA2DP;AACF;AAEA,MAAMkC,UAAU;AAChB,MAAMC,WAAW;AACjB,MAAMC,cAAc;AACpB,MAAMC,UAAU;AAET,MAAMZ;IAOXa,YAAYC,MAAkC,CAAE;QAC9C,IAAI,CAACC,MAAM,GAAGN;QACd,IAAI,CAACb,MAAM,GAAG;QAEd,IAAI,CAACoB,cAAc,GAAG,EAAE;QACxB,IAAI,CAACC,aAAa,GAAG,EAAE;QACvB,IAAI,CAACC,aAAa,GAAG;YAAC,IAAI,CAACD,aAAa;SAAC;QAEzC,MAAME,SAASL,OAAOM,SAAS;QAE/B,MAAMC,WAAW,CAAC,EAChBC,IAAI,EACJC,KAAK,EACgC;YACrC,IAAID,MAAM;gBACR,IAAI,IAAI,CAACP,MAAM,KAAKN,SAAS;oBAC3B,IAAI,CAACM,MAAM,GAAGL;gBAChB;gBACA;YACF;YACA,IAAI,IAAI,CAACK,MAAM,KAAKN,WAAW,IAAI,CAACM,MAAM,KAAKJ,aAAa;gBAC1D,IAAI,CAACM,aAAa,CAACO,IAAI,CAACD;YAC1B,OAAO;gBACL,IAAI,CAACP,cAAc,CAACQ,IAAI,CAACD;YAC3B;YACAJ,OAAOM,IAAI,GAAGC,IAAI,CAACL,UAAUM;QAC/B;QACA,MAAMA,QAAQ,CAAC/B;YACb,IAAI,CAACmB,MAAM,GAAGH;YACd,IAAI,CAAChB,MAAM,GAAGA;QAChB;QAEAuB,OAAOM,IAAI,GAAGC,IAAI,CAACL,UAAUM;IAC/B;IAEAxB,YAAY;QACV,IAAI,CAACc,aAAa,GAAG,EAAE;QACvB,IAAI,CAACC,aAAa,CAACM,IAAI,CAAC,IAAI,CAACP,aAAa;IAC5C;IAEAnB,eAAe;QACb,IAAI,IAAI,CAACiB,MAAM,KAAKN,SAAS;YAC3B,IAAI,CAACM,MAAM,GAAGL;QAChB;IACF;IAEAb,kBAAkB;QAChB,IAAI,CAACkB,MAAM,GAAGJ;IAChB;IAEA;;;;;;GAMC,GACDiB,iBAAiB;QACf,OAAQ,IAAI,CAACb,MAAM;YACjB,KAAKL;YACL,KAAKC;gBACH,OAAO,IAAIkB,aAAa,IAAI,CAACX,aAAa;YAC5C;gBACE,MAAM,OAAA,cAEL,CAFK,uLAAI3C,iBAAAA,CACR,CAAC,mGAAmG,EAAE,IAAI,CAACwC,MAAM,EAAE,GAD/G,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;QACJ;IACF;IAEA;;;GAGC,GACDe,WAAW;QACT,OAAQ,IAAI,CAACf,MAAM;YACjB,KAAKL;YACL,KAAKC;gBACH,MAAMO,gBAAgB,IAAI,CAACA,aAAa;gBACxC,MAAMF,iBAAiB,IAAI,CAACA,cAAc;gBAC1C,OAAO,IAAIe,eAAe;oBACxBC,OAAMC,UAAU;wBACd,IAAK,IAAI7B,IAAI,GAAGA,IAAIc,cAAcb,MAAM,EAAED,IAAK;4BAC7C,MAAM8B,SAAShB,aAAa,CAACd,EAAE;4BAC/B,IAAK,IAAI+B,IAAI,GAAGA,IAAID,OAAO7B,MAAM,EAAE8B,IAAK;gCACtCF,WAAWG,OAAO,CAACF,MAAM,CAACC,EAAE;4BAC9B;wBACF;wBACA,IAAK,IAAI/B,IAAI,GAAGA,IAAIY,eAAeX,MAAM,EAAED,IAAK;4BAC9C6B,WAAWG,OAAO,CAACpB,cAAc,CAACZ,EAAE;wBACtC;wBACA6B,WAAWI,KAAK;oBAClB;gBACF;YACF;gBACE,MAAM,OAAA,cAEL,CAFK,uLAAI9D,iBAAAA,CACR,CAAC,mGAAmG,EAAE,IAAI,CAACwC,MAAM,EAAE,GAD/G,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;QACJ;IACF;AACF;AAEA,MAAMc,qBAAwBE;IAK5BlB,YAAYK,aAA8B,CAAE;QAC1C,IAAIA,cAAcb,MAAM,KAAK,GAAG;YAC9B,MAAM,OAAA,cAEL,CAFK,uLAAI9B,iBAAAA,CACR,kEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,IAAI+D;QACJ,KAAK,CAAC;YACJN,OAAMC,UAAU;gBACdK,cAAcL;YAChB;QACF;QAEA,4GAA4G;QAC5G,uGAAuG;QACvG,IAAI,CAACK,WAAW,GAAGA;QACnB,IAAI,CAACC,SAAS,GAAG;QACjB,IAAI,CAACrB,aAAa,GAAGA;QACrB,IAAI,CAACsB,YAAY;IACnB;IAEAA,eAAe;QACb,IAAI,IAAI,CAACD,SAAS,GAAG,IAAI,CAACrB,aAAa,CAACb,MAAM,EAAE;YAC9C,MAAM6B,SAAS,IAAI,CAAChB,aAAa,CAAC,IAAI,CAACqB,SAAS,GAAG;YACnD,IAAK,IAAInC,IAAI,GAAGA,IAAI8B,OAAO7B,MAAM,EAAED,IAAK;gBACtC,IAAI,CAACkC,WAAW,CAACF,OAAO,CAACF,MAAM,CAAC9B,EAAE;YACpC;QACF,OAAO;YACL,MAAM,OAAA,cAEL,CAFK,uLAAI7B,iBAAAA,CACR,sEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IAEAkE,kBAAkB;QAChB,IAAI,IAAI,CAACF,SAAS,GAAG,IAAI,CAACrB,aAAa,CAACb,MAAM,EAAE;YAC9C,MAAM,OAAA,cAEL,CAFK,uLAAI9B,iBAAAA,CACR,yEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;AACF;AAiBO,SAASmE,0BACdlD,MAAwB,EACxB,GAAGC,eAAkC;IAErC,IAAIb,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,+EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAuCP;AACF;AAMO,MAAMoE;IAGX9B,YAAYC,MAAkC,CAAE;QAC9C,IAAI,CAAC8B,OAAO,GAAG9B;IACjB;IAEA+B,MAAM;QACJ,IAAI,IAAI,CAACD,OAAO,KAAK,MAAM;YACzB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,kEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,MAAMD,MAAM,IAAI,CAACD,OAAO,CAACC,GAAG;QAC5B,IAAI,CAACD,OAAO,GAAGC,GAAG,CAAC,EAAE;QACrB,OAAOA,GAAG,CAAC,EAAE;IACf;IAEAE,UAAU;QACR,IAAI,IAAI,CAACH,OAAO,KAAK,MAAM;YACzB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,sEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,MAAMhC,SAAS,IAAI,CAAC8B,OAAO;QAC3B,IAAI,CAACA,OAAO,GAAG;QACf,OAAO9B;IACT;AACF;AAMO,eAAekC,iCACpBC,UAAsD;IAEtD,MAAMf,SAA4B,EAAE;IACpC,MAAM,EAAEgB,OAAO,EAAE,GAAG,MAAMD;IAC1B,MAAM9B,SAAS+B,QAAQ9B,SAAS;IAChC,MAAO,KAAM;QACX,MAAM,EAAEE,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAMJ,OAAOM,IAAI;QACzC,IAAIH,MAAM;YACR,OAAO,IAAI6B,2BAA2BjB;QACxC,OAAO;YACLA,OAAOV,IAAI,CAACD;QACd;IACF;AACF;AAEO,eAAe6B,2CACpBH,UAAsC;IAEtC,MAAMf,SAA4B,EAAE;IACpC,MAAMf,SAAS8B,WAAW7B,SAAS;IACnC,MAAO,KAAM;QACX,MAAM,EAAEE,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAMJ,OAAOM,IAAI;QACzC,IAAIH,MAAM;YACR;QACF,OAAO;YACLY,OAAOV,IAAI,CAACD;QACd;IACF;IACA,OAAO,IAAI4B,2BAA2BjB;AACxC;AACO,MAAMiB;IAGHE,aAAaC,UAAkB,EAAqB;QAC1D,IAAI,IAAI,CAACC,OAAO,KAAK,MAAM;YACzB,MAAM,OAAA,cAEL,CAFK,uLAAIhF,iBAAAA,CACR,CAAC,SAAS,EAAE+E,WAAW,kEAAkE,CAAC,GADtF,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,OAAO,IAAI,CAACC,OAAO;IACrB;IAEQC,cAAcF,UAAkB,EAAqB;QAC3D,MAAMpB,SAAS,IAAI,CAACmB,YAAY,CAACC;QACjC,IAAI,CAACP,OAAO;QACZ,OAAOb;IACT;IAEAa,UAAgB;QACd,IAAI,CAACQ,OAAO,GAAG;IACjB;IAEA1C,YAAYqB,MAAyB,CAAE;QACrC,IAAI,CAACqB,OAAO,GAAGrB;IACjB;IAEAuB,oBAAgD;QAC9C,MAAMvB,SAAS,IAAI,CAACmB,YAAY,CAAC;QACjC,OAAOK,sBAAsBxB;IAC/B;IAEAyB,2BAAuD;QACrD,MAAMzB,SAAS,IAAI,CAACsB,aAAa,CAAC;QAClC,OAAOE,sBAAsBxB;IAC/B;IAEAJ,WAAuC;QACrC,MAAMI,SAAS,IAAI,CAACmB,YAAY,CAAC;QACjC,OAAOO,oBAAoB1B;IAC7B;IAEA2B,kBAA8C;QAC5C,MAAM3B,SAAS,IAAI,CAACsB,aAAa,CAAC;QAClC,OAAOI,oBAAoB1B;IAC7B;AACF;AAEA,SAASwB,sBACPxB,MAAyB;IAEzB,IAAI9B,IAAI;IACR,OAAO,IAAI2B,eAAe;QACxB,MAAM+B,MAAK7B,UAAU;YACnB,IAAI7B,IAAI8B,OAAO7B,MAAM,EAAE;gBACrB4B,WAAWG,OAAO,CAACF,MAAM,CAAC9B,IAAI;YAChC;QACA,iEAAiE;QACjE,iEAAiE;QACjE,qCAAqC;QACvC;IACF;AACF;AAEA,SAASwD,oBACP1B,MAAyB;IAEzB,IAAI9B,IAAI;IACR,OAAO,IAAI2B,eAAe;QACxB,MAAM+B,MAAK7B,UAAU;YACnB,IAAI7B,IAAI8B,OAAO7B,MAAM,EAAE;gBACrB4B,WAAWG,OAAO,CAACF,MAAM,CAAC9B,IAAI;YAChC,OAAO;gBACL6B,WAAWI,KAAK;YAClB;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 11386, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/prospective-render-utils.ts"],"sourcesContent":["import { getDigestForWellKnownError } from './create-error-handler'\n\nexport function printDebugThrownValueForProspectiveRender(\n  thrownValue: unknown,\n  route: string\n) {\n  // We don't need to print well-known Next.js errors.\n  if (getDigestForWellKnownError(thrownValue)) {\n    return\n  }\n\n  let message: undefined | string\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    typeof (thrownValue as any).message === 'string'\n  ) {\n    message = (thrownValue as any).message\n    if (typeof (thrownValue as any).stack === 'string') {\n      const originalErrorStack: string = (thrownValue as any).stack\n      const stackStart = originalErrorStack.indexOf('\\n')\n      if (stackStart > -1) {\n        const error = new Error(\n          `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.\n          \nOriginal Error: ${message}`\n        )\n        error.stack =\n          'Error: ' + error.message + originalErrorStack.slice(stackStart)\n        console.error(error)\n        return\n      }\n    }\n  } else if (typeof thrownValue === 'string') {\n    message = thrownValue\n  }\n\n  if (message) {\n    console.error(`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.\n          \nOriginal Message: ${message}`)\n    return\n  }\n\n  console.error(\n    `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`\n  )\n  console.error(thrownValue)\n  return\n}\n"],"names":["getDigestForWellKnownError","printDebugThrownValueForProspectiveRender","thrownValue","route","message","stack","originalErrorStack","stackStart","indexOf","error","Error","slice","console"],"mappings":";;;AAAA,SAASA,0BAA0B,QAAQ,yBAAwB;;AAE5D,SAASC,0CACdC,WAAoB,EACpBC,KAAa;IAEb,oDAAoD;IACpD,6MAAIH,6BAAAA,EAA2BE,cAAc;QAC3C;IACF;IAEA,IAAIE;IACJ,IACE,OAAOF,gBAAgB,YACvBA,gBAAgB,QAChB,OAAQA,YAAoBE,OAAO,KAAK,UACxC;QACAA,UAAWF,YAAoBE,OAAO;QACtC,IAAI,OAAQF,YAAoBG,KAAK,KAAK,UAAU;YAClD,MAAMC,qBAA8BJ,YAAoBG,KAAK;YAC7D,MAAME,aAAaD,mBAAmBE,OAAO,CAAC;YAC9C,IAAID,aAAa,CAAC,GAAG;gBACnB,MAAME,QAAQ,OAAA,cAIb,CAJa,IAAIC,MAChB,CAAC,MAAM,EAAEP,MAAM;;gBAET,EAAEC,SAAS,GAHL,qBAAA;2BAAA;gCAAA;kCAAA;gBAId;gBACAK,MAAMJ,KAAK,GACT,YAAYI,MAAML,OAAO,GAAGE,mBAAmBK,KAAK,CAACJ;gBACvDK,QAAQH,KAAK,CAACA;gBACd;YACF;QACF;IACF,OAAO,IAAI,OAAOP,gBAAgB,UAAU;QAC1CE,UAAUF;IACZ;IAEA,IAAIE,SAAS;QACXQ,QAAQH,KAAK,CAAC,CAAC,MAAM,EAAEN,MAAM;;kBAEf,EAAEC,SAAS;QACzB;IACF;IAEAQ,QAAQH,KAAK,CACX,CAAC,MAAM,EAAEN,MAAM,wOAAwO,CAAC;IAE1PS,QAAQH,KAAK,CAACP;IACd;AACF","ignoreList":[0]}},
    {"offset": {"line": 11434, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render-render-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function scheduleInSequentialTasks<R>(\n  render: () => R | Promise<R>,\n  followup: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`scheduleInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: R | Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        followup()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n"],"names":["InvariantError","scheduleInSequentialTasks","render","followup","process","env","NEXT_RUNTIME","Promise","resolve","reject","pendingResult","setImmediate","err"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;;AAM1D,SAASC,0BACdC,MAA4B,EAC5BC,QAAoB;IAEpB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIN,iBAAAA,CACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAeP;AACF","ignoreList":[0]}},
    {"offset": {"line": 11456, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the dynamicIO flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nexport class CacheSignal {\n  private count: number\n  private earlyListeners: Array<() => void>\n  private listeners: Array<() => void>\n  private tickPending: boolean\n  private taskPending: boolean\n\n  constructor() {\n    this.count = 0\n    this.earlyListeners = []\n    this.listeners = []\n    this.tickPending = false\n    this.taskPending = false\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      process.nextTick(() => {\n        this.tickPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.earlyListeners.length; i++) {\n            this.earlyListeners[i]()\n          }\n          this.earlyListeners.length = 0\n        }\n      })\n    }\n    if (!this.taskPending) {\n      this.taskPending = true\n      setTimeout(() => {\n        this.taskPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.listeners.length; i++) {\n            this.listeners[i]()\n          }\n          this.listeners.length = 0\n        }\n      }, 0)\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n  }\n\n  endRead() {\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n  }\n}\n"],"names":["CacheSignal","constructor","count","earlyListeners","listeners","tickPending","taskPending","noMorePendingCaches","process","nextTick","i","length","setTimeout","inputReady","Promise","resolve","push","cacheReady","beginRead","endRead"],"mappings":"AAAA;;;;;CAKC,GAED;;;AAAO,MAAMA;IAOXC,aAAc;QACZ,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,cAAc,GAAG,EAAE;QACxB,IAAI,CAACC,SAAS,GAAG,EAAE;QACnB,IAAI,CAACC,WAAW,GAAG;QACnB,IAAI,CAACC,WAAW,GAAG;IACrB;IAEQC,sBAAsB;QAC5B,IAAI,CAAC,IAAI,CAACF,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBG,QAAQC,QAAQ,CAAC;gBACf,IAAI,CAACJ,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACH,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACP,cAAc,CAACQ,MAAM,EAAED,IAAK;wBACnD,IAAI,CAACP,cAAc,CAACO,EAAE;oBACxB;oBACA,IAAI,CAACP,cAAc,CAACQ,MAAM,GAAG;gBAC/B;YACF;QACF;QACA,IAAI,CAAC,IAAI,CAACL,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBM,WAAW;gBACT,IAAI,CAACN,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACJ,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAED,IAAK;wBAC9C,IAAI,CAACN,SAAS,CAACM,EAAE;oBACnB;oBACA,IAAI,CAACN,SAAS,CAACO,MAAM,GAAG;gBAC1B;YACF,GAAG;QACL;IACF;IAEA;;;GAGC,GACDE,aAAa;QACX,OAAO,IAAIC,QAAc,CAACC;YACxB,IAAI,CAACZ,cAAc,CAACa,IAAI,CAACD;YACzB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEA;;;;GAIC,GACDU,aAAa;QACX,OAAO,IAAIH,QAAc,CAACC;YACxB,IAAI,CAACX,SAAS,CAACY,IAAI,CAACD;YACpB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEAW,YAAY;QACV,IAAI,CAAChB,KAAK;IACZ;IAEAiB,UAAU;QACR,4FAA4F;QAC5F,kGAAkG;QAClG,gGAAgG;QAChG,2BAA2B;QAC3B,+GAA+G;QAC/G,mHAAmH;QACnH,IAAI,CAACjB,KAAK;QACV,IAAI,IAAI,CAACA,KAAK,KAAK,GAAG;YACpB,IAAI,CAACK,mBAAmB;QAC1B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 11543, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/clean-async-snapshot-instance.ts"],"sourcesContent":["import { createSnapshot } from '../app-render/async-local-storage'\n\nexport const runInCleanSnapshot: <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R = createSnapshot()\n"],"names":["createSnapshot","runInCleanSnapshot"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,oCAAmC;;AAE3D,MAAMC,gOAGJD,iBAAAA,GAAgB","ignoreList":[0]}},
    {"offset": {"line": 11555, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/clean-async-snapshot.external.ts"],"sourcesContent":["// Share the instance module in the next-shared layer\nimport { runInCleanSnapshot } from './clean-async-snapshot-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport { runInCleanSnapshot }\n"],"names":["runInCleanSnapshot"],"mappings":"AAAA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 11575, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/render-to-string.tsx"],"sourcesContent":["import { streamToString } from '../stream-utils/node-web-streams-helper'\n\nexport async function renderToString({\n  renderToReadableStream,\n  element,\n}: {\n  // `renderToReadableStream()` method could come from different react-dom/server implementations\n  // such as `react-dom/server.edge` or `react-dom/server.node`, etc.\n  renderToReadableStream: typeof import('react-dom/server.edge').renderToReadableStream\n  element: React.ReactElement\n}): Promise<string> {\n  const renderStream = await renderToReadableStream(element)\n  await renderStream.allReady\n  return streamToString(renderStream)\n}\n"],"names":["streamToString","renderToString","renderToReadableStream","element","renderStream","allReady"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,0CAAyC;;AAEjE,eAAeC,eAAe,EACnCC,sBAAsB,EACtBC,OAAO,EAMR;IACC,MAAMC,eAAe,MAAMF,uBAAuBC;IAClD,MAAMC,aAAaC,QAAQ;IAC3B,wNAAOL,iBAAAA,EAAeI;AACxB","ignoreList":[0]}},
    {"offset": {"line": 11591, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/metadata-insertion/create-server-inserted-metadata.tsx"],"sourcesContent":["import React from 'react'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport {\n  ServerInsertedMetadataContext,\n  type MetadataResolver,\n} from '../../../shared/lib/server-inserted-metadata.shared-runtime'\nimport { renderToString } from '../render-to-string'\n\n/**\n * For chromium based browsers (Chrome, Edge, etc.) and Safari,\n * icons need to stay under <head> to be picked up by the browser.\n *\n */\nconst REINSERT_ICON_SCRIPT = `\\\ndocument.querySelectorAll('body link[rel=\"icon\"], body link[rel=\"apple-touch-icon\"]').forEach(el => document.head.appendChild(el))`\n\nexport function createServerInsertedMetadata(nonce: string | undefined) {\n  let metadataResolver: MetadataResolver | null = null\n  let metadataToFlush: React.ReactNode = null\n  const setMetadataResolver = (resolver: MetadataResolver): void => {\n    metadataResolver = resolver\n  }\n\n  return {\n    ServerInsertedMetadataProvider: ({\n      children,\n    }: {\n      children: React.ReactNode\n    }) => {\n      return (\n        <ServerInsertedMetadataContext.Provider value={setMetadataResolver}>\n          {children}\n        </ServerInsertedMetadataContext.Provider>\n      )\n    },\n\n    async getServerInsertedMetadata(): Promise<string> {\n      if (!metadataResolver || metadataToFlush) {\n        return ''\n      }\n\n      metadataToFlush = metadataResolver()\n      const html = await renderToString({\n        renderToReadableStream,\n        element: (\n          <>\n            {metadataToFlush}\n            <script nonce={nonce}>{REINSERT_ICON_SCRIPT}</script>\n          </>\n        ),\n      })\n\n      return html\n    },\n  }\n}\n"],"names":["React","renderToReadableStream","ServerInsertedMetadataContext","renderToString","REINSERT_ICON_SCRIPT","createServerInsertedMetadata","nonce","metadataResolver","metadataToFlush","setMetadataResolver","resolver","ServerInsertedMetadataProvider","children","Provider","value","getServerInsertedMetadata","html","element","script"],"mappings":";;;;AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SACEC,6BAA6B,QAExB,8DAA6D;AACpE,SAASC,cAAc,QAAQ,sBAAqB;;;;;;AAEpD;;;;CAIC,GACD,MAAMC,uBAAuB,CAAC;kIACoG,CAAC;AAE5H,SAASC,6BAA6BC,KAAyB;IACpE,IAAIC,mBAA4C;IAChD,IAAIC,kBAAmC;IACvC,MAAMC,sBAAsB,CAACC;QAC3BH,mBAAmBG;IACrB;IAEA,OAAO;QACLC,gCAAgC,CAAC,EAC/BC,QAAQ,EAGT;YACC,OAAA,WAAA,IACE,qLAAA,+MAACV,gCAAAA,CAA8BW,QAAQ,EAAA;gBAACC,OAAOL;0BAC5CG;;QAGP;QAEA,MAAMG;YACJ,IAAI,CAACR,oBAAoBC,iBAAiB;gBACxC,OAAO;YACT;YAEAA,kBAAkBD;YAClB,MAAMS,OAAO,2MAAMb,iBAAAA,EAAe;2NAChCF,yBAAAA;gBACAgB,SAAAA,WAAAA,mLACE,OAAA,EAAA,2KAAA,CAAA,WAAA,EAAA;;wBACGT;sNACD,MAAA,EAACU,UAAAA;4BAAOZ,OAAOA;sCAAQF;;;;YAG7B;YAEA,OAAOY;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 11650, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from './types'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  ClientReferenceManifest,\n  ManifestNode,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  getFirstDynamicReason,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  consumeDynamicAccess,\n  type DynamicAccess,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../shared/lib/router/action-queue'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { ServerPrerenderStreamResult } from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n  prerenderServerWithPhases,\n  prerenderClientWithPhases,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport './clean-async-snapshot.external'\nimport { INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n}\n\nconst flightDataPathHeadKey = 'h'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isPrefetchRequest =\n    isDevWarmupRequest ||\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest =\n    isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\nfunction createDivergedMetadataComponents(\n  Metadata: React.ComponentType,\n  serveStreamingMetadata: boolean\n): {\n  StaticMetadata: React.ComponentType<{}>\n  StreamingMetadata: React.ComponentType<{}> | null\n} {\n  function EmptyMetadata() {\n    return null\n  }\n  const StreamingMetadata: React.ComponentType | null = serveStreamingMetadata\n    ? Metadata\n    : null\n\n  const StaticMetadata: React.ComponentType<{}> = serveStreamingMetadata\n    ? EmptyMetadata\n    : Metadata\n\n  return {\n    StaticMetadata,\n    StreamingMetadata,\n  }\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({ ctx }: { ctx: AppRenderContext }) {\n  const is404Page = ctx.pagePath === '/404'\n  const isInvalidStatusCode =\n    typeof ctx.res.statusCode === 'number' && ctx.res.statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  if (!ctx.isAction && (is404Page || isInvalidStatusCode)) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const searchParams = createServerSearchParamsForMetadata(query, workStore)\n    const {\n      ViewportTree,\n      MetadataTree,\n      getViewportReady,\n      getMetadataReady,\n      StreamingMetadataOutlet,\n    } = createMetadataComponents({\n      tree: loaderTree,\n      searchParams,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        workStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createServerParamsForMetadata,\n      workStore,\n      MetadataBoundary,\n      ViewportBoundary,\n      serveStreamingMetadata,\n    })\n\n    const { StreamingMetadata, StaticMetadata } =\n      createDivergedMetadataComponents(() => {\n        return (\n          // Adding requestId as react key to make metadata remount for each render\n          <MetadataTree key={requestId} />\n        )\n      }, serveStreamingMetadata)\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            {/* noindex needs to be blocking */}\n            <NonIndex ctx={ctx} />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <ViewportTree key={requestId} />\n            {StreamingMetadata ? <StreamingMetadata /> : null}\n            <StaticMetadata />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        StreamingMetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    routeType: ctx.isAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during dynamicIO development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  if (\n    // We only want this behavior when running `next dev`\n    renderOpts.dev &&\n    // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' &&\n    // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO\n  ) {\n    const [resolveValidation, validationOutlet] = createValidationOutlet()\n    RSCPayload._validation = validationOutlet\n\n    spawnDynamicValidationInDev(\n      resolveValidation,\n      ctx.componentMod.tree,\n      ctx,\n      false,\n      ctx.clientReferenceManifest,\n      ctx.workStore.route,\n      requestStore\n    )\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    ctx.componentMod.renderToReadableStream,\n    RSCPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n  if (!renderOpts.dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  const rootParams = getRootParams(\n    ctx.componentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  // We're doing a dev warmup, so we should create a new resume data cache so\n  // we can fill it.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const renderController = new AbortController()\n  const prerenderController = new AbortController()\n  const cacheSignal = new CacheSignal()\n\n  const prerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: renderController.signal,\n    controller: prerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const rscPayload = await workUnitAsyncStorage.run(\n    prerenderStore,\n    generateDynamicRSCPayload,\n    ctx\n  )\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  workUnitAsyncStorage.run(\n    prerenderStore,\n    ctx.componentMod.renderToReadableStream,\n    rscPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      signal: renderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling\n  await cacheSignal.cacheReady()\n  // We unset the cache so any late over-run renders aren't able to write into this cache\n  prerenderStore.prerenderResumeDataCache = null\n  // Abort the render\n  renderController.abort()\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n    devRenderResumeDataCache: createRenderResumeDataCache(\n      prerenderResumeDataCache\n    ),\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const {\n    ViewportTree,\n    MetadataTree,\n    getViewportReady,\n    getMetadataReady,\n    StreamingMetadataOutlet,\n  } = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    searchParams,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      workStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const { StreamingMetadata, StaticMetadata } =\n    createDivergedMetadataComponents(() => {\n      return (\n        // Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed\n        <MetadataTree />\n      )\n    }, serveStreamingMetadata)\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getViewportReady,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    StreamingMetadata,\n    StreamingMetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      <ViewportTree key={ctx.requestId} />\n      <StaticMetadata />\n    </React.Fragment>\n  )\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    requestId,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const { MetadataTree, ViewportTree } = createMetadataComponents({\n    tree,\n    searchParams,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  const { StreamingMetadata, StaticMetadata } =\n    createDivergedMetadataComponents(\n      () => (\n        <React.Fragment key={flightDataPathHeadKey}>\n          {/* Adding requestId as react key to make metadata remount for each render */}\n          <MetadataTree key={requestId} />\n        </React.Fragment>\n      ),\n      serveStreamingMetadata\n    )\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <ViewportTree key={requestId} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n      <StaticMetadata />\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head>{StreamingMetadata ? <StreamingMetadata /> : null}</head>\n      <body>\n        {process.env.NODE_ENV !== 'production' && err ? (\n          <template\n            data-next-error-message={err.message}\n            data-next-error-digest={'digest' in err ? err.digest : ''}\n            data-next-error-stack={err.stack}\n          />\n        ) : null}\n      </body>\n    </html>,\n    {},\n    null,\n    false,\n  ]\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n  ServerInsertedHTMLProvider,\n  ServerInsertedMetadataProvider,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedMetadataProvider>\n        <ServerInsertedHTMLProvider>\n          <AppRouter\n            actionQueue={actionQueue}\n            globalErrorComponentAndStyles={response.G}\n            assetPrefix={response.p}\n          />\n        </ServerInsertedHTMLProvider>\n      </ServerInsertedMetadataProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction AppWithoutContext<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  return (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorComponentAndStyles={response.G}\n      assetPrefix={response.p}\n    />\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null,\n  implicitTags: Array<string>,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n\n  setReferenceManifestsSingleton({\n    page: workStore.page,\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = workStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isActionRequest = getServerActionRequestMetadata(req).isServerAction\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isAction: isActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      workStore,\n      loaderTree,\n      implicitTags\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      const pendingPromise = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ]).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    if (response.collectedTags) {\n      metadata.fetchTags = response.collectedTags.join(',')\n    }\n\n    // Let the client router know how long to keep the cached entry around.\n    const staleHeader = String(response.collectedStale)\n    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n    metadata.headers ??= {}\n    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n      metadata.cacheControl = { revalidate: 0, expire: undefined }\n    } else {\n      // Copy the cache control value onto the render result metadata.\n      metadata.cacheControl = {\n        revalidate:\n          response.collectedRevalidate >= INFINITE_CACHE\n            ? false\n            : response.collectedRevalidate,\n        expire:\n          response.collectedExpire >= INFINITE_CACHE\n            ? undefined\n            : response.collectedExpire,\n      }\n    }\n\n    // provide bailout info for debugging\n    if (metadata.cacheControl?.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: workStore.dynamicUsageDescription,\n        stack: workStore.dynamicUsageStack,\n      }\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.devRenderResumeDataCache ??\n      postponedState?.renderResumeDataCache\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const requestStore = createRequestStoreForRender(\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache\n    )\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req) &&\n      !isDevWarmupRequest\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        if (!requestStore.usedDynamic && !workStore.forceDynamic) {\n          // only node can be ISR so we only need to update the status here\n          const { pathname } = new URL(req.url || '/', 'http://n')\n          setIsrStatus(pathname, true)\n        }\n      })\n    }\n\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx, requestStore)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            workStore,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      workStore,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      const pendingPromise = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ]).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  isDevWarmup: boolean,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  isDevWarmup,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n  })\n\n  const { isPrefetchRequest } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.devRenderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const implicitTags = getImplicitTags(\n    renderOpts.routeModule.definition.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    requestEndedState,\n    postponedState,\n    implicitTags,\n    serverComponentsHmrCache,\n    sharedContext\n  )\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n  const appendHeader = res.appendHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      renderOpts.dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into dynamicIO\n      renderOpts.experimental.dynamicIO\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during dynamicIO development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n              filterStackFrame(url: string, _functionName: string): boolean {\n                // The default implementation filters out <anonymous> stack frames\n                // but we want to retain them because current Server Components and\n                // built-in Components in parent stacks don't have source location.\n                return !url.startsWith('node:') && !url.includes('node_modules')\n              },\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      spawnDynamicValidationInDev(\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        workStore.route,\n        requestStore\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            appendHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        bootstrapScripts: [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML =\n      renderOpts.supportsDynamicResponse !== true ||\n      !!renderOpts.shouldWaitOnAllReady\n\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      getServerInsertedMetadata,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer: require('react-dom/server.edge'),\n          element: (\n            <AppWithoutContext\n              reactServerStream={errorServerStream}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={ctx.nonce}\n            />\n          ),\n          streamOptions: {\n            nonce: ctx.nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        renderOpts.supportsDynamicResponse !== true ||\n        !!renderOpts.shouldWaitOnAllReady\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        getServerInsertedMetadata,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  route: string,\n  requestStore: RequestStore\n): Promise<void> {\n  const { componentMod: ComponentMod } = ctx\n  const rootParams = getRootParams(\n    ComponentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  const cacheSignal = new CacheSignal()\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  const initialServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const initialClientController = new AbortController()\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: initialClientController.signal,\n    controller: initialClientController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  let initialServerStream\n  try {\n    initialServerStream = workUnitAsyncStorage.run(\n      initialServerPrerenderStore,\n      ComponentMod.renderToReadableStream,\n      firstAttemptRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // The render aborted before this error was handled which indicates\n            // the error is caused by unfinished components within the render\n            return\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n        signal: initialServerRenderController.signal,\n      }\n    )\n  } catch (err: unknown) {\n    if (\n      initialServerPrerenderController.signal.aborted ||\n      initialServerRenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, route)\n    }\n  }\n\n  const nonce = '1'\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n\n  if (initialServerStream) {\n    const [warmupStream, renderStream] = initialServerStream.tee()\n    initialServerStream = null\n    // Before we attempt the SSR initial render we need to ensure all client modules\n    // are already loaded.\n    await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    const pendingInitialClientResult = workUnitAsyncStorage.run(\n      initialClientPrerenderStore,\n      prerender,\n      <App\n        reactServerStream={renderStream}\n        preinitScripts={() => {}}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={nonce}\n      />,\n      {\n        signal: initialClientController.signal,\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (initialClientController.signal.aborted) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n      }\n    )\n    pendingInitialClientResult.catch((err: unknown) => {\n      if (initialClientController.signal.aborted) {\n        // We aborted the render normally and can ignore this error\n      } else {\n        // We're going to retry to so we normally would suppress this error but\n        // when verbose logging is on we print it\n        if (process.env.__NEXT_VERBOSE_LOGGING) {\n          printDebugThrownValueForProspectiveRender(err, route)\n        }\n      }\n    })\n  }\n\n  await cacheSignal.cacheReady()\n  // It is important that we abort the SSR render first to avoid\n  // connection closed errors from having an incomplete RSC stream\n  initialClientController.abort()\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We've now filled caches and triggered any inadvertent sync bailouts\n  // due to lazy module initialization. We can restart our render to capture results\n\n  const finalServerController = new AbortController()\n  const serverDynamicTracking = createDynamicTrackingState(false)\n\n  const finalServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const finalClientController = new AbortController()\n  const clientDynamicTracking = createDynamicTrackingState(false)\n  const dynamicValidation = createDynamicValidationState()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags: [],\n    renderSignal: finalClientController.signal,\n    controller: finalClientController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n  }\n\n  const finalServerPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const serverPrerenderStreamResult = await prerenderServerWithPhases(\n    finalServerController.signal,\n    () =>\n      workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.renderToReadableStream,\n        finalServerPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: (err) => {\n            if (isUseCacheTimeoutError(err)) {\n              return err.digest\n            }\n\n            if (\n              finalServerController.signal.aborted &&\n              isPrerenderInterruptedError(err)\n            ) {\n              return err.digest\n            }\n\n            return getDigestForWellKnownError(err)\n          },\n          signal: finalServerController.signal,\n        }\n      ),\n    () => {\n      finalServerController.abort()\n    }\n  )\n\n  let rootDidError = false\n  const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n  try {\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    await prerenderClientWithPhases(\n      () =>\n        workUnitAsyncStorage.run(\n          finalClientPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={serverPhasedStream}\n            preinitScripts={() => {}}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          {\n            signal: finalClientController.signal,\n            onError: (err, errorInfo) => {\n              if (isUseCacheTimeoutError(err)) {\n                dynamicValidation.dynamicErrors.push(err)\n\n                return\n              }\n\n              if (\n                isPrerenderInterruptedError(err) ||\n                finalClientController.signal.aborted\n              ) {\n                if (!rootDidError) {\n                  // If the root errored before we observe this error then it wasn't caused by something dynamic.\n                  // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n                  // then we are a dynamic route.\n                  requestStore.usedDynamic = true\n                }\n\n                const componentStack = errorInfo.componentStack\n                if (typeof componentStack === 'string') {\n                  trackAllowedDynamicAccess(\n                    route,\n                    componentStack,\n                    dynamicValidation,\n                    serverDynamicTracking,\n                    clientDynamicTracking\n                  )\n                }\n                return\n              }\n\n              return getDigestForWellKnownError(err)\n            },\n          }\n        ),\n      () => {\n        finalClientController.abort()\n        serverPhasedStream.assertExhausted()\n      }\n    )\n  } catch (err) {\n    rootDidError = true\n    if (\n      isPrerenderInterruptedError(err) ||\n      finalClientController.signal.aborted\n    ) {\n      // we don't have a root because the abort errored in the root. We can just ignore this error\n    } else {\n      // If an error is thrown in the root before prerendering is aborted, we\n      // don't want to rethrow it here, otherwise this would lead to a hanging\n      // response and unhandled rejection. We also don't want to log it, because\n      // it's most likely already logged as part of the normal render. So we\n      // just fall through here, to make sure `resolveValidation` is called.\n    }\n  }\n\n  function LogDynamicValidation() {\n    try {\n      throwIfDisallowedDynamic(\n        route,\n        dynamicValidation,\n        serverDynamicTracking,\n        clientDynamicTracking\n      )\n    } catch {}\n    return null\n  }\n\n  resolveValidation(<LogDynamicValidation />)\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  implicitTags: Array<string>\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n  const rootParams = getRootParams(tree, ctx.getDynamicParamFromSegment)\n\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = workStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult:\n    | null\n    | ReactServerPrerenderResult\n    | ServerPrerenderStreamResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        // The cacheSignal helps us track whether caches are still filling or we are ready\n        // to cut the render off.\n        const cacheSignal = new CacheSignal()\n\n        // The resume data cache here should use a fresh instance as it's\n        // performing a fresh prerender. If we get to implementing the\n        // prerendering of an already prerendered page, we should use the passed\n        // resume data cache instead.\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const initialServerPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const pendingInitialServerResult = workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          ComponentMod.prerender,\n          initialServerPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (initialServerPrerenderController.signal.aborted) {\n                // The render aborted before this error was handled which indicates\n                // the error is caused by unfinished components within the render\n                return\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            },\n            // we don't care to track postpones during the prospective render because we need\n            // to always do a final render anyway\n            onPostpone: undefined,\n            // We don't want to stop rendering until the cacheSignal is complete so we pass\n            // a different signal to this render call than is used by dynamic APIs to signify\n            // transitioning out of the prerender environment\n            signal: initialServerRenderController.signal,\n          }\n        )\n\n        await cacheSignal.cacheReady()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        let initialServerResult\n        try {\n          initialServerResult = await createReactServerPrerenderResult(\n            pendingInitialServerResult\n          )\n        } catch (err) {\n          if (\n            initialServerRenderController.signal.aborted ||\n            initialServerPrerenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerResult) {\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(\n            initialServerResult.asStream(),\n            clientReferenceManifest\n          )\n\n          const initialClientController = new AbortController()\n          const initialClientPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            rootParams,\n            implicitTags: implicitTags,\n            renderSignal: initialClientController.signal,\n            controller: initialClientController,\n            cacheSignal: null,\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...implicitTags],\n            prerenderResumeDataCache,\n          }\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                initialClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={initialServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: initialClientController.signal,\n                  onError: (err) => {\n                    const digest = getDigestForWellKnownError(err)\n\n                    if (digest) {\n                      return digest\n                    }\n\n                    if (initialClientController.signal.aborted) {\n                      // These are expected errors that might error the prerender. we ignore them.\n                    } else if (\n                      process.env.NEXT_DEBUG_BUILD ||\n                      process.env.__NEXT_VERBOSE_LOGGING\n                    ) {\n                      // We don't normally log these errors because we are going to retry anyway but\n                      // it can be useful for debugging Next.js itself to get visibility here when needed\n                      printDebugThrownValueForProspectiveRender(\n                        err,\n                        workStore.route\n                      )\n                    }\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              initialClientController.abort()\n            }\n          ).catch((err) => {\n            if (\n              initialServerRenderController.signal.aborted ||\n              isPrerenderInterruptedError(err)\n            ) {\n              // These are expected errors that might error the prerender. we ignore them.\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              // We don't normally log these errors because we are going to retry anyway but\n              // it can be useful for debugging Next.js itself to get visibility here when needed\n              printDebugThrownValueForProspectiveRender(err, workStore.route)\n            }\n          })\n        }\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        let prerenderIsPending = true\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              async () => {\n                const prerenderResult = await workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: (err: unknown) => {\n                      return serverComponentsErrorHandler(err)\n                    },\n                    signal: finalServerController.signal,\n                  }\n                )\n                prerenderIsPending = false\n                return prerenderResult\n              },\n              () => {\n                if (finalServerController.signal.aborted) {\n                  // If the server controller is already aborted we must have called something\n                  // that required aborting the prerender synchronously such as with new Date()\n                  serverIsDynamic = true\n                  return\n                }\n\n                if (prerenderIsPending) {\n                  // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                  // there is something unfinished.\n                  serverIsDynamic = true\n                }\n                finalServerController.abort()\n              }\n            )\n          ))\n\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const finalClientController = new AbortController()\n        const finalClientPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        }\n\n        let clientIsDynamic = false\n        let dynamicValidation = createDynamicValidationState()\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n          () =>\n            workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={ctx.nonce}\n              />,\n              {\n                signal: finalClientController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientController.signal.aborted\n                  ) {\n                    clientIsDynamic = true\n\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore.route,\n                        componentStack,\n                        dynamicValidation,\n                        serverDynamicTracking,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            ),\n          () => {\n            finalClientController.abort()\n          }\n        )\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalRenderPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = await getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams,\n              prerenderResumeDataCache\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = await getDynamicDataPostponedState(\n              prerenderResumeDataCache\n            )\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        } else {\n          // Static case\n          if (workStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={ctx.nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce: ctx.nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                ctx.nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = workStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        const cacheSignal = new CacheSignal()\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const initialClientController = new AbortController()\n        const initialClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: initialClientController.signal,\n          controller: initialClientController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        let initialServerStream\n        try {\n          initialServerStream = workUnitAsyncStorage.run(\n            initialServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (\n                  initialServerPrerenderController.signal.aborted ||\n                  initialServerRenderController.signal.aborted\n                ) {\n                  // The render aborted before this error was handled which indicates\n                  // the error is caused by unfinished components within the render\n                  return\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              signal: initialServerRenderController.signal,\n            }\n          )\n        } catch (err: unknown) {\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerStream) {\n          const [warmupStream, renderStream] = initialServerStream.tee()\n          initialServerStream = null\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const pendingInitialClientResult = workUnitAsyncStorage.run(\n            initialClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={ctx.nonce}\n            />,\n            {\n              signal: initialClientController.signal,\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (initialClientController.signal.aborted) {\n                  // These are expected errors that might error the prerender. we ignore them.\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  // We don't normally log these errors because we are going to retry anyway but\n                  // it can be useful for debugging Next.js itself to get visibility here when needed\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              bootstrapScripts: [bootstrapScript],\n            }\n          )\n          pendingInitialClientResult.catch((err: unknown) => {\n            if (initialClientController.signal.aborted) {\n              // We aborted the render normally and can ignore this error\n            } else {\n              // We're going to retry to so we normally would suppress this error but\n              // when verbose logging is on we print it\n              if (process.env.__NEXT_VERBOSE_LOGGING) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            }\n          })\n        }\n\n        await cacheSignal.cacheReady()\n        // It is important that we abort the SSR render first to avoid\n        // connection closed errors from having an incomplete RSC stream\n        initialClientController.abort()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        // We've now filled caches and triggered any inadvertant sync bailouts\n        // due to lazy module initialization. We can restart our render to capture results\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        let clientIsDynamic = false\n        const finalClientController = new AbortController()\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const dynamicValidation = createDynamicValidationState()\n\n        const finalClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags: implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags],\n          prerenderResumeDataCache,\n        })\n\n        const finalServerPayload = await workUnitAsyncStorage.run(\n          finalServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const serverPrerenderStreamResult = (reactServerPrerenderResult =\n          await prerenderServerWithPhases(\n            finalServerController.signal,\n            () =>\n              workUnitAsyncStorage.run(\n                finalServerPrerenderStore,\n                ComponentMod.renderToReadableStream,\n                finalServerPayload,\n                clientReferenceManifest.clientModules,\n                {\n                  onError: (err: unknown) => {\n                    if (finalServerController.signal.aborted) {\n                      serverIsDynamic = true\n                      if (isPrerenderInterruptedError(err)) {\n                        return err.digest\n                      }\n                      return getDigestForWellKnownError(err)\n                    }\n\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerController.signal,\n                }\n              ),\n            () => {\n              finalServerController.abort()\n            }\n          ))\n\n        let htmlStream\n        const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n        try {\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const result = await prerenderClientWithPhases(\n            () =>\n              workUnitAsyncStorage.run(\n                finalClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={serverPhasedStream}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: finalClientController.signal,\n                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n                    if (\n                      isPrerenderInterruptedError(err) ||\n                      finalClientController.signal.aborted\n                    ) {\n                      clientIsDynamic = true\n\n                      const componentStack: string | undefined = (\n                        errorInfo as any\n                      ).componentStack\n                      if (typeof componentStack === 'string') {\n                        trackAllowedDynamicAccess(\n                          workStore.route,\n                          componentStack,\n                          dynamicValidation,\n                          serverDynamicTracking,\n                          clientDynamicTracking\n                        )\n                      }\n                      return\n                    }\n\n                    return htmlRendererErrorHandler(err, errorInfo)\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              finalClientController.abort()\n              serverPhasedStream.assertExhausted()\n            }\n          )\n          htmlStream = result.prelude\n        } catch (err) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            finalClientController.signal.aborted\n          ) {\n            // we don't have a root because the abort errored in the root. We can just ignore this error\n          } else {\n            // This error is something else and should bubble up\n            throw err\n          }\n        }\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          const dynamicReason = serverIsDynamic\n            ? getFirstDynamicReason(serverDynamicTracking)\n            : getFirstDynamicReason(clientDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          }\n        }\n\n        const flightData = await streamToBuffer(\n          serverPrerenderStreamResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalClientPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream!, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              serverPrerenderStreamResult.asStream(),\n              ctx.nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            validateRootLayout,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: finalServerPrerenderStore.stale,\n          collectedTags: finalServerPrerenderStore.tags,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n        prerenderResumeDataCache,\n      }\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await workUnitAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams,\n            prerenderResumeDataCache\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={ctx.nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags: implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce: ctx.nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: prerenderLegacyStore.stale,\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <AppWithoutContext\n            reactServerStream={errorServerStream}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={ctx.nonce}\n          />\n        ),\n        streamOptions: {\n          nonce: ctx.nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream =\n        reactServerPrerenderResult instanceof ServerPrerenderStreamResult\n          ? reactServerPrerenderResult.asStream()\n          : reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale:\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE,\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: ReadableStream<Uint8Array>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  let createFromReadableStream\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  try {\n    createFromReadableStream(flightStream, {\n      serverConsumerManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n        serverModuleMap: null,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<React.ReactNode | undefined> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n\n  return globalErrorStyles\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const clientReferenceManifest = renderOpts.clientReferenceManifest\n  if (!clientReferenceManifest || !renderOpts.experimental.clientSegmentCache) {\n    return\n  }\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: null,\n  }\n\n  // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n  // promise, the absence of which we use to determine if a segment is fully\n  // static or partially static. However, when dynamicIO is not enabled, this\n  // trick doesn't work.\n  //\n  // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n  // assume all segments are partial.\n  //\n  // TODO: When PPR is on, we can at least optimize the case where the entire\n  // page is static. Either by passing that as an argument to this function, or\n  // by setting a header on the response like the we do for full page RSC\n  // prefetches today. The latter approach might be simpler since it requires\n  // less plumbing, and the client has to check the header regardless to see if\n  // PPR is enabled.\n  const shouldAssumePartialData =\n    renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n\n  const staleTime = prerenderStore.stale\n  return await ComponentMod.collectSegmentData(\n    shouldAssumePartialData,\n    fullPageDataBuffer,\n    staleTime,\n    clientReferenceManifest.clientModules as ManifestNode,\n    serverConsumerManifest,\n    fallbackRouteParams\n  )\n}\n"],"names":["workAsyncStorage","React","RenderResult","chainStreams","renderToInitialFizzStream","createDocumentClosingStream","continueFizzStream","continueDynamicPrerender","continueStaticPrerender","continueDynamicHTMLResume","streamToBuffer","streamToString","stripInternalQueries","NEXT_HMR_REFRESH_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_URL","RSC_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","createTrackedMetadataContext","createMetadataContext","createRequestStoreForRender","createWorkStore","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getURLFromRedirectError","getRedirectStatusCodeFromError","isRedirectError","getImplicitTags","AppRenderSpan","NextNodeServerSpan","getTracer","FlightRenderResult","createFlightReactServerErrorHandler","createHTMLReactServerErrorHandler","createHTMLErrorHandler","isUserLandError","getDigestForWellKnownError","getShortDynamicParamType","dynamicParamTypes","getSegmentParam","getScriptNonceFromHeader","parseAndValidateFlightRouterState","createFlightRouterStateFromLoaderTree","handleAction","isBailoutToCSRError","warn","error","appendMutableCookies","createServerInsertedHTML","getRequiredScripts","addPathPrefix","makeGetServerInsertedHTML","walkTreeWithFlightRouterState","createComponentTree","getRootParams","getAssetQueryString","setReferenceManifestsSingleton","DynamicState","parsePostponedState","getDynamicDataPostponedState","getDynamicHTMLPostponedState","getPostponedFromState","isDynamicServerError","useFlightStream","createInlinedDataReadableStream","StaticGenBailoutError","isStaticGenBailoutError","getStackWithoutErrorMessage","accessedDynamicData","createPostponedAbortSignal","formatDynamicAPIAccesses","isPrerenderInterruptedError","createDynamicTrackingState","createDynamicValidationState","getFirstDynamicReason","trackAllowedDynamicAccess","throwIfDisallowedDynamic","consumeDynamicAccess","getClientComponentLoaderMetrics","wrapClientComponentLoader","createServerModuleMap","isNodeNextRequest","parseParameter","parseRelativeUrl","AppRouter","getServerActionRequestMetadata","createInitialRouterState","createMutableActionQueue","getRevalidateReason","PAGE_SEGMENT_KEY","DynamicServerError","ServerPrerenderStreamResult","ReactServerResult","createReactServerPrerenderResult","createReactServerPrerenderResultFromRender","prerenderAndAbortInSequentialTasks","prerenderServerWithPhases","prerenderClientWithPhases","printDebugThrownValueForProspectiveRender","scheduleInSequentialTasks","waitAtLeastOneReactRenderTask","workUnitAsyncStorage","CacheSignal","getTracedMetadata","InvariantError","INFINITE_CACHE","createComponentStylesAndScripts","parseLoaderTree","createPrerenderResumeDataCache","createRenderResumeDataCache","isError","isUseCacheTimeoutError","createServerInsertedMetadata","flightDataPathHeadKey","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","toLowerCase","undefined","isHmrRefresh","isRSCRequest","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","isRouteTreePrefetchRequest","csp","nonce","createNotFoundLoaderTree","loaderTree","components","children","page","createDivergedMetadataComponents","Metadata","serveStreamingMetadata","EmptyMetadata","StreamingMetadata","StaticMetadata","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","treeSegment","split","slice","flatMap","pathSegment","join","NonIndex","ctx","is404Page","isInvalidStatusCode","res","statusCode","isAction","meta","name","content","generateDynamicRSCPayload","flightData","componentMod","tree","createServerSearchParamsForMetadata","createServerParamsForMetadata","createMetadataComponents","MetadataBoundary","ViewportBoundary","appUsingSizeAdjustment","query","requestId","workStore","url","renderOpts","skipFlight","preloadCallbacks","searchParams","ViewportTree","MetadataTree","getViewportReady","getMetadataReady","StreamingMetadataOutlet","metadataContext","pathname","loaderTreeToFilter","parentParams","rscHead","Fragment","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","sharedContext","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","generateDynamicFlightRenderResult","req","requestStore","onFlightDataRenderError","err","onInstrumentationRequestError","onError","dev","RSCPayload","run","process","env","NODE_ENV","experimental","dynamicIO","resolveValidation","validationOutlet","createValidationOutlet","_validation","spawnDynamicValidationInDev","clientReferenceManifest","route","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","fetchMetrics","warmupDevRender","rootParams","prerenderResumeDataCache","renderController","AbortController","prerenderController","cacheSignal","prerenderStore","phase","implicitTags","renderSignal","signal","controller","dynamicTracking","revalidate","expire","stale","tags","rscPayload","cacheReady","abort","devRenderResumeDataCache","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","GlobalError","initialTree","errorType","seedData","authInterrupts","varyHeader","getHeader","couldBeIntercepted","includes","initialHead","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","ssrError","Error","html","id","head","body","template","data-next-error-message","message","data-next-error-digest","digest","data-next-error-stack","stack","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","ServerInsertedMetadataProvider","response","use","initialState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","Map","location","prerendered","actionQueue","HeadManagerContext","require","Provider","appDir","globalErrorComponentAndStyles","AppWithoutContext","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setIsrStatus","NEXT_RUNTIME","originalRequest","on","ended","metrics","reset","startSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","patchFetch","taintObjectReference","crypto","randomUUID","nanoid","isActionRequest","isServerAction","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","getBodyResult","spanName","prerenderToStream","dynamicAccess","isDebugDynamicAccesses","access","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","length","find","pendingRevalidates","pendingRevalidateWrites","revalidatedTags","pendingPromise","Promise","all","incrementalCache","revalidateTag","Object","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","waitUntil","collectedTags","fetchTags","staleHeader","String","collectedStale","setHeader","forceStatic","collectedRevalidate","cacheControl","collectedExpire","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","stream","renderResumeDataCache","onUpdateCookies","previewProps","usedDynamic","forceDynamic","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","generateFlight","notFoundLoaderTree","result","assignMetadata","renderToHTMLOrFlight","routeModule","definition","renderServerInsertedHTML","getServerInsertedMetadata","tracingMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","reactServerResult","bind","appendHeader","prerenderPhase","environmentName","filterStackFrame","_functionName","startsWith","DATA","inlinedReactServerDataStream","tee","resume","htmlStream","getServerInsertedHTML","serverCapturedErrors","basePath","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","generateStaticHTML","supportsDynamicResponse","shouldWaitOnAllReady","validateRootLayout","shouldBailoutToCSR","reason","redirectUrl","Headers","mutableCookies","from","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","outlet","resolve","isNotFound","initialServerPrerenderController","initialServerRenderController","initialServerPrerenderStore","initialClientController","initialClientPrerenderStore","firstAttemptRSCPayload","initialServerStream","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","warmupStream","renderStream","warmFlightResponse","prerender","pendingInitialClientResult","catch","finalServerController","serverDynamicTracking","finalServerPrerenderStore","finalClientController","clientDynamicTracking","dynamicValidation","finalClientPrerenderStore","finalServerPayload","serverPrerenderStreamResult","rootDidError","serverPhasedStream","asPhasedStream","errorInfo","dynamicErrors","push","componentStack","assertExhausted","LogDynamicValidation","shouldGenerateStaticFlightData","reactServerPrerenderResult","setMetadataHeader","item","initialServerPayload","pendingInitialServerResult","onPostpone","initialServerResult","asStream","asUnclosingStream","serverIsDynamic","finalRenderPrerenderStore","finalAttemptRSCPayload","prerenderIsPending","prerenderResult","clientIsDynamic","prelude","segmentData","collectSegmentData","foreverStream","ReadableStream","resumeStream","JSON","parse","stringify","consumeAsStream","cache","dynamicReason","reactServerPrerenderStore","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","flightStream","loadingChunks","chunkListeners","load","add","delete","createFromReadableStream","TURBOPACK","serverConsumerManifest","moduleLoading","moduleMap","ssrModuleMapping","r","modules","globalErrorModule","styles","filePath","getComponent","fullPageDataBuffer","clientSegmentCache","isEdgeRuntime","edgeRscModuleMapping","rscModuleMapping","shouldAssumePartialData","staleTime"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14333, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/rsc/preloads.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport ReactDOM from 'react-dom'\n\nexport function preloadStyle(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'style' }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preloadFont(\n  href: string,\n  type: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'font', type }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preconnect(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = {}\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ;(ReactDOM as any).preconnect(href, opts)\n}\n"],"names":["ReactDOM","preloadStyle","href","crossOrigin","nonce","opts","as","preload","preloadFont","type","preconnect"],"mappings":"AAAA;;;;AAIA;;;;;AAEA,OAAOA,cAAc,YAAW;;AAEzB,SAASC,aACdC,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;IAAQ;IAChC,IAAI,OAAOH,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;wMACAJ,UAAAA,CAASO,OAAO,CAACL,MAAMG;AACzB;AAEO,SAASG,YACdN,IAAY,EACZO,IAAY,EACZN,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;QAAQG;IAAK;IACrC,IAAI,OAAON,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;wMACAJ,UAAAA,CAASO,OAAO,CAACL,MAAMG;AACzB;AAEO,SAASK,WACdR,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY,CAAC;IACnB,IAAI,OAAOF,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;;wMACEJ,UAAAA,CAAiBU,UAAU,CAACR,MAAMG;AACtC","ignoreList":[0]}},
    {"offset": {"line": 14386, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/rsc/postpone.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\n// When postpone is available in canary React we can switch to importing it directly\nexport { Postpone } from '../dynamic-rendering'\n"],"names":["Postpone"],"mappings":"AAAA;;;;AAIA,GAEA,oFAAoF","ignoreList":[0]}},
    {"offset": {"line": 14409, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/rsc/taint.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport * as React from 'react'\n\ntype Reference = object\ntype TaintableUniqueValue = string | bigint | ArrayBufferView\n\nfunction notImplemented() {\n  throw new Error('Taint can only be used with the taint flag.')\n}\n\nexport const taintObjectReference: (\n  message: string | undefined,\n  object: Reference\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintObjectReference\n  : notImplemented\nexport const taintUniqueValue: (\n  message: string | undefined,\n  lifetime: Reference,\n  value: TaintableUniqueValue\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintUniqueValue\n  : notImplemented\n"],"names":["React","notImplemented","Error","taintObjectReference","process","env","__NEXT_EXPERIMENTAL_REACT","experimental_taintObjectReference","taintUniqueValue","experimental_taintUniqueValue"],"mappings":"AAAA;;;;AAIA;;;;AAEA,YAAYA,WAAW,QAAO;;AAK9B,SAASC;IACP,MAAM,OAAA,cAAwD,CAAxD,IAAIC,MAAM,gDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAuD;AAC/D;AAEO,MAAMC,uBAGDC,QAAQC,GAAG,CAACC,yBAAyB,GAE7CN,MAAMO,+BACNN,EADuC,aACzB;AACX,MAAMO,mBAIDJ,QAAQC,GAAG,CAACC,yBAAyB,GAE7CN,MAAMS,6BAA6B,EACnCR,eAAc","ignoreList":[0]}},
    {"offset": {"line": 14434, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  Segment as FlightRouterStateSegment,\n  DynamicParamTypesShort,\n} from './types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  encodeChildSegmentKey,\n  encodeSegment,\n  ROOT_SEGMENT_KEY,\n  type EncodedSegment,\n} from '../../shared/lib/segment-cache/segment-value-encoding'\nimport { getDigestForWellKnownError } from './create-error-handler'\nimport type { FallbackRouteParams } from '../request/fallback-params'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  head: HeadData\n  isHeadPartial: boolean\n  staleTime: number\n}\n\nexport type TreePrefetch = {\n  // The segment, in the format expected by a FlightRouterState.\n  segment: FlightRouterStateSegment\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  isRootLayout: boolean\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n}\n\nfunction onSegmentPrerenderError(error: unknown) {\n  const digest = getDigestForWellKnownError(error)\n  if (digest) {\n    return digest\n  }\n  // We don't need to log the errors because we would have already done that\n  // when generating the original Flight stream for the whole page.\n}\n\nexport async function collectSegmentData(\n  shouldAssumePartialData: boolean,\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<string, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      shouldAssumePartialData={shouldAssumePartialData}\n      fullPageDataBuffer={fullPageDataBuffer}\n      fallbackRouteParams={fallbackRouteParams}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree', treeBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  shouldAssumePartialData,\n  fullPageDataBuffer,\n  fallbackRouteParams,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  shouldAssumePartialData: boolean\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  fallbackRouteParams: FallbackRouteParams | null\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[string, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: HeadData = flightDataPaths[0][2]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = collectSegmentDataImpl(\n    shouldAssumePartialData,\n    flightRouterState,\n    buildId,\n    seedData,\n    fallbackRouteParams,\n    fullPageDataBuffer,\n    clientModules,\n    serverConsumerManifest,\n    ROOT_SEGMENT_KEY,\n    segmentTasks\n  )\n\n  const isHeadPartial =\n    shouldAssumePartialData || (await isPartialRSCData(head, clientModules))\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    head,\n    isHeadPartial,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nfunction collectSegmentDataImpl(\n  shouldAssumePartialData: boolean,\n  route: FlightRouterState,\n  buildId: string,\n  seedData: CacheNodeSeedData | null,\n  fallbackRouteParams: FallbackRouteParams | null,\n  fullPageDataBuffer: Buffer,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  key: string,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): TreePrefetch {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[2] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n    const childKey = encodeChildSegmentKey(\n      key,\n      parallelRouteKey,\n      Array.isArray(childSegment) && fallbackRouteParams !== null\n        ? encodeSegmentWithPossibleFallbackParam(\n            childSegment,\n            fallbackRouteParams\n          )\n        : encodeSegment(childSegment)\n    )\n    const childTree = collectSegmentDataImpl(\n      shouldAssumePartialData,\n      childRoute,\n      buildId,\n      childSeedData,\n      fallbackRouteParams,\n      fullPageDataBuffer,\n      clientModules,\n      serverConsumerManifest,\n      childKey,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          shouldAssumePartialData,\n          buildId,\n          seedData,\n          key,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  return {\n    segment: route[0],\n    slots: slotMetadata,\n    isRootLayout: route[4] === true,\n  }\n}\n\nfunction encodeSegmentWithPossibleFallbackParam(\n  segment: [string, string, DynamicParamTypesShort],\n  fallbackRouteParams: FallbackRouteParams\n): EncodedSegment {\n  const name = segment[0]\n  if (!fallbackRouteParams.has(name)) {\n    // Normal case. No matching fallback parameter.\n    return encodeSegment(segment)\n  }\n  // This segment includes a fallback parameter. During prerendering, a random\n  // placeholder value was used; however, for segment prefetches, we need the\n  // segment path to be predictable so the server can create a rewrite for it.\n  // So, replace the placeholder segment value with a \"template\" string,\n  // e.g. `[name]`.\n  // TODO: This will become a bit cleaner once remove route parameters from the\n  // server response, and instead add them to the segment keys on the client.\n  // Instead of a string replacement, like we do here, route params will always\n  // be encoded in separate step from the rest of the segment, not just in the\n  // case of fallback params.\n  const encodedSegment = encodeSegment(segment)\n  const lastIndex = encodedSegment.lastIndexOf('$')\n  const encodedFallbackSegment =\n    // NOTE: This is guaranteed not to clash with the rest of the segment\n    // because non-simple characters (including [ and ]) trigger a base\n    // 64 encoding.\n    encodedSegment.substring(0, lastIndex + 1) + `[${name}]`\n  return encodedFallbackSegment as EncodedSegment\n}\n\nasync function renderSegmentPrefetch(\n  shouldAssumePartialData: boolean,\n  buildId: string,\n  seedData: CacheNodeSeedData,\n  key: string,\n  clientModules: ManifestNode\n): Promise<[string, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    loading,\n    isPartial:\n      shouldAssumePartialData || (await isPartialRSCData(rsc, clientModules)),\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  if (key === ROOT_SEGMENT_KEY) {\n    return ['/_index', segmentBuffer]\n  } else {\n    return [key, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","unstable_prerender","prerender","streamFromBuffer","streamToBuffer","waitAtLeastOneReactRenderTask","encodeChildSegmentKey","encodeSegment","ROOT_SEGMENT_KEY","getDigestForWellKnownError","onSegmentPrerenderError","error","digest","collectSegmentData","shouldAssumePartialData","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","fallbackRouteParams","resultMap","Map","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","PrefetchTreeData","signal","onError","treeBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","flightRouterState","seedData","head","tree","collectSegmentDataImpl","isHeadPartial","isPartialRSCData","treePrefetch","route","key","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childKey","Array","isArray","encodeSegmentWithPossibleFallbackParam","childTree","push","then","renderSegmentPrefetch","segment","slots","isRootLayout","name","has","encodedSegment","lastIndex","lastIndexOf","encodedFallbackSegment","substring","rsc","loading","segmentPrefetch","isPartial","segmentStream","segmentBuffer","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14704, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/app-render/entry-base.ts"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nexport {\n  createTemporaryReferenceSet,\n  renderToReadableStream,\n  decodeReply,\n  decodeAction,\n  decodeFormState,\n} from 'react-server-dom-webpack/server.edge'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge'\n\nimport LayoutRouter from '../../client/components/layout-router'\nimport RenderFromTemplateContext from '../../client/components/render-from-template-context'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { actionAsyncStorage } from '../app-render/action-async-storage.external'\nimport { ClientPageRoot } from '../../client/components/client-page'\nimport { ClientSegmentRoot } from '../../client/components/client-segment'\nimport {\n  createServerSearchParamsForServerPage,\n  createPrerenderSearchParamsForClientPage,\n  createServerSearchParamsForMetadata,\n} from '../request/search-params'\nimport {\n  createServerParamsForServerSegment,\n  createServerParamsForMetadata,\n  createPrerenderParamsForClientSegment,\n} from '../request/params'\nimport * as serverHooks from '../../client/components/hooks-server-context'\nimport { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary'\nimport { createMetadataComponents } from '../../lib/metadata/metadata'\nimport { patchFetch as _patchFetch } from '../lib/patch-fetch'\n// not being used but needs to be included in the client manifest for /_not-found\nimport '../../client/components/error-boundary'\nimport {\n  MetadataBoundary,\n  ViewportBoundary,\n  OutletBoundary,\n} from '../../client/components/metadata/metadata-boundary'\n\nimport { preloadStyle, preloadFont, preconnect } from './rsc/preloads'\nimport { Postpone } from './rsc/postpone'\nimport { taintObjectReference } from './rsc/taint'\nexport { collectSegmentData } from './collect-segment-data'\n\n// patchFetch makes use of APIs such as `React.unstable_postpone` which are only available\n// in the experimental channel of React, so export it from here so that it comes from the bundled runtime\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  LayoutRouter,\n  RenderFromTemplateContext,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  actionAsyncStorage,\n  createServerSearchParamsForServerPage,\n  createServerSearchParamsForMetadata,\n  createPrerenderSearchParamsForClientPage,\n  createServerParamsForServerSegment,\n  createServerParamsForMetadata,\n  createPrerenderParamsForClientSegment,\n  serverHooks,\n  preloadStyle,\n  preloadFont,\n  preconnect,\n  Postpone,\n  MetadataBoundary,\n  ViewportBoundary,\n  OutletBoundary,\n  taintObjectReference,\n  ClientPageRoot,\n  ClientSegmentRoot,\n  HTTPAccessFallbackBoundary,\n  patchFetch,\n  createMetadataComponents,\n}\n"],"names":["createTemporaryReferenceSet","renderToReadableStream","decodeReply","decodeAction","decodeFormState","unstable_prerender","prerender","LayoutRouter","RenderFromTemplateContext","workAsyncStorage","workUnitAsyncStorage","actionAsyncStorage","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerSearchParamsForMetadata","createServerParamsForServerSegment","createServerParamsForMetadata","createPrerenderParamsForClientSegment","serverHooks","HTTPAccessFallbackBoundary","createMetadataComponents","patchFetch","_patchFetch","MetadataBoundary","ViewportBoundary","OutletBoundary","preloadStyle","preloadFont","preconnect","Postpone","taintObjectReference","collectSegmentData"],"mappings":"AAAA,6DAA6D;;;;AAc7D,SAASS,gBAAgB,QAAQ,4CAA2C;AAC5E,SAASC,oBAAoB,QAAQ,qCAAoC;AAiBzE,SAASa,cAAcC,WAAW,QAAQ,qBAAoB;;;;;;;;;;;;;;;;;;;;;;AAc9D,0FAA0F;AAC1F,yGAAyG;AACzG,SAASD;IACP,OAAOC,gMAAAA,EAAY;4SACjBf,mBAAAA;gUACAC,uBAAAA;IACF;AACF","ignoreList":[0]}}]
}