{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [NEXT_RSC_UNION_QUERY] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(url: T): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n\n  instance.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;oMAACD,uBAAAA;CAAqB;AAE5C,SAASE,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQH,qBAAsB;QACvC,OAAOE,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BAAkDC,GAAM;IACtE,MAAMC,cAAc,OAAOD,QAAQ;IACnC,MAAME,WAAWD,cAAc,IAAIE,IAAIH,OAAQA;IAE/CE,SAASE,YAAY,CAACC,MAAM,iMAACX,uBAAAA;IAE7B,OAAQO,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/api-utils/web.ts"],"sourcesContent":["// Buffer.byteLength polyfill in the Edge runtime, with only utf8 strings\n// supported at the moment.\nexport function byteLength(payload: string): number {\n  return new TextEncoder().encode(payload).buffer.byteLength\n}\n"],"names":["byteLength","payload","TextEncoder","encode","buffer"],"mappings":"AAAA,yEAAyE;AACzE,2BAA2B;;;;AACpB,SAASA,WAAWC,OAAe;IACxC,OAAO,IAAIC,cAAcC,MAAM,CAACF,SAASG,MAAM,CAACJ,UAAU;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/api-utils/get-cookie-parser.ts"],"sourcesContent":["import type { NextApiRequestCookies } from '.'\n\n/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */\n\nexport function getCookieParser(headers: {\n  [key: string]: string | string[] | null | undefined\n}): () => NextApiRequestCookies {\n  return function parseCookie(): NextApiRequestCookies {\n    const { cookie } = headers\n\n    if (!cookie) {\n      return {}\n    }\n\n    const { parse: parseCookieFn } = require('next/dist/compiled/cookie')\n    return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)\n  }\n}\n"],"names":["getCookieParser","headers","parseCookie","cookie","parse","parseCookieFn","require","Array","isArray","join"],"mappings":"AAEA;;;CAGC,GAED;;;AAAO,SAASA,gBAAgBC,OAE/B;IACC,OAAO,SAASC;QACd,MAAM,EAAEC,MAAM,EAAE,GAAGF;QAEnB,IAAI,CAACE,QAAQ;YACX,OAAO,CAAC;QACV;QAEA,MAAM,EAAEC,OAAOC,aAAa,EAAE,GAAGC,QAAQ;QACzC,OAAOD,cAAcE,MAAMC,OAAO,CAACL,UAAUA,OAAOM,IAAI,CAAC,QAAQN;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  public readonly isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this.isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAaXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,2MAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,gLAACV,+BAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,SAAS,GAAGC,QACf,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEAa,SAAS;QACP,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;YACxB,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,2EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,IAAI,CAACF,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BM,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;QACR;IACF;IAEAC,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACT,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO;YACPa,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 440, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  wrapWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header.toLowerCase())\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags?: string[] | undefined\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  renderResumeDataCache: RenderResumeDataCache | undefined\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    rootParams,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    {},\n    implicitTags,\n    onUpdateCookies,\n    undefined,\n    previewProps,\n    false,\n    undefined\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags: implicitTags ?? [],\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    rootParams,\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies = wrapWithMutableAccessCheck(\n          this.mutableCookies\n        )\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","toLowerCase","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","rootParams","implicitTags","previewProps","isHmrRefresh","serverComponentsHmrCache","renderResumeDataCache","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  isPrefetchRequest?: boolean\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'dynamicIO' | 'authInterrupts'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'shouldWaitOnAllReady'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'dev'\n  > &\n    RequestLifecycleOpts &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n\n  /**\n   * The build ID of the current build.\n   */\n  buildId: string\n}\n\nexport function createWorkStore({\n  page,\n  fallbackRouteParams,\n  renderOpts,\n  requestEndedState,\n  isPrefetchRequest,\n  buildId,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.shouldWaitOnAllReady &&\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n    isPrefetchRequest,\n    buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n\n    afterContext: createAfterContext(renderOpts),\n    dynamicIOEnabled: renderOpts.experimental.dynamicIO,\n    dev: renderOpts.dev ?? false,\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({\n    waitUntil,\n    onClose,\n    onTaskError: onAfterTaskError,\n  })\n}\n"],"names":["AfterContext","normalizeAppPath","createWorkStore","page","fallbackRouteParams","renderOpts","requestEndedState","isPrefetchRequest","buildId","isStaticGeneration","shouldWaitOnAllReady","supportsDynamicResponse","isDraftMode","isServerAction","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","dynamicIOEnabled","experimental","dynamicIO","dev","waitUntil","onClose","onAfterTaskError","onTaskError"],"mappings":";;;AASA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;;;AA+DnE,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACjBC,iBAAiB,EACjBC,OAAO,EACU;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACJ,WAAWK,oBAAoB,IAChC,CAACL,WAAWM,uBAAuB,IACnC,CAACN,WAAWO,WAAW,IACvB,CAACP,WAAWQ,cAAc;IAE5B,MAAMC,QAAmB;QACvBL;QACAN;QACAC;QACAW,QAAOd,sNAAAA,EAAiBE;QACxBa,kBACE,AACA,mDAAmD,kBADkB;QAErEX,WAAWW,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBd,WAAWc,iBAAiB;QAC/CC,cAAcf,WAAWe,YAAY;QACrCC,gBAAgBhB,WAAWiB,UAAU;QACrCC,YAAYlB,WAAWkB,UAAU;QACjCC,sBAAsBnB,WAAWmB,oBAAoB;QAErDZ,aAAaP,WAAWO,WAAW;QAEnCN;QACAC;QACAC;QACAiB,uBAAuBpB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYoB,qBAAqB,KAAI,CAAC;QAC7DC,aAAarB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYqB,WAAW,KAAI;QAExCC,cAAcC,mBAAmBvB;QACjCwB,kBAAkBxB,WAAWyB,YAAY,CAACC,SAAS;QACnDC,KAAK3B,WAAW2B,GAAG,IAAI;IACzB;IAEA,sFAAsF;IACtF3B,WAAWS,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASc,mBAAmBvB,UAAgC;IAC1D,MAAM,EAAE4B,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAG9B;IACjD,OAAO,uLAAIL,eAAAA,CAAa;QACtBiC;QACAC;QACAE,aAAaD;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  public readonly isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this.isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAaXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,2MAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,gLAACV,+BAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,SAAS,GAAGC,QACf,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEAa,SAAS;QACP,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;YACxB,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,2EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,IAAI,CAACF,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BM,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;QACR;IACF;IAEAC,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACT,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO;YACPa,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  wrapWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header.toLowerCase())\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags?: string[] | undefined\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n  renderResumeDataCache: RenderResumeDataCache | undefined\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    rootParams,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    {},\n    implicitTags,\n    onUpdateCookies,\n    undefined,\n    previewProps,\n    false,\n    undefined\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  rootParams: Params,\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags: implicitTags ?? [],\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    rootParams,\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies = wrapWithMutableAccessCheck(\n          this.mutableCookies\n        )\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","toLowerCase","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","rootParams","implicitTags","previewProps","isHmrRefresh","serverComponentsHmrCache","renderResumeDataCache","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  isPrefetchRequest?: boolean\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'dynamicIO' | 'authInterrupts'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'shouldWaitOnAllReady'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'dev'\n  > &\n    RequestLifecycleOpts &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n\n  /**\n   * The build ID of the current build.\n   */\n  buildId: string\n}\n\nexport function createWorkStore({\n  page,\n  fallbackRouteParams,\n  renderOpts,\n  requestEndedState,\n  isPrefetchRequest,\n  buildId,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.shouldWaitOnAllReady &&\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n    isPrefetchRequest,\n    buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n\n    afterContext: createAfterContext(renderOpts),\n    dynamicIOEnabled: renderOpts.experimental.dynamicIO,\n    dev: renderOpts.dev ?? false,\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(renderOpts: RequestLifecycleOpts): AfterContext {\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({\n    waitUntil,\n    onClose,\n    onTaskError: onAfterTaskError,\n  })\n}\n"],"names":["AfterContext","normalizeAppPath","createWorkStore","page","fallbackRouteParams","renderOpts","requestEndedState","isPrefetchRequest","buildId","isStaticGeneration","shouldWaitOnAllReady","supportsDynamicResponse","isDraftMode","isServerAction","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","dynamicIOEnabled","experimental","dynamicIO","dev","waitUntil","onClose","onAfterTaskError","onTaskError"],"mappings":";;;AASA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;;;AA+DnE,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACjBC,iBAAiB,EACjBC,OAAO,EACU;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACJ,WAAWK,oBAAoB,IAChC,CAACL,WAAWM,uBAAuB,IACnC,CAACN,WAAWO,WAAW,IACvB,CAACP,WAAWQ,cAAc;IAE5B,MAAMC,QAAmB;QACvBL;QACAN;QACAC;QACAW,QAAOd,sNAAAA,EAAiBE;QACxBa,kBACE,AACA,mDAAmD,kBADkB;QAErEX,WAAWW,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBd,WAAWc,iBAAiB;QAC/CC,cAAcf,WAAWe,YAAY;QACrCC,gBAAgBhB,WAAWiB,UAAU;QACrCC,YAAYlB,WAAWkB,UAAU;QACjCC,sBAAsBnB,WAAWmB,oBAAoB;QAErDZ,aAAaP,WAAWO,WAAW;QAEnCN;QACAC;QACAC;QACAiB,uBAAuBpB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYoB,qBAAqB,KAAI,CAAC;QAC7DC,aAAarB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYqB,WAAW,KAAI;QAExCC,cAAcC,mBAAmBvB;QACjCwB,kBAAkBxB,WAAWyB,YAAY,CAACC,SAAS;QACnDC,KAAK3B,WAAW2B,GAAG,IAAI;IACzB;IAEA,sFAAsF;IACtF3B,WAAWS,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASc,mBAAmBvB,UAAgC;IAC1D,MAAM,EAAE4B,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAG9B;IACjD,OAAO,uLAAIL,eAAAA,CAAa;QACtBiC;QACAC;QACAE,aAAaD;IACf;AACF","ignoreList":[0]}},
    {"offset": {"line": 887, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/after/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'revalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    revalidatedTags: store.revalidatedTags ? [...store.revalidatedTags] : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTags = new Set(prev.revalidatedTags)\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function executeRevalidates(\n  workStore: WorkStore,\n  {\n    revalidatedTags,\n    pendingRevalidates,\n    pendingRevalidateWrites,\n  }: RevalidationState\n) {\n  return Promise.all([\n    workStore.incrementalCache?.revalidateTag(revalidatedTags),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","revalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTags","Set","prevRevalidateWrites","filter","tag","has","Object","fromEntries","entries","key","promise","workStore","Promise","all","incrementalCache","revalidateTag","values"],"mappings":"AAEA,kFAAkF,GAClF;;;AAAO,eAAeA,uBACpBC,KAA4B,EAC5BC,QAA0B;IAE1B,IAAI,CAACD,OAAO;QACV,OAAOC;IACT;IACA,+FAA+F;IAC/F,yFAAyF;IACzF,MAAMC,yBAAyBC,uBAAuBH;IACtD,IAAI;QACF,OAAO,MAAMC;IACf,SAAU;QACR,qFAAqF;QACrF,MAAMG,iBAAiBC,sBACrBH,wBACAC,uBAAuBH;QAEzB,MAAMM,mBAAmBN,OAAOI;IAClC;AACF;AASA,SAASD,uBAAuBH,KAAgB;IAC9C,OAAO;QACLO,iBAAiBP,MAAMO,eAAe,GAAG;eAAIP,MAAMO,eAAe;SAAC,GAAG,EAAE;QACxEC,oBAAoB;YAAE,GAAGR,MAAMQ,kBAAkB;QAAC;QAClDC,yBAAyBT,MAAMS,uBAAuB,GAClD;eAAIT,MAAMS,uBAAuB;SAAC,GAClC,EAAE;IACR;AACF;AAEA,SAASJ,sBACPK,IAAuB,EACvBC,IAAuB;IAEvB,MAAMC,WAAW,IAAIC,IAAIH,KAAKH,eAAe;IAC7C,MAAMO,uBAAuB,IAAID,IAAIH,KAAKD,uBAAuB;IACjE,OAAO;QACLF,iBAAiBI,KAAKJ,eAAe,CAACQ,MAAM,CAAC,CAACC,MAAQ,CAACJ,SAASK,GAAG,CAACD;QACpER,oBAAoBU,OAAOC,WAAW,CACpCD,OAAOE,OAAO,CAACT,KAAKH,kBAAkB,EAAEO,MAAM,CAC5C,CAAC,CAACM,IAAI,GAAK,CAAEA,CAAAA,OAAOX,KAAKF,kBAAiB;QAG9CC,yBAAyBE,KAAKF,uBAAuB,CAACM,MAAM,CAC1D,CAACO,UAAY,CAACR,qBAAqBG,GAAG,CAACK;IAE3C;AACF;AAEA,eAAehB,mBACbiB,SAAoB,EACpB,EACEhB,eAAe,EACfC,kBAAkB,EAClBC,uBAAuB,EACL;QAGlBc;IADF,OAAOC,QAAQC,GAAG,CAAC;SACjBF,8BAAAA,UAAUG,gBAAgB,KAAA,OAAA,KAAA,IAA1BH,4BAA4BI,aAAa,CAACpB;WACvCW,OAAOU,MAAM,CAACpB;WACdC;KACJ;AACH","ignoreList":[0]}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose']\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose']\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(\n        task.catch((error) => this.reportTaskError('promise', error))\n      )\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error('`after()`: Argument must be a promise or a function')\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      this.workUnitStores.add(workUnitStore)\n    }\n\n    const afterTaskStore = afterTaskAsyncStorage.getStore()\n\n    // This is used for checking if request APIs can be called inside `after`.\n    // Note that we need to check the phase in which the *topmost* `after` was called (which should be \"action\"),\n    // not the current phase (which might be \"after\" if we're in a nested after).\n    // Otherwise, we might allow `after(() => headers())`, but not `after(() => after(() => headers()))`.\n    const rootTaskSpawnPhase = afterTaskStore\n      ? afterTaskStore.rootTaskSpawnPhase // nested after\n      : workUnitStore?.phase // topmost after\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =>\n          callback()\n        )\n      } catch (error) {\n        this.reportTaskError('function', error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      taskKind === 'promise'\n        ? `A promise passed to \\`after()\\` rejected:`\n        : `An error occurred in a function passed to \\`after()\\`:`,\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","afterTaskAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","afterTaskStore","rootTaskSpawnPhase","phase","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","run","Promise","resolve","runCallbacks","size","workStore","start","onIdle","taskKind","console","handlerError","cause"],"mappings":";;;AAAA,OAAOA,kBAAkB,6BAA4B;AAGrD,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,UAAU,QAAQ,+BAA8B;AACzD,SAASC,gBAAgB,QAAQ,4CAA2C;;AAC5E,SAASC,sBAAsB,QAAQ,uBAAsB;AAC7D,SAASC,YAAY,QAAQ,oCAAmC;;AAChE,SACEC,oBAAoB,QAEf,iDAAgD;;AACvD,SAASC,qBAAqB,QAAQ,kDAAiD;;;;;;;;;AAQhF,MAAMC;IASXC,YAAY,EAAEC,SAAS,EAAEC,OAAO,EAAEC,WAAW,EAAoB,CAAE;aAF3DC,cAAAA,GAAiB,IAAIC;QAG3B,IAAI,CAACJ,SAAS,GAAGA;QACjB,IAAI,CAACC,OAAO,GAAGA;QACf,IAAI,CAACC,WAAW,GAAGA;QAEnB,IAAI,CAACG,aAAa,GAAG,2KAAIf,WAAAA;QACzB,IAAI,CAACe,aAAa,CAACC,KAAK;IAC1B;IAEOC,MAAMC,IAAe,EAAQ;QAClC,sLAAIhB,cAAAA,EAAWgB,OAAO;YACpB,IAAI,CAAC,IAAI,CAACR,SAAS,EAAE;gBACnBS;YACF;YACA,IAAI,CAACT,SAAS,CACZQ,KAAKE,KAAK,CAAC,CAACC,QAAU,IAAI,CAACC,eAAe,CAAC,WAAWD;QAE1D,OAAO,IAAI,OAAOH,SAAS,YAAY;YACrC,iCAAiC;YACjC,IAAI,CAACK,WAAW,CAACL;QACnB,OAAO;YACL,MAAM,OAAA,cAAgE,CAAhE,IAAIM,MAAM,wDAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA+D;QACvE;IACF;IAEQD,YAAYE,QAAuB,EAAE;QAC3C,mFAAmF;QACnF,IAAI,CAAC,IAAI,CAACf,SAAS,EAAE;YACnBS;QACF;QAEA,MAAMO,gBAAgBpB,yTAAAA,CAAqBqB,QAAQ;QACnD,IAAID,eAAe;YACjB,IAAI,CAACb,cAAc,CAACe,GAAG,CAACF;QAC1B;QAEA,MAAMG,sTAAiBtB,wBAAAA,CAAsBoB,QAAQ;QAErD,0EAA0E;QAC1E,6GAA6G;QAC7G,6EAA6E;QAC7E,qGAAqG;QACrG,MAAMG,qBAAqBD,iBACvBA,eAAeC,kBAAkB,CAAC,eAAe;WACjDJ,iBAAAA,OAAAA,KAAAA,IAAAA,cAAeK,KAAK,CAAC,gBAAgB;;QAEzC,gCAAgC;QAChC,IAAI,CAAC,IAAI,CAACC,0BAA0B,EAAE;YACpC,IAAI,CAACA,0BAA0B,GAAG,IAAI,CAACC,mBAAmB;YAC1D,IAAI,CAACvB,SAAS,CAAC,IAAI,CAACsB,0BAA0B;QAChD;QAEA,qGAAqG;QACrG,0FAA0F;QAC1F,qBAAqB;QACrB,eAAe;QACf,cAAc;QACd,MAAME,mBAAkB7B,sNAAAA,EAAa;YACnC,IAAI;gBACF,2SAAME,wBAAAA,CAAsB4B,GAAG,CAAC;oBAAEL;gBAAmB,GAAG,IACtDL;YAEJ,EAAE,OAAOJ,OAAO;gBACd,IAAI,CAACC,eAAe,CAAC,YAAYD;YACnC;QACF;QAEA,IAAI,CAACN,aAAa,CAACa,GAAG,CAACM;IACzB;IAEA,MAAcD,sBAAsB;QAClC,MAAM,IAAIG,QAAc,CAACC,UAAY,IAAI,CAAC1B,OAAO,CAAE0B;QACnD,OAAO,IAAI,CAACC,YAAY;IAC1B;IAEA,MAAcA,eAA8B;QAC1C,IAAI,IAAI,CAACvB,aAAa,CAACwB,IAAI,KAAK,GAAG;QAEnC,KAAK,MAAMb,iBAAiB,IAAI,CAACb,cAAc,CAAE;YAC/Ca,cAAcK,KAAK,GAAG;QACxB;QAEA,MAAMS,8RAAYrC,mBAAAA,CAAiBwB,QAAQ;QAC3C,IAAI,CAACa,WAAW;YACd,MAAM,OAAA,cAAoE,CAApE,uLAAIvC,iBAAAA,CAAe,mDAAnB,qBAAA;uBAAA;4BAAA;8BAAA;YAAmE;QAC3E;QAEA,OAAOG,qNAAAA,EAAuBoC,WAAW;YACvC,IAAI,CAACzB,aAAa,CAAC0B,KAAK;YACxB,OAAO,IAAI,CAAC1B,aAAa,CAAC2B,MAAM;QAClC;IACF;IAEQpB,gBAAgBqB,QAAgC,EAAEtB,KAAc,EAAE;QACxE,iGAAiG;QACjG,qEAAqE;QACrEuB,QAAQvB,KAAK,CACXsB,aAAa,YACT,CAAC,yCAAyC,CAAC,GAC3C,CAAC,sDAAsD,CAAC,EAC5DtB;QAEF,IAAI,IAAI,CAACT,WAAW,EAAE;YACpB,2FAA2F;YAC3F,IAAI;gBACF,IAAI,CAACA,WAAW,IAAA,OAAA,KAAA,IAAhB,IAAI,CAACA,WAAW,CAAA,IAAA,CAAhB,IAAI,EAAeS;YACrB,EAAE,OAAOwB,cAAc;gBACrBD,QAAQvB,KAAK,CACX,OAAA,cAKC,CALD,uLAAIpB,iBAAAA,CACF,2EACA;oBACE6C,OAAOD;gBACT,IAJF,qBAAA;2BAAA;gCAAA;kCAAA;gBAKA;YAEJ;QACF;IACF;AACF;AAEA,SAAS1B;IACP,MAAM,OAAA,cAEL,CAFK,IAAIK,MACR,wGADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}},
    {"offset": {"line": 1082, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/after/builtin-request-context.ts"],"sourcesContent":["import { createAsyncLocalStorage } from '../app-render/async-local-storage'\n\nexport function getBuiltinRequestContext():\n  | BuiltinRequestContextValue\n  | undefined {\n  const _globalThis = globalThis as GlobalThisWithRequestContext\n  const ctx = _globalThis[NEXT_REQUEST_CONTEXT_SYMBOL]\n  return ctx?.get()\n}\n\nconst NEXT_REQUEST_CONTEXT_SYMBOL = Symbol.for('@next/request-context')\n\ntype GlobalThisWithRequestContext = typeof globalThis & {\n  [NEXT_REQUEST_CONTEXT_SYMBOL]?: BuiltinRequestContext\n}\n\n/** A request context provided by the platform. */\nexport type BuiltinRequestContext = {\n  get(): BuiltinRequestContextValue | undefined\n}\n\nexport type RunnableBuiltinRequestContext = BuiltinRequestContext & {\n  run<T>(value: BuiltinRequestContextValue, callback: () => T): T\n}\n\nexport type BuiltinRequestContextValue = {\n  waitUntil?: WaitUntil\n}\nexport type WaitUntil = (promise: Promise<any>) => void\n\n/** \"@next/request-context\" has a different signature from AsyncLocalStorage,\n * matching [AsyncContext.Variable](https://github.com/tc39/proposal-async-context).\n * We don't need a full AsyncContext adapter here, just having `.get()` is enough\n */\nexport function createLocalRequestContext(): RunnableBuiltinRequestContext {\n  const storage = createAsyncLocalStorage<BuiltinRequestContextValue>()\n  return {\n    get: () => storage.getStore(),\n    run: (value, callback) => storage.run(value, callback),\n  }\n}\n"],"names":["createAsyncLocalStorage","getBuiltinRequestContext","_globalThis","globalThis","ctx","NEXT_REQUEST_CONTEXT_SYMBOL","get","Symbol","for","createLocalRequestContext","storage","getStore","run","value","callback"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,oCAAmC;;AAEpE,SAASC;IAGd,MAAMC,cAAcC;IACpB,MAAMC,MAAMF,WAAW,CAACG,4BAA4B;IACpD,OAAOD,OAAAA,OAAAA,KAAAA,IAAAA,IAAKE,GAAG;AACjB;AAEA,MAAMD,8BAA8BE,OAAOC,GAAG,CAAC;AAwBxC,SAASC;IACd,MAAMC,kNAAUV,0BAAAA;IAChB,OAAO;QACLM,KAAK,IAAMI,QAAQC,QAAQ;QAC3BC,KAAK,CAACC,OAAOC,WAAaJ,QAAQE,GAAG,CAACC,OAAOC;IAC/C;AACF","ignoreList":[0]}},
    {"offset": {"line": 1107, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/after/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'revalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    revalidatedTags: store.revalidatedTags ? [...store.revalidatedTags] : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTags = new Set(prev.revalidatedTags)\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function executeRevalidates(\n  workStore: WorkStore,\n  {\n    revalidatedTags,\n    pendingRevalidates,\n    pendingRevalidateWrites,\n  }: RevalidationState\n) {\n  return Promise.all([\n    workStore.incrementalCache?.revalidateTag(revalidatedTags),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","revalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTags","Set","prevRevalidateWrites","filter","tag","has","Object","fromEntries","entries","key","promise","workStore","Promise","all","incrementalCache","revalidateTag","values"],"mappings":"AAEA,kFAAkF,GAClF;;;AAAO,eAAeA,uBACpBC,KAA4B,EAC5BC,QAA0B;IAE1B,IAAI,CAACD,OAAO;QACV,OAAOC;IACT;IACA,+FAA+F;IAC/F,yFAAyF;IACzF,MAAMC,yBAAyBC,uBAAuBH;IACtD,IAAI;QACF,OAAO,MAAMC;IACf,SAAU;QACR,qFAAqF;QACrF,MAAMG,iBAAiBC,sBACrBH,wBACAC,uBAAuBH;QAEzB,MAAMM,mBAAmBN,OAAOI;IAClC;AACF;AASA,SAASD,uBAAuBH,KAAgB;IAC9C,OAAO;QACLO,iBAAiBP,MAAMO,eAAe,GAAG;eAAIP,MAAMO,eAAe;SAAC,GAAG,EAAE;QACxEC,oBAAoB;YAAE,GAAGR,MAAMQ,kBAAkB;QAAC;QAClDC,yBAAyBT,MAAMS,uBAAuB,GAClD;eAAIT,MAAMS,uBAAuB;SAAC,GAClC,EAAE;IACR;AACF;AAEA,SAASJ,sBACPK,IAAuB,EACvBC,IAAuB;IAEvB,MAAMC,WAAW,IAAIC,IAAIH,KAAKH,eAAe;IAC7C,MAAMO,uBAAuB,IAAID,IAAIH,KAAKD,uBAAuB;IACjE,OAAO;QACLF,iBAAiBI,KAAKJ,eAAe,CAACQ,MAAM,CAAC,CAACC,MAAQ,CAACJ,SAASK,GAAG,CAACD;QACpER,oBAAoBU,OAAOC,WAAW,CACpCD,OAAOE,OAAO,CAACT,KAAKH,kBAAkB,EAAEO,MAAM,CAC5C,CAAC,CAACM,IAAI,GAAK,CAAEA,CAAAA,OAAOX,KAAKF,kBAAiB;QAG9CC,yBAAyBE,KAAKF,uBAAuB,CAACM,MAAM,CAC1D,CAACO,UAAY,CAACR,qBAAqBG,GAAG,CAACK;IAE3C;AACF;AAEA,eAAehB,mBACbiB,SAAoB,EACpB,EACEhB,eAAe,EACfC,kBAAkB,EAClBC,uBAAuB,EACL;QAGlBc;IADF,OAAOC,QAAQC,GAAG,CAAC;SACjBF,8BAAAA,UAAUG,gBAAgB,KAAA,OAAA,KAAA,IAA1BH,4BAA4BI,aAAa,CAACpB;WACvCW,OAAOU,MAAM,CAACpB;WACdC;KACJ;AACH","ignoreList":[0]}},
    {"offset": {"line": 1161, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose']\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose']\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(\n        task.catch((error) => this.reportTaskError('promise', error))\n      )\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error('`after()`: Argument must be a promise or a function')\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      this.workUnitStores.add(workUnitStore)\n    }\n\n    const afterTaskStore = afterTaskAsyncStorage.getStore()\n\n    // This is used for checking if request APIs can be called inside `after`.\n    // Note that we need to check the phase in which the *topmost* `after` was called (which should be \"action\"),\n    // not the current phase (which might be \"after\" if we're in a nested after).\n    // Otherwise, we might allow `after(() => headers())`, but not `after(() => after(() => headers()))`.\n    const rootTaskSpawnPhase = afterTaskStore\n      ? afterTaskStore.rootTaskSpawnPhase // nested after\n      : workUnitStore?.phase // topmost after\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await afterTaskAsyncStorage.run({ rootTaskSpawnPhase }, () =>\n          callback()\n        )\n      } catch (error) {\n        this.reportTaskError('function', error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(taskKind: 'promise' | 'function', error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      taskKind === 'promise'\n        ? `A promise passed to \\`after()\\` rejected:`\n        : `An error occurred in a function passed to \\`after()\\`:`,\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","afterTaskAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","afterTaskStore","rootTaskSpawnPhase","phase","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","run","Promise","resolve","runCallbacks","size","workStore","start","onIdle","taskKind","console","handlerError","cause"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1302, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { CacheControl, Revalidate } from '../lib/cache-control'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport interface IncrementalResponseCacheEntry {\n  cacheControl?: CacheControl\n  /**\n   * timestamp in milliseconds to revalidate after\n   */\n  revalidateAfter?: Revalidate\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n  value: Exclude<IncrementalCacheValue, CachedFetchValue> | null\n}\n\nexport interface IncrementalFetchCacheEntry {\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  value: CachedFetchValue\n}\n\nexport type IncrementalCacheEntry =\n  | IncrementalResponseCacheEntry\n  | IncrementalFetchCacheEntry\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  cacheControl?: CacheControl\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalResponseCacheEntry | null\n  isRevalidating?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface GetIncrementalFetchCacheContext {\n  kind: IncrementalCacheKind.FETCH\n  revalidate?: Revalidate\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  softTags?: string[]\n}\n\nexport interface GetIncrementalResponseCacheContext {\n  kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback: boolean\n}\n\nexport interface SetIncrementalFetchCacheContext {\n  fetchCache: true\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n}\n\nexport interface SetIncrementalResponseCacheContext {\n  fetchCache?: false\n  cacheControl?: CacheControl\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback?: boolean\n}\n\nexport interface IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n\nexport interface IncrementalCache extends IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;AA+CO,IAAWA,kBAAAA,WAAAA,GAAAA,SAAAA,eAAAA;;;;;;;WAAAA;MAOjB;AA2IM,IAAWC,uBAAAA,WAAAA,GAAAA,SAAAA,oBAAAA;;;;;;WAAAA;MAMjB","ignoreList":[0]}},
    {"offset": {"line": 1329, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalResponseCacheEntry,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalResponseCacheEntry> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalResponseCacheEntry | null\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    cacheControl: response.cacheControl,\n    isFallback: response.isFallback,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(response.value.html),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(response.value.html),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH> {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    default:\n      throw new Error(`Unexpected route kind ${routeKind}`)\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","isMiss","isStale","cacheControl","isFallback","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE","Error"],"mappings":";;;;;AAAA,SACEA,eAAe,EACfC,oBAAoB,QAKf,UAAS;AAEhB,OAAOC,kBAAkB,mBAAkB;AAC3C,SAASC,SAAS,QAAQ,gBAAe;;;;AAElC,eAAeC,uBACpBC,UAA8B;QAK1BA,mBAQIA;IAXR,OAAO;QACL,GAAGA,UAAU;QACbC,OACED,CAAAA,CAAAA,oBAAAA,WAAWC,KAAK,KAAA,OAAA,KAAA,IAAhBD,kBAAkBE,IAAI,0LAAKP,kBAAAA,CAAgBQ,KAAK,GAC5C;YACED,0LAAMP,kBAAAA,CAAgBQ,KAAK;YAC3BC,MAAM,MAAMJ,WAAWC,KAAK,CAACG,IAAI,CAACC,iBAAiB,CAAC;YACpDC,UAAUN,WAAWC,KAAK,CAACK,QAAQ;YACnCC,SAASP,WAAWC,KAAK,CAACM,OAAO;YACjCC,QAAQR,WAAWC,KAAK,CAACO,MAAM;QACjC,IACAR,CAAAA,CAAAA,qBAAAA,WAAWC,KAAK,KAAA,OAAA,KAAA,IAAhBD,mBAAkBE,IAAI,0LAAKP,kBAAAA,CAAgBc,QAAQ,GACjD;YACEP,0LAAMP,kBAAAA,CAAgBc,QAAQ;YAC9BL,MAAM,MAAMJ,WAAWC,KAAK,CAACG,IAAI,CAACC,iBAAiB,CAAC;YACpDK,WAAWV,WAAWC,KAAK,CAACS,SAAS;YACrCC,SAASX,WAAWC,KAAK,CAACU,OAAO;YACjCJ,SAASP,WAAWC,KAAK,CAACM,OAAO;YACjCC,QAAQR,WAAWC,KAAK,CAACO,MAAM;YAC/BI,aAAaZ,WAAWC,KAAK,CAACW,WAAW;QAC3C,IACAZ,WAAWC,KAAK;IAC1B;AACF;AAEO,eAAeY,qBACpBC,QAA8C;QAU1CA,iBAQIA;IAhBR,IAAI,CAACA,UAAU,OAAO;IAEtB,OAAO;QACLC,QAAQD,SAASC,MAAM;QACvBC,SAASF,SAASE,OAAO;QACzBC,cAAcH,SAASG,YAAY;QACnCC,YAAYJ,SAASI,UAAU;QAC/BjB,OACEa,CAAAA,CAAAA,kBAAAA,SAASb,KAAK,KAAA,OAAA,KAAA,IAAda,gBAAgBZ,IAAI,0LAAKP,kBAAAA,CAAgBQ,KAAK,GACzC;YACCD,0LAAMP,kBAAAA,CAAgBQ,KAAK;YAC3BC,gLAAMP,UAAAA,CAAasB,UAAU,CAACL,SAASb,KAAK,CAACG,IAAI;YACjDE,UAAUQ,SAASb,KAAK,CAACK,QAAQ;YACjCC,SAASO,SAASb,KAAK,CAACM,OAAO;YAC/BC,QAAQM,SAASb,KAAK,CAACO,MAAM;QAC/B,IACAM,CAAAA,CAAAA,mBAAAA,SAASb,KAAK,KAAA,OAAA,KAAA,IAAda,iBAAgBZ,IAAI,0LAAKP,kBAAAA,CAAgBc,QAAQ,GAC9C;YACCP,0LAAMP,kBAAAA,CAAgBc,QAAQ;YAC9BL,gLAAMP,UAAAA,CAAasB,UAAU,CAACL,SAASb,KAAK,CAACG,IAAI;YACjDO,SAASG,SAASb,KAAK,CAACU,OAAO;YAC/BJ,SAASO,SAASb,KAAK,CAACM,OAAO;YAC/BC,QAAQM,SAASb,KAAK,CAACO,MAAM;YAC7BE,WAAWI,SAASb,KAAK,CAACS,SAAS;YACnCE,aAAaE,SAASb,KAAK,CAACW,WAAW;QACzC,IACAE,SAASb,KAAK;IACxB;AACF;AAEO,SAASmB,gCACdC,SAAoB;IAEpB,OAAQA;QACN,4KAAKvB,YAAAA,CAAUK,KAAK;YAClB,2LAAOP,uBAAAA,CAAqBO,KAAK;QACnC,4KAAKL,YAAAA,CAAUW,QAAQ;YACrB,2LAAOb,uBAAAA,CAAqBa,QAAQ;QACtC,4KAAKX,YAAAA,CAAUwB,KAAK;YAClB,2LAAO1B,uBAAAA,CAAqB0B,KAAK;QACnC,4KAAKxB,YAAAA,CAAUyB,SAAS;YACtB,2LAAO3B,uBAAAA,CAAqB2B,SAAS;QACvC;YACE,MAAM,OAAA,cAA+C,CAA/C,IAAIC,MAAM,CAAC,sBAAsB,EAAEH,WAAW,GAA9C,qBAAA;uBAAA;4BAAA;8BAAA;YAA8C;IACxD;AACF","ignoreList":[0]}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalResponseCacheEntry | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n    } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n\n        let resolved = false\n        let cachedResponse: IncrementalResponseCacheEntry | null = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kind,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            resolve(cachedResponse)\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator({\n            hasResolved: resolved,\n            previousCacheEntry: cachedResponse,\n            isRevalidating: true,\n          })\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          // We want to persist the result only if it has a cache control value\n          // defined.\n          if (resolveValue.cacheControl) {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                cacheControl: resolveValue.cacheControl,\n                isRoutePPREnabled,\n                isFallback,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a path is erroring we automatically re-set the existing cache\n          // with new revalidate and expire times to prevent non-stop retrying.\n          if (cachedResponse?.cacheControl) {\n            const newRevalidate = Math.min(\n              Math.max(cachedResponse.cacheControl.revalidate || 3, 3),\n              30\n            )\n\n            const newExpire =\n              cachedResponse.cacheControl.expire === undefined\n                ? undefined\n                : Math.max(\n                    newRevalidate + 3,\n                    cachedResponse.cacheControl.expire\n                  )\n\n            await incrementalCache.set(key, cachedResponse.value, {\n              cacheControl: { revalidate: newRevalidate, expire: newExpire },\n              isRoutePPREnabled,\n              isFallback,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["Batcher","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","hasResolved","previousCacheEntry","incrementalCache","isFallback","isRoutePPREnabled","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kind","routeKind","resolved","cachedResponse","isStale","isPrefetch","cacheEntry","isRevalidating","undefined","resolveValue","isMiss","cacheControl","set","value","err","newRevalidate","Math","min","max","revalidate","newExpire","expire","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1566, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/web.ts"],"sourcesContent":["import { DetachedPromise } from '../../lib/detached-promise'\nimport type { ResponseCacheEntry, ResponseGenerator } from './types'\n\n/**\n * In the web server, there is currently no incremental cache provided and we\n * always SSR the page.\n */\nexport default class WebResponseCache {\n  pendingResponses: Map<string, Promise<ResponseCacheEntry | null>>\n  previousCacheItem?: {\n    key: string\n    entry: ResponseCacheEntry | null\n    expiresAt: number\n  }\n  minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    this.pendingResponses = new Map()\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    Object.assign(this, { minimalMode })\n  }\n\n  public get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: any\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // ensure on-demand revalidate doesn't block normal requests\n    const pendingResponseKey = key\n      ? `${key}-${context.isOnDemandRevalidate ? '1' : '0'}`\n      : null\n\n    const pendingResponse = pendingResponseKey\n      ? this.pendingResponses.get(pendingResponseKey)\n      : null\n    if (pendingResponse) {\n      return pendingResponse\n    }\n\n    const {\n      promise,\n      resolve: resolver,\n      reject: rejecter,\n    } = new DetachedPromise<ResponseCacheEntry | null>()\n    if (pendingResponseKey) {\n      this.pendingResponses.set(pendingResponseKey, promise)\n    }\n\n    let hasResolved = false\n    const resolve = (cacheEntry: ResponseCacheEntry | null) => {\n      if (pendingResponseKey) {\n        // Ensure all reads from the cache get the latest value.\n        this.pendingResponses.set(\n          pendingResponseKey,\n          Promise.resolve(cacheEntry)\n        )\n      }\n      if (!hasResolved) {\n        hasResolved = true\n        resolver(cacheEntry)\n      }\n    }\n\n    // we keep the previous cache entry around to leverage\n    // when the incremental cache is disabled in minimal mode\n    if (\n      pendingResponseKey &&\n      this.minimalMode &&\n      this.previousCacheItem?.key === pendingResponseKey &&\n      this.previousCacheItem.expiresAt > Date.now()\n    ) {\n      resolve(this.previousCacheItem.entry)\n      this.pendingResponses.delete(pendingResponseKey)\n      return promise\n    }\n\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    ;(async () => {\n      try {\n        const cacheEntry = await responseGenerator({ hasResolved })\n        const resolveValue =\n          cacheEntry === null\n            ? null\n            : {\n                ...cacheEntry,\n                isMiss: true,\n              }\n\n        // for on-demand revalidate wait to resolve until cache is set\n        if (!context.isOnDemandRevalidate) {\n          resolve(resolveValue)\n        }\n\n        if (key && cacheEntry && cacheEntry.cacheControl) {\n          this.previousCacheItem = {\n            key: pendingResponseKey || key,\n            entry: cacheEntry,\n            expiresAt: Date.now() + 1000,\n          }\n        } else {\n          this.previousCacheItem = undefined\n        }\n\n        if (context.isOnDemandRevalidate) {\n          resolve(resolveValue)\n        }\n      } catch (err) {\n        // while revalidating in the background we can't reject as\n        // we already resolved the cache entry so log the error here\n        if (hasResolved) {\n          console.error(err)\n        } else {\n          rejecter(err as Error)\n        }\n      } finally {\n        if (pendingResponseKey) {\n          this.pendingResponses.delete(pendingResponseKey)\n        }\n      }\n    })()\n    return promise\n  }\n}\n"],"names":["DetachedPromise","WebResponseCache","constructor","minimalMode","pendingResponses","Map","Object","assign","get","key","responseGenerator","context","pendingResponseKey","isOnDemandRevalidate","pendingResponse","promise","resolve","resolver","reject","rejecter","set","hasResolved","cacheEntry","Promise","previousCacheItem","expiresAt","Date","now","entry","delete","resolveValue","isMiss","cacheControl","undefined","err","console","error"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,6BAA4B;;AAO7C,MAAMC;IASnBC,YAAYC,WAAoB,CAAE;QAChC,IAAI,CAACC,gBAAgB,GAAG,IAAIC;QAC5B,4EAA4E;QAC5E,qEAAqE;QACrEC,OAAOC,MAAM,CAAC,IAAI,EAAE;YAAEJ;QAAY;IACpC;IAEOK,IACLC,GAAkB,EAClBC,iBAAoC,EACpCC,OAIC,EACmC;YA0ClC;QAzCF,4DAA4D;QAC5D,MAAMC,qBAAqBH,MACvB,GAAGA,IAAI,CAAC,EAAEE,QAAQE,oBAAoB,GAAG,MAAM,KAAK,GACpD;QAEJ,MAAMC,kBAAkBF,qBACpB,IAAI,CAACR,gBAAgB,CAACI,GAAG,CAACI,sBAC1B;QACJ,IAAIE,iBAAiB;YACnB,OAAOA;QACT;QAEA,MAAM,EACJC,OAAO,EACPC,SAASC,QAAQ,EACjBC,QAAQC,QAAQ,EACjB,GAAG,8KAAInB,kBAAAA;QACR,IAAIY,oBAAoB;YACtB,IAAI,CAACR,gBAAgB,CAACgB,GAAG,CAACR,oBAAoBG;QAChD;QAEA,IAAIM,cAAc;QAClB,MAAML,UAAU,CAACM;YACf,IAAIV,oBAAoB;gBACtB,wDAAwD;gBACxD,IAAI,CAACR,gBAAgB,CAACgB,GAAG,CACvBR,oBACAW,QAAQP,OAAO,CAACM;YAEpB;YACA,IAAI,CAACD,aAAa;gBAChBA,cAAc;gBACdJ,SAASK;YACX;QACF;QAEA,sDAAsD;QACtD,yDAAyD;QACzD,IACEV,sBACA,IAAI,CAACT,WAAW,IAChB,CAAA,CAAA,0BAAA,IAAI,CAACqB,iBAAiB,KAAA,OAAA,KAAA,IAAtB,wBAAwBf,GAAG,MAAKG,sBAChC,IAAI,CAACY,iBAAiB,CAACC,SAAS,GAAGC,KAAKC,GAAG,IAC3C;YACAX,QAAQ,IAAI,CAACQ,iBAAiB,CAACI,KAAK;YACpC,IAAI,CAACxB,gBAAgB,CAACyB,MAAM,CAACjB;YAC7B,OAAOG;QACT;QAEA,sEAAsE;QACtE,uEAAuE;QACvE,oDAAoD;;QAClD,CAAA;YACA,IAAI;gBACF,MAAMO,aAAa,MAAMZ,kBAAkB;oBAAEW;gBAAY;gBACzD,MAAMS,eACJR,eAAe,OACX,OACA;oBACE,GAAGA,UAAU;oBACbS,QAAQ;gBACV;gBAEN,8DAA8D;gBAC9D,IAAI,CAACpB,QAAQE,oBAAoB,EAAE;oBACjCG,QAAQc;gBACV;gBAEA,IAAIrB,OAAOa,cAAcA,WAAWU,YAAY,EAAE;oBAChD,IAAI,CAACR,iBAAiB,GAAG;wBACvBf,KAAKG,sBAAsBH;wBAC3BmB,OAAON;wBACPG,WAAWC,KAAKC,GAAG,KAAK;oBAC1B;gBACF,OAAO;oBACL,IAAI,CAACH,iBAAiB,GAAGS;gBAC3B;gBAEA,IAAItB,QAAQE,oBAAoB,EAAE;oBAChCG,QAAQc;gBACV;YACF,EAAE,OAAOI,KAAK;gBACZ,0DAA0D;gBAC1D,4DAA4D;gBAC5D,IAAIb,aAAa;oBACfc,QAAQC,KAAK,CAACF;gBAChB,OAAO;oBACLf,SAASe;gBACX;YACF,SAAU;gBACR,IAAItB,oBAAoB;oBACtB,IAAI,CAACR,gBAAgB,CAACyB,MAAM,CAACjB;gBAC/B;YACF;QACF,CAAA;QACA,OAAOG;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { CacheControl, Revalidate } from '../lib/cache-control'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport interface IncrementalResponseCacheEntry {\n  cacheControl?: CacheControl\n  /**\n   * timestamp in milliseconds to revalidate after\n   */\n  revalidateAfter?: Revalidate\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n  value: Exclude<IncrementalCacheValue, CachedFetchValue> | null\n}\n\nexport interface IncrementalFetchCacheEntry {\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  value: CachedFetchValue\n}\n\nexport type IncrementalCacheEntry =\n  | IncrementalResponseCacheEntry\n  | IncrementalFetchCacheEntry\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  cacheControl?: CacheControl\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalResponseCacheEntry | null\n  isRevalidating?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface GetIncrementalFetchCacheContext {\n  kind: IncrementalCacheKind.FETCH\n  revalidate?: Revalidate\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  softTags?: string[]\n}\n\nexport interface GetIncrementalResponseCacheContext {\n  kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback: boolean\n}\n\nexport interface SetIncrementalFetchCacheContext {\n  fetchCache: true\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n}\n\nexport interface SetIncrementalResponseCacheContext {\n  fetchCache?: false\n  cacheControl?: CacheControl\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback?: boolean\n}\n\nexport interface IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n\nexport interface IncrementalCache extends IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;AA+CO,IAAWA,kBAAAA,WAAAA,GAAAA,SAAAA,eAAAA;;;;;;;WAAAA;MAOjB;AA2IM,IAAWC,uBAAAA,WAAAA,GAAAA,SAAAA,oBAAAA;;;;;;WAAAA;MAMjB","ignoreList":[0]}},
    {"offset": {"line": 1689, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalResponseCacheEntry,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalResponseCacheEntry> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalResponseCacheEntry | null\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    cacheControl: response.cacheControl,\n    isFallback: response.isFallback,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(response.value.html),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(response.value.html),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH> {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    default:\n      throw new Error(`Unexpected route kind ${routeKind}`)\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","isMiss","isStale","cacheControl","isFallback","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE","Error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1770, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalResponseCacheEntry | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n    } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n\n        let resolved = false\n        let cachedResponse: IncrementalResponseCacheEntry | null = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kind,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            resolve(cachedResponse)\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator({\n            hasResolved: resolved,\n            previousCacheEntry: cachedResponse,\n            isRevalidating: true,\n          })\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          // We want to persist the result only if it has a cache control value\n          // defined.\n          if (resolveValue.cacheControl) {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                cacheControl: resolveValue.cacheControl,\n                isRoutePPREnabled,\n                isFallback,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a path is erroring we automatically re-set the existing cache\n          // with new revalidate and expire times to prevent non-stop retrying.\n          if (cachedResponse?.cacheControl) {\n            const newRevalidate = Math.min(\n              Math.max(cachedResponse.cacheControl.revalidate || 3, 3),\n              30\n            )\n\n            const newExpire =\n              cachedResponse.cacheControl.expire === undefined\n                ? undefined\n                : Math.max(\n                    newRevalidate + 3,\n                    cachedResponse.cacheControl.expire\n                  )\n\n            await incrementalCache.set(key, cachedResponse.value, {\n              cacheControl: { revalidate: newRevalidate, expire: newExpire },\n              isRoutePPREnabled,\n              isFallback,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["Batcher","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","hasResolved","previousCacheEntry","incrementalCache","isFallback","isRoutePPREnabled","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kind","routeKind","resolved","cachedResponse","isStale","isPrefetch","cacheEntry","isRevalidating","undefined","resolveValue","isMiss","cacheControl","set","value","err","newRevalidate","Math","min","max","revalidate","newExpire","expire","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1926, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/encodedTags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML"],"mappings":";;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 2005, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2057, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encodedTags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\nexport type ReactReadableStream = ReadableStream<Uint8Array> & {\n  allReady?: Promise<void> | undefined\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // We could encode this invariant in the arguments but current uses of this function pass\n  // use spread so it would be missed by\n  if (streams.length === 0) {\n    throw new Error('Invariant: chainStreams requires at least one stream')\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport function createBufferedTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    // If we already have a pending flush, then return early.\n    if (pending) return\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        const chunk = new Uint8Array(bufferByteLength)\n        let copiedBytes = 0\n\n        for (let i = 0; i < bufferedChunks.length; i++) {\n          const bufferedChunk = bufferedChunks[i]\n          chunk.set(bufferedChunk, copiedBytes)\n          copiedBytes += bufferedChunk.byteLength\n        }\n        // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n        // and our bufferByteLength to prepare for the next round of buffered chunks\n        bufferedChunks.length = 0\n        bufferByteLength = 0\n        controller.enqueue(chunk)\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      // Flush the buffer to the controller.\n      flush(controller)\n    },\n    flush() {\n      if (!pending) return\n\n      return pending.promise\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: typeof import('react-dom/server.edge')\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\n// Merge two streams into one. Ensure the final transform stream is closed\n// when both are finished.\nfunction createMergedTransformStream(\n  stream: ReadableStream<Uint8Array>\n): TransformStream<Uint8Array, Uint8Array> {\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    if (pull) {\n      return\n    }\n\n    const reader = stream.getReader()\n\n    // NOTE: streaming flush\n    // We are buffering here for the inlined data stream because the\n    // \"shell\" stream might be chunkenized again by the underlying stream\n    // implementation, e.g. with a specific high-water mark. To ensure it's\n    // the safe timing to pipe the data stream, this extra tick is\n    // necessary.\n\n    // We don't start reading until we've left the current Task to ensure\n    // that it's inserted after flushing the shell. Note that this implementation\n    // might get stale if impl details of Fizz change in the future.\n    await atLeastOneTask()\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (!pull) {\n        pull = startPulling(controller)\n      }\n    },\n    flush(controller) {\n      if (donePulling) {\n        return\n      }\n      return pull || startPulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: typeof window.__next_root_layout_missing_tags = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<script>self.__next_root_layout_missing_tags=${JSON.stringify(\n            missingTags\n          )}</script>`\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML and there's an `allReady` promise on the\n  // stream, we need to wait for it to resolve before continuing.\n  if (isStaticGeneration && 'allReady' in renderStream) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Insert generated metadata\n    createHeadInsertionTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata to head\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata to body\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","voidCatch","encoder","TextEncoder","chainStreams","streams","length","Error","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","ReadableStream","start","controller","enqueue","encode","close","streamFromBuffer","chunk","streamToBuffer","stream","reader","getReader","chunks","done","value","read","push","Buffer","concat","streamToString","signal","decoder","TextDecoder","fatal","string","aborted","decode","createBufferedTransformStream","bufferedChunks","bufferByteLength","pending","flush","detached","Uint8Array","copiedBytes","bufferedChunk","set","byteLength","undefined","resolve","transform","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createHeadInsertionTransformStream","insert","inserted","hasBytes","insertion","encodedInsertion","index","CLOSED","HEAD","insertedHeadContent","slice","createDeferredSuffixStream","suffix","flushed","createMergedTransformStream","pull","donePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","JSON","stringify","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/encodedTags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML"],"mappings":";;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2659, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encodedTags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\nexport type ReactReadableStream = ReadableStream<Uint8Array> & {\n  allReady?: Promise<void> | undefined\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // We could encode this invariant in the arguments but current uses of this function pass\n  // use spread so it would be missed by\n  if (streams.length === 0) {\n    throw new Error('Invariant: chainStreams requires at least one stream')\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport function createBufferedTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    // If we already have a pending flush, then return early.\n    if (pending) return\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        const chunk = new Uint8Array(bufferByteLength)\n        let copiedBytes = 0\n\n        for (let i = 0; i < bufferedChunks.length; i++) {\n          const bufferedChunk = bufferedChunks[i]\n          chunk.set(bufferedChunk, copiedBytes)\n          copiedBytes += bufferedChunk.byteLength\n        }\n        // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n        // and our bufferByteLength to prepare for the next round of buffered chunks\n        bufferedChunks.length = 0\n        bufferByteLength = 0\n        controller.enqueue(chunk)\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      // Flush the buffer to the controller.\n      flush(controller)\n    },\n    flush() {\n      if (!pending) return\n\n      return pending.promise\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: typeof import('react-dom/server.edge')\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\n// Merge two streams into one. Ensure the final transform stream is closed\n// when both are finished.\nfunction createMergedTransformStream(\n  stream: ReadableStream<Uint8Array>\n): TransformStream<Uint8Array, Uint8Array> {\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    if (pull) {\n      return\n    }\n\n    const reader = stream.getReader()\n\n    // NOTE: streaming flush\n    // We are buffering here for the inlined data stream because the\n    // \"shell\" stream might be chunkenized again by the underlying stream\n    // implementation, e.g. with a specific high-water mark. To ensure it's\n    // the safe timing to pipe the data stream, this extra tick is\n    // necessary.\n\n    // We don't start reading until we've left the current Task to ensure\n    // that it's inserted after flushing the shell. Note that this implementation\n    // might get stale if impl details of Fizz change in the future.\n    await atLeastOneTask()\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (!pull) {\n        pull = startPulling(controller)\n      }\n    },\n    flush(controller) {\n      if (donePulling) {\n        return\n      }\n      return pull || startPulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: typeof window.__next_root_layout_missing_tags = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<script>self.__next_root_layout_missing_tags=${JSON.stringify(\n            missingTags\n          )}</script>`\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML and there's an `allReady` promise on the\n  // stream, we need to wait for it to resolve before continuing.\n  if (isStaticGeneration && 'allReady' in renderStream) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Insert generated metadata\n    createHeadInsertionTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata to head\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert generated metadata to body\n      .pipeThrough(\n        createHeadInsertionTransformStream(getServerInsertedMetadata)\n      )\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","voidCatch","encoder","TextEncoder","chainStreams","streams","length","Error","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","ReadableStream","start","controller","enqueue","encode","close","streamFromBuffer","chunk","streamToBuffer","stream","reader","getReader","chunks","done","value","read","push","Buffer","concat","streamToString","signal","decoder","TextDecoder","fatal","string","aborted","decode","createBufferedTransformStream","bufferedChunks","bufferByteLength","pending","flush","detached","Uint8Array","copiedBytes","bufferedChunk","set","byteLength","undefined","resolve","transform","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createHeadInsertionTransformStream","insert","inserted","hasBytes","insertion","encodedInsertion","index","CLOSED","HEAD","insertedHeadContent","slice","createDeferredSuffixStream","suffix","flushed","createMergedTransformStream","pull","donePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","JSON","stringify","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3130, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/request-meta.ts"],"sourcesContent":["/* eslint-disable no-redeclare */\nimport type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type { ServerComponentsHmrCache } from './response-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: any\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * Equals the segment path that was used for the prefetch RSC request.\n   */\n  segmentPrefetchRSCRequest?: string\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * True when the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  isNextDataReq?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntry?: (\n    cacheEntry: any,\n    requestMeta: any\n  ) => Promise<boolean | void> | boolean | void\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * In development, the original source page that returned a 404.\n   */\n  developmentNotFoundSourcePage?: string\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the default route matches were set on the request during routing.\n   */\n  didSetDefaultRouteMatches?: boolean\n\n  /**\n   * Whether the request is for the custom error page.\n   */\n  customErrorRender?: true\n\n  /**\n   * Whether to bubble up the NoFallbackError to the caller when a 404 is\n   * returned.\n   */\n  bubbleNoFallback?: true\n\n  /**\n   * True when the request had locale information inferred from the default\n   * locale.\n   */\n  localeInferredFromDefault?: true\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   */\n  locale?: string\n\n  /**\n   * The default locale that was inferred or explicitly set for the request.\n   */\n  defaultLocale?: string\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  /**\n   * The `_rsc` query parameter used for cache busting to ensure that the RSC\n   * requests do not get cached by the browser explicitly.\n   */\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery &\n  NextQueryMetadata & {\n    amp?: '1'\n  }\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta"],"mappings":"AAAA,+BAA+B,GAU/B,kGAAkG;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAgM/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC","ignoreList":[0]}},
    {"offset": {"line": 3163, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 3189, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/base-http/index.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { I18NConfig } from '../config-shared'\n\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport type { NextApiRequestCookies } from '../api-utils'\nimport { getCookieParser } from '../api-utils/get-cookie-parser'\n\nexport interface BaseNextRequestConfig {\n  basePath: string | undefined\n  i18n?: I18NConfig\n  trailingSlash?: boolean | undefined\n}\n\nexport type FetchMetric = {\n  url: string\n  idx: number\n  end: number\n  start: number\n  method: string\n  status: number\n  cacheReason: string\n  cacheStatus: 'hit' | 'miss' | 'skip' | 'hmr'\n  cacheWarning?: string\n}\n\nexport type FetchMetrics = Array<FetchMetric>\n\nexport abstract class BaseNextRequest<Body = any> {\n  protected _cookies: NextApiRequestCookies | undefined\n  public abstract headers: IncomingHttpHeaders\n  public abstract fetchMetrics: FetchMetric[] | undefined\n\n  constructor(\n    public method: string,\n    public url: string,\n    public body: Body\n  ) {}\n\n  // Utils implemented using the abstract methods above\n\n  public get cookies() {\n    if (this._cookies) return this._cookies\n    return (this._cookies = getCookieParser(this.headers)())\n  }\n}\n\nexport abstract class BaseNextResponse<Destination = any> {\n  abstract statusCode: number | undefined\n  abstract statusMessage: string | undefined\n  abstract get sent(): boolean\n\n  constructor(public destination: Destination) {}\n\n  /**\n   * Sets a value for the header overwriting existing values\n   */\n  abstract setHeader(name: string, value: string | string[]): this\n\n  /**\n   * Removes a header\n   */\n  abstract removeHeader(name: string): this\n\n  /**\n   * Appends value for the given header name\n   */\n  abstract appendHeader(name: string, value: string): this\n\n  /**\n   * Get all values for a header as an array or undefined if no value is present\n   */\n  abstract getHeaderValues(name: string): string[] | undefined\n\n  abstract hasHeader(name: string): boolean\n\n  /**\n   * Get values for a header concatenated using `,` or undefined if no value is present\n   */\n  abstract getHeader(name: string): string | undefined\n\n  abstract getHeaders(): OutgoingHttpHeaders\n\n  abstract body(value: string): this\n\n  abstract send(): void\n\n  abstract onClose(callback: () => void): void\n\n  // Utils implemented using the abstract methods above\n\n  public redirect(destination: string, statusCode: number) {\n    this.setHeader('Location', destination)\n    this.statusCode = statusCode\n\n    // Since IE11 doesn't support the 308 header add backwards\n    // compatibility using refresh header\n    if (statusCode === RedirectStatusCode.PermanentRedirect) {\n      this.setHeader('Refresh', `0;url=${destination}`)\n    }\n\n    return this\n  }\n}\n"],"names":["RedirectStatusCode","getCookieParser","BaseNextRequest","constructor","method","url","body","cookies","_cookies","headers","BaseNextResponse","destination","redirect","statusCode","setHeader","PermanentRedirect"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,+CAA8C;AAEjF,SAASC,eAAe,QAAQ,iCAAgC;;;AAsBzD,MAAeC;IAKpBC,YACSC,MAAc,EACdC,GAAW,EACXC,IAAU,CACjB;aAHOF,MAAAA,GAAAA;aACAC,GAAAA,GAAAA;aACAC,IAAAA,GAAAA;IACN;IAEH,qDAAqD;IAErD,IAAWC,UAAU;QACnB,IAAI,IAAI,CAACC,QAAQ,EAAE,OAAO,IAAI,CAACA,QAAQ;QACvC,OAAQ,IAAI,CAACA,QAAQ,wMAAGP,kBAAAA,EAAgB,IAAI,CAACQ,OAAO;IACtD;AACF;AAEO,MAAeC;IAKpBP,YAAmBQ,WAAwB,CAAE;aAA1BA,WAAAA,GAAAA;IAA2B;IAqC9C,qDAAqD;IAE9CC,SAASD,WAAmB,EAAEE,UAAkB,EAAE;QACvD,IAAI,CAACC,SAAS,CAAC,YAAYH;QAC3B,IAAI,CAACE,UAAU,GAAGA;QAElB,0DAA0D;QAC1D,qCAAqC;QACrC,IAAIA,iNAAeb,qBAAAA,CAAmBe,iBAAiB,EAAE;YACvD,IAAI,CAACD,SAAS,CAAC,WAAW,CAAC,MAAM,EAAEH,aAAa;QAClD;QAEA,OAAO,IAAI;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 3231, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/base-http/web.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { FetchMetrics } from './index'\n\nimport { toNodeOutgoingHttpHeaders } from '../web/utils'\nimport { BaseNextRequest, BaseNextResponse } from './index'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport type { NextRequestHint } from '../web/adapter'\nimport { CloseController, trackBodyConsumed } from '../web/web-on-close'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class WebNextRequest extends BaseNextRequest<ReadableStream | null> {\n  public request: Request\n  public headers: IncomingHttpHeaders\n  public fetchMetrics: FetchMetrics | undefined\n\n  constructor(request: NextRequestHint) {\n    const url = new URL(request.url)\n\n    super(\n      request.method,\n      url.href.slice(url.origin.length),\n      request.clone().body\n    )\n    this.request = request\n    this.fetchMetrics = request.fetchMetrics\n\n    this.headers = {}\n    for (const [name, value] of request.headers.entries()) {\n      this.headers[name] = value\n    }\n  }\n\n  async parseBody(_limit: string | number): Promise<any> {\n    throw new Error('parseBody is not implemented in the web runtime')\n  }\n}\n\nexport class WebNextResponse extends BaseNextResponse<WritableStream> {\n  private headers = new Headers()\n  private textBody: string | undefined = undefined\n\n  private closeController = new CloseController()\n\n  public statusCode: number | undefined\n  public statusMessage: string | undefined\n\n  constructor(public transformStream = new TransformStream()) {\n    super(transformStream.writable)\n  }\n\n  setHeader(name: string, value: string | string[]): this {\n    this.headers.delete(name)\n    for (const val of Array.isArray(value) ? value : [value]) {\n      this.headers.append(name, val)\n    }\n    return this\n  }\n\n  removeHeader(name: string): this {\n    this.headers.delete(name)\n    return this\n  }\n\n  getHeaderValues(name: string): string[] | undefined {\n    // https://developer.mozilla.org/docs/Web/API/Headers/get#example\n    return this.getHeader(name)\n      ?.split(',')\n      .map((v) => v.trimStart())\n  }\n\n  getHeader(name: string): string | undefined {\n    return this.headers.get(name) ?? undefined\n  }\n\n  getHeaders(): OutgoingHttpHeaders {\n    return toNodeOutgoingHttpHeaders(this.headers)\n  }\n\n  hasHeader(name: string): boolean {\n    return this.headers.has(name)\n  }\n\n  appendHeader(name: string, value: string): this {\n    this.headers.append(name, value)\n    return this\n  }\n\n  body(value: string) {\n    this.textBody = value\n    return this\n  }\n\n  private readonly sendPromise = new DetachedPromise<void>()\n\n  private _sent = false\n  public send() {\n    this.sendPromise.resolve()\n    this._sent = true\n  }\n\n  get sent() {\n    return this._sent\n  }\n\n  public async toResponse() {\n    // If we haven't called `send` yet, wait for it to be called.\n    if (!this.sent) await this.sendPromise.promise\n\n    const body = this.textBody ?? this.transformStream.readable\n\n    let bodyInit: BodyInit = body\n\n    // if the response is streaming, onClose() can still be called after this point.\n    const canAddListenersLater = typeof bodyInit !== 'string'\n    const shouldTrackBody = canAddListenersLater\n      ? true\n      : this.closeController.listeners > 0\n\n    if (shouldTrackBody) {\n      bodyInit = trackBodyConsumed(body, () => {\n        this.closeController.dispatchClose()\n      })\n    }\n\n    return new Response(bodyInit, {\n      headers: this.headers,\n      status: this.statusCode,\n      statusText: this.statusMessage,\n    })\n  }\n\n  public onClose(callback: () => void) {\n    if (this.closeController.isClosed) {\n      throw new InvariantError(\n        'Cannot call onClose on a WebNextResponse that is already closed'\n      )\n    }\n    return this.closeController.onClose(callback)\n  }\n}\n"],"names":["toNodeOutgoingHttpHeaders","BaseNextRequest","BaseNextResponse","DetachedPromise","CloseController","trackBodyConsumed","InvariantError","WebNextRequest","constructor","request","url","URL","method","href","slice","origin","length","clone","body","fetchMetrics","headers","name","value","entries","parseBody","_limit","Error","WebNextResponse","transformStream","TransformStream","writable","Headers","textBody","undefined","closeController","sendPromise","_sent","setHeader","delete","val","Array","isArray","append","removeHeader","getHeaderValues","getHeader","split","map","v","trimStart","get","getHeaders","hasHeader","has","appendHeader","send","resolve","sent","toResponse","promise","readable","bodyInit","canAddListenersLater","shouldTrackBody","listeners","dispatchClose","Response","status","statusCode","statusText","statusMessage","onClose","callback","isClosed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 3372, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/client-component-renderer-logger.ts"],"sourcesContent":["import type { AppPageModule } from './route-modules/app-page/module'\n\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(\n  ComponentMod: AppPageModule\n): AppPageModule['__next_app__'] {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args) => {\n      const startTime = performance.now()\n      const result = ComponentMod.__next_app__.loadChunk(...args)\n      // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n      // We only need to know when it's settled.\n      result.finally(() => {\n        clientComponentLoadTimes += performance.now() - startTime\n      })\n      return result\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","result","finally","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":"AAEA,oDAAoD;;;;;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BACdC,YAA2B;IAE3B,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,MAAME,SAAST,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YACtD,gHAAgH;YAChH,0CAA0C;YAC1CK,OAAOC,OAAO,CAAC;gBACbb,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;YACA,OAAOI;QACT;IACF;AACF;AAEO,SAASE,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJjB,6BAA6B,IACzBkB,YACA;QACElB;QACAC;QACAC;IACF;IAEN,IAAIc,QAAQG,KAAK,EAAE;QACjBnB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOe;AACT","ignoreList":[0]}},
    {"offset": {"line": 3428, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3559, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { CacheControl } from './lib/cache-control'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToBuffer,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'\n\ntype ContentTypeOption = string | undefined\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  cacheControl?: CacheControl\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentData?: Map<string, Buffer>\n\n  /**\n   * In development, the cache is warmed up before the render. This is attached\n   * to the metadata so that it can be used during the render.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  cacheControl?: CacheControl\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType?: ContentTypeOption\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(value: string | Buffer) {\n    return new RenderResult<StaticRenderResultMetadata>(value, { metadata: {} })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  public toUnchunkedBuffer(stream?: false): Buffer\n  public toUnchunkedBuffer(stream: true): Promise<Buffer>\n  public toUnchunkedBuffer(stream = false): Promise<Buffer> | Buffer {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToBuffer(this.readable)\n    }\n\n    return Buffer.from(this.response)\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns the response if it is a stream, or throws an error if it is a\n   * string.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be streamed')\n    }\n    if (typeof this.response === 'string') {\n      throw new Error('Invariant: static responses cannot be streamed')\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public chain(readable: ReadableStream<Uint8Array>) {\n    if (this.response === null) {\n      throw new Error('Invariant: response is null. This is a bug in Next.js')\n    }\n\n    // If the response is not an array of streams already, make it one.\n    let responses: ReadableStream<Uint8Array>[]\n    if (typeof this.response === 'string') {\n      responses = [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      responses = this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      responses = [streamFromBuffer(this.response)]\n    } else {\n      responses = [this.response]\n    }\n\n    // Add the new stream to the array.\n    responses.push(readable)\n\n    // Update the response.\n    this.response = responses\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToBuffer","streamToString","isAbortError","pipeToNodeResponse","RenderResult","fromStatic","value","metadata","constructor","response","contentType","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedBuffer","stream","Error","readable","Buffer","from","toUnchunkedString","isBuffer","Array","isArray","chain","responses","push","pipeTo","writable","preventClose","close","err","abort","res"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3753, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0]}},
    {"offset": {"line": 3782, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/utils.ts"],"sourcesContent":["import { BLOCKED_PAGES } from '../shared/lib/constants'\n\nexport function isBlockedPage(page: string): boolean {\n  return BLOCKED_PAGES.includes(page)\n}\n\nexport function cleanAmpPath(pathname: string): string {\n  if (pathname.match(/\\?amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/\\?amp=(y|yes|true|1)&?/, '?')\n  }\n  if (pathname.match(/&amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/&amp=(y|yes|true|1)/, '')\n  }\n  pathname = pathname.replace(/\\?$/, '')\n  return pathname\n}\n\ntype AnyFunc<T> = (this: T, ...args: any) => any\nexport function debounce<T, F extends AnyFunc<T>>(\n  fn: F,\n  ms: number,\n  maxWait = Infinity\n) {\n  let timeoutId: undefined | NodeJS.Timeout\n\n  // The time the debouncing function was first called during this debounce queue.\n  let startTime = 0\n  // The time the debouncing function was last called.\n  let lastCall = 0\n\n  // The arguments and this context of the last call to the debouncing function.\n  let args: Parameters<F>, context: T\n\n  // A helper used to that either invokes the debounced function, or\n  // reschedules the timer if a more recent call was made.\n  function run() {\n    const now = Date.now()\n    const diff = lastCall + ms - now\n\n    // If the diff is non-positive, then we've waited at least `ms`\n    // milliseconds since the last call. Or if we've waited for longer than the\n    // max wait time, we must call the debounced function.\n    if (diff <= 0 || startTime + maxWait >= now) {\n      // It's important to clear the timeout id before invoking the debounced\n      // function, in case the function calls the debouncing function again.\n      timeoutId = undefined\n      fn.apply(context, args)\n    } else {\n      // Else, a new call was made after the original timer was scheduled. We\n      // didn't clear the timeout (doing so is very slow), so now we need to\n      // reschedule the timer for the time difference.\n      timeoutId = setTimeout(run, diff)\n    }\n  }\n\n  return function (this: T, ...passedArgs: Parameters<F>) {\n    // The arguments and this context of the most recent call are saved so the\n    // debounced function can be invoked with them later.\n    args = passedArgs\n    context = this\n\n    // Instead of constantly clearing and scheduling a timer, we record the\n    // time of the last call. If a second call comes in before the timer fires,\n    // then we'll reschedule in the run function. Doing this is considerably\n    // faster.\n    lastCall = Date.now()\n\n    // Only schedule a new timer if we're not currently waiting.\n    if (timeoutId === undefined) {\n      startTime = lastCall\n      timeoutId = setTimeout(run, ms)\n    }\n  }\n}\n"],"names":["BLOCKED_PAGES","isBlockedPage","page","includes","cleanAmpPath","pathname","match","replace","debounce","fn","ms","maxWait","Infinity","timeoutId","startTime","lastCall","args","context","run","now","Date","diff","undefined","apply","setTimeout","passedArgs"],"mappings":";;;;;;AAAA,SAASA,aAAa,QAAQ,0BAAyB;;AAEhD,SAASC,cAAcC,IAAY;IACxC,iMAAOF,gBAAAA,CAAcG,QAAQ,CAACD;AAChC;AAEO,SAASE,aAAaC,QAAgB;IAC3C,IAAIA,SAASC,KAAK,CAAC,yBAAyB;QAC1CD,WAAWA,SAASE,OAAO,CAAC,0BAA0B;IACxD;IACA,IAAIF,SAASC,KAAK,CAAC,wBAAwB;QACzCD,WAAWA,SAASE,OAAO,CAAC,uBAAuB;IACrD;IACAF,WAAWA,SAASE,OAAO,CAAC,OAAO;IACnC,OAAOF;AACT;AAGO,SAASG,SACdC,EAAK,EACLC,EAAU,EACVC,UAAUC,QAAQ;IAElB,IAAIC;IAEJ,gFAAgF;IAChF,IAAIC,YAAY;IAChB,oDAAoD;IACpD,IAAIC,WAAW;IAEf,8EAA8E;IAC9E,IAAIC,MAAqBC;IAEzB,kEAAkE;IAClE,wDAAwD;IACxD,SAASC;QACP,MAAMC,MAAMC,KAAKD,GAAG;QACpB,MAAME,OAAON,WAAWL,KAAKS;QAE7B,+DAA+D;QAC/D,2EAA2E;QAC3E,sDAAsD;QACtD,IAAIE,QAAQ,KAAKP,YAAYH,WAAWQ,KAAK;YAC3C,uEAAuE;YACvE,sEAAsE;YACtEN,YAAYS;YACZb,GAAGc,KAAK,CAACN,SAASD;QACpB,OAAO;YACL,uEAAuE;YACvE,sEAAsE;YACtE,gDAAgD;YAChDH,YAAYW,WAAWN,KAAKG;QAC9B;IACF;IAEA,OAAO,SAAmB,GAAGI,UAAyB;QACpD,0EAA0E;QAC1E,qDAAqD;QACrDT,OAAOS;QACPR,UAAU,IAAI;QAEd,uEAAuE;QACvE,2EAA2E;QAC3E,wEAAwE;QACxE,UAAU;QACVF,WAAWK,KAAKD,GAAG;QAEnB,4DAA4D;QAC5D,IAAIN,cAAcS,WAAW;YAC3BR,YAAYC;YACZF,YAAYW,WAAWN,KAAKR;QAC9B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3854, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/server-utils.ts"],"sourcesContent":["import type { Rewrite } from '../lib/load-custom-routes'\nimport type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'\nimport type { NextConfig } from './config'\nimport type { BaseNextRequest } from './base-http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { getPathMatch } from '../shared/lib/router/utils/path-match'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport {\n  matchHas,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { normalizeRscURL } from '../shared/lib/router/utils/app-paths'\nimport {\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../lib/constants'\nimport { normalizeNextQueryParam } from './web/utils'\n\nexport function normalizeVercelUrl(\n  req: BaseNextRequest,\n  paramKeys: string[],\n  defaultRouteRegex: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  // make sure to normalize req.url on Vercel to strip dynamic and rewrite\n  // params from the query which are added during routing\n  const _parsedUrl = parseUrl(req.url!, true)\n  delete (_parsedUrl as any).search\n\n  for (const key of Object.keys(_parsedUrl.query)) {\n    const isNextQueryPrefix =\n      key !== NEXT_QUERY_PARAM_PREFIX && key.startsWith(NEXT_QUERY_PARAM_PREFIX)\n\n    const isNextInterceptionMarkerPrefix =\n      key !== NEXT_INTERCEPTION_MARKER_PREFIX &&\n      key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)\n\n    if (\n      isNextQueryPrefix ||\n      isNextInterceptionMarkerPrefix ||\n      paramKeys.includes(key) ||\n      (defaultRouteRegex && Object.keys(defaultRouteRegex.groups).includes(key))\n    ) {\n      delete _parsedUrl.query[key]\n    }\n  }\n\n  req.url = formatUrl(_parsedUrl)\n}\n\nexport function interpolateDynamicPath(\n  pathname: string,\n  params: ParsedUrlQuery,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  if (!defaultRouteRegex) return pathname\n\n  for (const param of Object.keys(defaultRouteRegex.groups)) {\n    const { optional, repeat } = defaultRouteRegex.groups[param]\n    let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n    if (optional) {\n      builtParam = `[${builtParam}]`\n    }\n\n    let paramValue: string\n    const value = params[param]\n\n    if (Array.isArray(value)) {\n      paramValue = value.map((v) => v && encodeURIComponent(v)).join('/')\n    } else if (value) {\n      paramValue = encodeURIComponent(value)\n    } else {\n      paramValue = ''\n    }\n\n    pathname = pathname.replaceAll(builtParam, paramValue)\n  }\n\n  return pathname\n}\n\nexport function normalizeDynamicRouteParams(\n  query: ParsedUrlQuery,\n  defaultRouteRegex: ReturnType<typeof getNamedRouteRegex>,\n  defaultRouteMatches: ParsedUrlQuery,\n  ignoreMissingOptional: boolean\n) {\n  let hasValidParams = true\n  let params: ParsedUrlQuery = {}\n\n  for (const key of Object.keys(defaultRouteRegex.groups)) {\n    let value: string | string[] | undefined = query[key]\n\n    if (typeof value === 'string') {\n      value = normalizeRscURL(value)\n    } else if (Array.isArray(value)) {\n      value = value.map(normalizeRscURL)\n    }\n\n    // if the value matches the default value we can't rely\n    // on the parsed params, this is used to signal if we need\n    // to parse x-now-route-matches or not\n    const defaultValue = defaultRouteMatches![key]\n    const isOptional = defaultRouteRegex!.groups[key].optional\n\n    const isDefaultValue = Array.isArray(defaultValue)\n      ? defaultValue.some((defaultVal) => {\n          return Array.isArray(value)\n            ? value.some((val) => val.includes(defaultVal))\n            : value?.includes(defaultVal)\n        })\n      : value?.includes(defaultValue as string)\n\n    if (\n      isDefaultValue ||\n      (typeof value === 'undefined' && !(isOptional && ignoreMissingOptional))\n    ) {\n      return { params: {}, hasValidParams: false }\n    }\n\n    // non-provided optional values should be undefined so normalize\n    // them to undefined\n    if (\n      isOptional &&\n      (!value ||\n        (Array.isArray(value) &&\n          value.length === 1 &&\n          // fallback optional catch-all SSG pages have\n          // [[...paramName]] for the root path on Vercel\n          (value[0] === 'index' || value[0] === `[[...${key}]]`)))\n    ) {\n      value = undefined\n      delete query[key]\n    }\n\n    // query values from the proxy aren't already split into arrays\n    // so make sure to normalize catch-all values\n    if (\n      value &&\n      typeof value === 'string' &&\n      defaultRouteRegex!.groups[key].repeat\n    ) {\n      value = value.split('/')\n    }\n\n    if (value) {\n      params[key] = value\n    }\n  }\n\n  return {\n    params,\n    hasValidParams,\n  }\n}\n\nexport function getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n  trailingSlash,\n  caseSensitive,\n}: {\n  page: string\n  i18n?: NextConfig['i18n']\n  basePath: string\n  rewrites: {\n    fallback?: ReadonlyArray<Rewrite>\n    afterFiles?: ReadonlyArray<Rewrite>\n    beforeFiles?: ReadonlyArray<Rewrite>\n  }\n  pageIsDynamic: boolean\n  trailingSlash?: boolean\n  caseSensitive: boolean\n}) {\n  let defaultRouteRegex: ReturnType<typeof getNamedRouteRegex> | undefined\n  let dynamicRouteMatcher: RouteMatchFn | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getNamedRouteRegex(page, {\n      prefixRouteKeys: false,\n    })\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(req: BaseNextRequest, parsedUrl: UrlWithParsedQuery) {\n    const rewriteParams = {}\n    let fsPathname = parsedUrl.pathname\n\n    const matchesPage = () => {\n      const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')\n      return (\n        fsPathnameNoSlash === removeTrailingSlash(page) ||\n        dynamicRouteMatcher?.(fsPathnameNoSlash)\n      )\n    }\n\n    const checkRewrite = (rewrite: Rewrite): boolean => {\n      const matcher = getPathMatch(\n        rewrite.source + (trailingSlash ? '(/)?' : ''),\n        {\n          removeUnnamedParams: true,\n          strict: true,\n          sensitive: !!caseSensitive,\n        }\n      )\n\n      if (!parsedUrl.pathname) return false\n\n      let params = matcher(parsedUrl.pathname)\n\n      if ((rewrite.has || rewrite.missing) && params) {\n        const hasParams = matchHas(\n          req,\n          parsedUrl.query,\n          rewrite.has,\n          rewrite.missing\n        )\n\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        const { parsedDestination, destQuery } = prepareDestination({\n          appendParamsToQuery: true,\n          destination: rewrite.destination,\n          params: params,\n          query: parsedUrl.query,\n        })\n\n        // if the rewrite destination is external break rewrite chain\n        if (parsedDestination.protocol) {\n          return true\n        }\n\n        Object.assign(rewriteParams, destQuery, params)\n        Object.assign(parsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(parsedUrl, parsedDestination)\n\n        fsPathname = parsedUrl.pathname\n        if (!fsPathname) return false\n\n        if (basePath) {\n          fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const result = normalizeLocalePath(fsPathname, i18n.locales)\n          fsPathname = result.pathname\n          parsedUrl.query.nextInternalLocale =\n            result.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          return true\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            parsedUrl.query = {\n              ...parsedUrl.query,\n              ...dynamicParams,\n            }\n            return true\n          }\n        }\n      }\n      return false\n    }\n\n    for (const rewrite of rewrites.beforeFiles || []) {\n      checkRewrite(rewrite)\n    }\n\n    if (fsPathname !== page) {\n      let finished = false\n\n      for (const rewrite of rewrites.afterFiles || []) {\n        finished = checkRewrite(rewrite)\n        if (finished) break\n      }\n\n      if (!finished && !matchesPage()) {\n        for (const rewrite of rewrites.fallback || []) {\n          finished = checkRewrite(rewrite)\n          if (finished) break\n        }\n      }\n    }\n    return rewriteParams\n  }\n\n  function getParamsFromRouteMatches(routeMatchesHeader: string) {\n    // If we don't have a default route regex, we can't get params from route\n    // matches\n    if (!defaultRouteRegex) return null\n\n    const { groups, routeKeys } = defaultRouteRegex\n\n    const matcher = getRouteMatcher({\n      re: {\n        // Simulate a RegExp match from the \\`req.url\\` input\n        exec: (str: string) => {\n          // Normalize all the prefixed query params.\n          const obj: Record<string, string> = Object.fromEntries(\n            new URLSearchParams(str)\n          )\n          for (const [key, value] of Object.entries(obj)) {\n            const normalizedKey = normalizeNextQueryParam(key)\n            if (!normalizedKey) continue\n\n            obj[normalizedKey] = value\n            delete obj[key]\n          }\n\n          // Use all the named route keys.\n          const result = {} as RegExpExecArray\n          for (const keyName of Object.keys(routeKeys)) {\n            const paramName = routeKeys[keyName]\n\n            // If this param name is not a valid parameter name, then skip it.\n            if (!paramName) continue\n\n            const group = groups[paramName]\n            const value = obj[keyName]\n\n            // When we're missing a required param, we can't match the route.\n            if (!group.optional && !value) return null\n\n            result[group.pos] = value\n          }\n\n          return result\n        },\n      },\n      groups,\n    })\n\n    const routeMatches = matcher(routeMatchesHeader)\n    if (!routeMatches) return null\n\n    return routeMatches\n  }\n\n  return {\n    handleRewrites,\n    defaultRouteRegex,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    getParamsFromRouteMatches,\n    /**\n     * Normalize dynamic route params.\n     *\n     * @param query - The query params to normalize.\n     * @param ignoreMissingOptional - Whether to ignore missing optional params.\n     * @returns The normalized params and whether they are valid.\n     */\n    normalizeDynamicRouteParams: (\n      query: ParsedUrlQuery,\n      ignoreMissingOptional: boolean\n    ) => {\n      if (!defaultRouteRegex || !defaultRouteMatches) {\n        return { params: {}, hasValidParams: false }\n      }\n\n      return normalizeDynamicRouteParams(\n        query,\n        defaultRouteRegex,\n        defaultRouteMatches,\n        ignoreMissingOptional\n      )\n    },\n    normalizeVercelUrl: (req: BaseNextRequest, paramKeys: string[]) =>\n      normalizeVercelUrl(req, paramKeys, defaultRouteRegex),\n    interpolateDynamicPath: (\n      pathname: string,\n      params: Record<string, undefined | string | string[]>\n    ) => interpolateDynamicPath(pathname, params, defaultRouteRegex),\n  }\n}\n"],"names":["format","formatUrl","parse","parseUrl","normalizeLocalePath","getPathMatch","getNamedRouteRegex","getRouteMatcher","matchHas","prepareDestination","removeTrailingSlash","normalizeRscURL","NEXT_INTERCEPTION_MARKER_PREFIX","NEXT_QUERY_PARAM_PREFIX","normalizeNextQueryParam","normalizeVercelUrl","req","paramKeys","defaultRouteRegex","_parsedUrl","url","search","key","Object","keys","query","isNextQueryPrefix","startsWith","isNextInterceptionMarkerPrefix","includes","groups","interpolateDynamicPath","pathname","params","param","optional","repeat","builtParam","paramValue","value","Array","isArray","map","v","encodeURIComponent","join","replaceAll","normalizeDynamicRouteParams","defaultRouteMatches","ignoreMissingOptional","hasValidParams","defaultValue","isOptional","isDefaultValue","some","defaultVal","val","length","undefined","split","getUtils","page","i18n","basePath","rewrites","pageIsDynamic","trailingSlash","caseSensitive","dynamicRouteMatcher","prefixRouteKeys","handleRewrites","parsedUrl","rewriteParams","fsPathname","matchesPage","fsPathnameNoSlash","checkRewrite","rewrite","matcher","source","removeUnnamedParams","strict","sensitive","has","missing","hasParams","assign","parsedDestination","destQuery","appendParamsToQuery","destination","protocol","replace","RegExp","result","locales","nextInternalLocale","detectedLocale","dynamicParams","beforeFiles","finished","afterFiles","fallback","getParamsFromRouteMatches","routeMatchesHeader","routeKeys","re","exec","str","obj","fromEntries","URLSearchParams","entries","normalizedKey","keyName","paramName","group","pos","routeMatches"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4123, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/locale-route-normalizer.ts"],"sourcesContent":["import type { I18NProvider } from '../lib/i18n-provider'\nimport type { Normalizer } from './normalizer'\n\n/**\n * Normalizes the pathname by removing the locale prefix if any.\n */\nexport class LocaleRouteNormalizer implements Normalizer {\n  constructor(private readonly provider: I18NProvider) {}\n\n  /**\n   * Normalizes the pathname by removing the locale prefix if any.\n   *\n   * @param pathname The pathname to normalize.\n   * @returns The pathname without the locale prefix (if any).\n   */\n  public normalize(pathname: string): string {\n    const match = this.provider.analyze(pathname)\n    return match.pathname\n  }\n}\n"],"names":["LocaleRouteNormalizer","constructor","provider","normalize","pathname","match","analyze"],"mappings":"AAGA;;CAEC,GACD;;;AAAO,MAAMA;IACXC,YAA6BC,QAAsB,CAAE;aAAxBA,QAAAA,GAAAA;IAAyB;IAEtD;;;;;GAKC,GACMC,UAAUC,QAAgB,EAAU;QACzC,MAAMC,QAAQ,IAAI,CAACH,QAAQ,CAACI,OAAO,CAACF;QACpC,OAAOC,MAAMD,QAAQ;IACvB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4148, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/normalizers.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\n/**\n * Normalizers combines many normalizers into a single normalizer interface that\n * will normalize the inputted pathname with each normalizer in order.\n */\nexport class Normalizers implements Normalizer {\n  constructor(private readonly normalizers: Array<Normalizer> = []) {}\n\n  public push(normalizer: Normalizer) {\n    this.normalizers.push(normalizer)\n  }\n\n  public normalize(pathname: string): string {\n    return this.normalizers.reduce<string>(\n      (normalized, normalizer) => normalizer.normalize(normalized),\n      pathname\n    )\n  }\n}\n"],"names":["Normalizers","constructor","normalizers","push","normalizer","normalize","pathname","reduce","normalized"],"mappings":"AAEA;;;CAGC,GACD;;;AAAO,MAAMA;IACXC,YAA6BC,cAAiC,EAAE,CAAE;aAArCA,WAAAA,GAAAA;IAAsC;IAE5DC,KAAKC,UAAsB,EAAE;QAClC,IAAI,CAACF,WAAW,CAACC,IAAI,CAACC;IACxB;IAEOC,UAAUC,QAAgB,EAAU;QACzC,OAAO,IAAI,CAACJ,WAAW,CAACK,MAAM,CAC5B,CAACC,YAAYJ,aAAeA,WAAWC,SAAS,CAACG,aACjDF;IAEJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 4171, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/prefixing-normalizer.ts"],"sourcesContent":["import path from '../../shared/lib/isomorphic/path'\nimport type { Normalizer } from './normalizer'\n\nexport class PrefixingNormalizer implements Normalizer {\n  private readonly prefix: string\n\n  constructor(...prefixes: ReadonlyArray<string>) {\n    this.prefix = path.posix.join(...prefixes)\n  }\n\n  public normalize(pathname: string): string {\n    return path.posix.join(this.prefix, pathname)\n  }\n}\n"],"names":["path","PrefixingNormalizer","constructor","prefixes","prefix","posix","join","normalize","pathname"],"mappings":";;;AAAA,OAAOA,UAAU,mCAAkC;;AAG5C,MAAMC;IAGXC,YAAY,GAAGC,QAA+B,CAAE;QAC9C,IAAI,CAACC,MAAM,sLAAGJ,UAAAA,CAAKK,KAAK,CAACC,IAAI,IAAIH;IACnC;IAEOI,UAAUC,QAAgB,EAAU;QACzC,0LAAOR,UAAAA,CAAKK,KAAK,CAACC,IAAI,CAAC,IAAI,CAACF,MAAM,EAAEI;IACtC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4190, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/app/app-bundle-path-normalizer.ts"],"sourcesContent":["import { Normalizers } from '../../normalizers'\nimport type { Normalizer } from '../../normalizer'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\nimport { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'\n\nexport class AppBundlePathNormalizer extends PrefixingNormalizer {\n  constructor() {\n    super('app')\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(normalizePagePath(page))\n  }\n}\n\nexport class DevAppBundlePathNormalizer extends Normalizers {\n  constructor(pageNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pageNormalizer,\n      // Normalize the app page to a pathname.\n      new AppBundlePathNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["Normalizers","PrefixingNormalizer","normalizePagePath","AppBundlePathNormalizer","constructor","normalize","page","DevAppBundlePathNormalizer","pageNormalizer","filename"],"mappings":";;;;AAAA,SAASA,WAAW,QAAQ,oBAAmB;AAE/C,SAASC,mBAAmB,QAAQ,6BAA4B;AAChE,SAASC,iBAAiB,QAAQ,uDAAsD;;;;AAEjF,MAAMC,gOAAgCF,sBAAAA;IAC3CG,aAAc;QACZ,KAAK,CAAC;IACR;IAEOC,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,wNAAUH,oBAAAA,EAAkBI;IAC3C;AACF;AAEO,MAAMC,uNAAmCP,cAAAA;IAC9CI,YAAYI,cAA0B,CAAE;QACtC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4227, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/app/app-filename-normalizer.ts"],"sourcesContent":["import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\n\nexport class AppFilenameNormalizer extends PrefixingNormalizer {\n  constructor(distDir: string) {\n    super(distDir, SERVER_DIRECTORY)\n  }\n\n  public normalize(manifestFilename: string): string {\n    return super.normalize(manifestFilename)\n  }\n}\n"],"names":["SERVER_DIRECTORY","PrefixingNormalizer","AppFilenameNormalizer","constructor","distDir","normalize","manifestFilename"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,mBAAmB,QAAQ,6BAA4B;;;AAEzD,MAAMC,8NAA8BD,sBAAAA;IACzCE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mMAASJ,mBAAAA;IACjB;IAEOK,UAAUC,gBAAwB,EAAU;QACjD,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4249, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/absolute-filename-normalizer.ts"],"sourcesContent":["import type { PAGE_TYPES } from '../../lib/page-types'\nimport { absolutePathToPage } from '../../shared/lib/page-path/absolute-path-to-page'\nimport type { Normalizer } from './normalizer'\n\n/**\n * Normalizes a given filename so that it's relative to the provided directory.\n * It will also strip the extension (if provided) and the trailing `/index`.\n */\nexport class AbsoluteFilenameNormalizer implements Normalizer {\n  /**\n   *\n   * @param dir the directory for which the files should be made relative to\n   * @param extensions the extensions the file could have\n   * @param keepIndex when `true` the trailing `/index` is _not_ removed\n   */\n  constructor(\n    private readonly dir: string,\n    private readonly extensions: ReadonlyArray<string>,\n    private readonly pagesType: PAGE_TYPES\n  ) {}\n\n  public normalize(filename: string): string {\n    return absolutePathToPage(filename, {\n      extensions: this.extensions,\n      keepIndex: false,\n      dir: this.dir,\n      pagesType: this.pagesType,\n    })\n  }\n}\n"],"names":["absolutePathToPage","AbsoluteFilenameNormalizer","constructor","dir","extensions","pagesType","normalize","filename","keepIndex"],"mappings":";;;AACA,SAASA,kBAAkB,QAAQ,mDAAkD;;AAO9E,MAAMC;IACX;;;;;GAKC,GACDC,YACmBC,GAAW,EACXC,UAAiC,EACjCC,SAAqB,CACtC;aAHiBF,GAAAA,GAAAA;aACAC,UAAAA,GAAAA;aACAC,SAAAA,GAAAA;IAChB;IAEIC,UAAUC,QAAgB,EAAU;QACzC,0NAAOP,qBAAAA,EAAmBO,UAAU;YAClCH,YAAY,IAAI,CAACA,UAAU;YAC3BI,WAAW;YACXL,KAAK,IAAI,CAACA,GAAG;YACbE,WAAW,IAAI,CAACA,SAAS;QAC3B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4280, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/app/app-page-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\n/**\n * DevAppPageNormalizer is a normalizer that is used to normalize a pathname\n * to a page in the `app` directory.\n */\nexport class DevAppPageNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(appDir: string, extensions: ReadonlyArray<string>) {\n    super(appDir, extensions, PAGE_TYPES.APP)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevAppPageNormalizer","constructor","appDir","extensions","APP"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAMxE,MAAMC,wOAA6BD,6BAAAA;IACxCE,YAAYC,MAAc,EAAEC,UAAiC,CAAE;QAC7D,KAAK,CAACD,QAAQC,gLAAYL,aAAAA,CAAWM,GAAG;IAC1C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4298, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/wrap-normalizer-fn.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\nexport function wrapNormalizerFn(fn: (pathname: string) => string): Normalizer {\n  return { normalize: fn }\n}\n"],"names":["wrapNormalizerFn","fn","normalize"],"mappings":";;;AAEO,SAASA,iBAAiBC,EAAgC;IAC/D,OAAO;QAAEC,WAAWD;IAAG;AACzB","ignoreList":[0]}},
    {"offset": {"line": 4312, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/underscore-normalizer.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\n/**\n * UnderscoreNormalizer replaces all instances of %5F with _.\n */\nexport class UnderscoreNormalizer implements Normalizer {\n  public normalize(pathname: string): string {\n    return pathname.replace(/%5F/g, '_')\n  }\n}\n"],"names":["UnderscoreNormalizer","normalize","pathname","replace"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,MAAMA;IACJC,UAAUC,QAAgB,EAAU;QACzC,OAAOA,SAASC,OAAO,CAAC,QAAQ;IAClC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4328, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/app/app-pathname-normalizer.ts"],"sourcesContent":["import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'\nimport { Normalizers } from '../../normalizers'\nimport { wrapNormalizerFn } from '../../wrap-normalizer-fn'\nimport { UnderscoreNormalizer } from '../../underscore-normalizer'\nimport type { Normalizer } from '../../normalizer'\n\nexport class AppPathnameNormalizer extends Normalizers {\n  constructor() {\n    super([\n      // The pathname to match should have the trailing `/page` and other route\n      // group information stripped from it.\n      wrapNormalizerFn(normalizeAppPath),\n      // The page should have the `%5F` characters replaced with `_` characters.\n      new UnderscoreNormalizer(),\n    ])\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(page)\n  }\n}\n\nexport class DevAppPathnameNormalizer extends Normalizers {\n  constructor(pageNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pageNormalizer,\n      // Normalize the app page to a pathname.\n      new AppPathnameNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["normalizeAppPath","Normalizers","wrapNormalizerFn","UnderscoreNormalizer","AppPathnameNormalizer","constructor","normalize","page","DevAppPathnameNormalizer","pageNormalizer","filename"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,gDAA+C;AAChF,SAASC,WAAW,QAAQ,oBAAmB;AAC/C,SAASC,gBAAgB,QAAQ,2BAA0B;AAC3D,SAASC,oBAAoB,QAAQ,8BAA6B;;;;;AAG3D,MAAMC,kNAA8BH,cAAAA;IACzCI,aAAc;QACZ,KAAK,CAAC;YACJ,yEAAyE;YACzE,sCAAsC;aACtCH,uNAAAA,kMAAiBF,mBAAAA;YACjB,0EAA0E;YAC1E,qMAAIG,uBAAAA;SACL;IACH;IAEOG,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF;AAEO,MAAMC,qNAAiCP,cAAAA;IAC5CI,YAAYI,cAA0B,CAAE;QACtC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4373, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/app/index.ts"],"sourcesContent":["import {\n  AppBundlePathNormalizer,\n  DevAppBundlePathNormalizer,\n} from './app-bundle-path-normalizer'\nimport { AppFilenameNormalizer } from './app-filename-normalizer'\nimport { DevAppPageNormalizer } from './app-page-normalizer'\nimport {\n  AppPathnameNormalizer,\n  DevAppPathnameNormalizer,\n} from './app-pathname-normalizer'\n\nexport class AppNormalizers {\n  public readonly filename: AppFilenameNormalizer\n  public readonly pathname: AppPathnameNormalizer\n  public readonly bundlePath: AppBundlePathNormalizer\n\n  constructor(distDir: string) {\n    this.filename = new AppFilenameNormalizer(distDir)\n    this.pathname = new AppPathnameNormalizer()\n    this.bundlePath = new AppBundlePathNormalizer()\n  }\n}\n\nexport class DevAppNormalizers {\n  public readonly page: DevAppPageNormalizer\n  public readonly pathname: DevAppPathnameNormalizer\n  public readonly bundlePath: DevAppBundlePathNormalizer\n\n  constructor(appDir: string, extensions: ReadonlyArray<string>) {\n    this.page = new DevAppPageNormalizer(appDir, extensions)\n    this.pathname = new DevAppPathnameNormalizer(this.page)\n    this.bundlePath = new DevAppBundlePathNormalizer(this.page)\n  }\n}\n"],"names":["AppBundlePathNormalizer","DevAppBundlePathNormalizer","AppFilenameNormalizer","DevAppPageNormalizer","AppPathnameNormalizer","DevAppPathnameNormalizer","AppNormalizers","constructor","distDir","filename","pathname","bundlePath","DevAppNormalizers","appDir","extensions","page"],"mappings":";;;;AAAA,SACEA,uBAAuB,EACvBC,0BAA0B,QACrB,+BAA8B;AACrC,SAASC,qBAAqB,QAAQ,4BAA2B;AACjE,SAASC,oBAAoB,QAAQ,wBAAuB;AAC5D,SACEC,qBAAqB,EACrBC,wBAAwB,QACnB,4BAA2B;;;;;AAE3B,MAAMC;IAKXC,YAAYC,OAAe,CAAE;QAC3B,IAAI,CAACC,QAAQ,GAAG,0NAAIP,wBAAAA,CAAsBM;QAC1C,IAAI,CAACE,QAAQ,GAAG,0NAAIN,wBAAAA;QACpB,IAAI,CAACO,UAAU,GAAG,gOAAIX,0BAAAA;IACxB;AACF;AAEO,MAAMY;IAKXL,YAAYM,MAAc,EAAEC,UAAiC,CAAE;QAC7D,IAAI,CAACC,IAAI,GAAG,sNAAIZ,uBAAAA,CAAqBU,QAAQC;QAC7C,IAAI,CAACJ,QAAQ,GAAG,0NAAIL,2BAAAA,CAAyB,IAAI,CAACU,IAAI;QACtD,IAAI,CAACJ,UAAU,GAAG,gOAAIV,6BAAAA,CAA2B,IAAI,CAACc,IAAI;IAC5D;AACF","ignoreList":[0]}},
    {"offset": {"line": 4405, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-bundle-path-normalizer.ts"],"sourcesContent":["import { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'\nimport type { Normalizer } from '../../normalizer'\nimport { Normalizers } from '../../normalizers'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\nimport { wrapNormalizerFn } from '../../wrap-normalizer-fn'\n\nexport class PagesBundlePathNormalizer extends Normalizers {\n  constructor() {\n    super([\n      // The bundle path should have the trailing `/index` stripped from\n      // it.\n      wrapNormalizerFn(normalizePagePath),\n      // The page should prefixed with `pages/`.\n      new PrefixingNormalizer('pages'),\n    ])\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(page)\n  }\n}\n\nexport class DevPagesBundlePathNormalizer extends Normalizers {\n  constructor(pagesNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pagesNormalizer,\n      // Normalize the app page to a pathname.\n      new PagesBundlePathNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["normalizePagePath","Normalizers","PrefixingNormalizer","wrapNormalizerFn","PagesBundlePathNormalizer","constructor","normalize","page","DevPagesBundlePathNormalizer","pagesNormalizer","filename"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,uDAAsD;AAExF,SAASC,WAAW,QAAQ,oBAAmB;AAC/C,SAASC,mBAAmB,QAAQ,6BAA4B;AAChE,SAASC,gBAAgB,QAAQ,2BAA0B;;;;;AAEpD,MAAMC,sNAAkCH,cAAAA;IAC7CI,aAAc;QACZ,KAAK,CAAC;YACJ,kEAAkE;YAClE,MAAM;aACNF,uNAAAA,4MAAiBH,oBAAAA;YACjB,0CAA0C;YAC1C,oMAAIE,sBAAAA,CAAoB;SACzB;IACH;IAEOI,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF;AAEO,MAAMC,yNAAqCP,cAAAA;IAChDI,YAAYI,eAA2B,CAAE;QACvC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4450, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-filename-normalizer.ts"],"sourcesContent":["import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\n\nexport class PagesFilenameNormalizer extends PrefixingNormalizer {\n  constructor(distDir: string) {\n    super(distDir, SERVER_DIRECTORY)\n  }\n\n  public normalize(manifestFilename: string): string {\n    return super.normalize(manifestFilename)\n  }\n}\n"],"names":["SERVER_DIRECTORY","PrefixingNormalizer","PagesFilenameNormalizer","constructor","distDir","normalize","manifestFilename"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,mBAAmB,QAAQ,6BAA4B;;;AAEzD,MAAMC,gOAAgCD,sBAAAA;IAC3CE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mMAASJ,mBAAAA;IACjB;IAEOK,UAAUC,gBAAwB,EAAU;QACjD,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4472, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-page-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\nexport class DevPagesPageNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    super(pagesDir, extensions, PAGE_TYPES.PAGES)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevPagesPageNormalizer","constructor","pagesDir","extensions","PAGES"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAExE,MAAMC,0OAA+BD,6BAAAA;IAC1CE,YAAYC,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,KAAK,CAACD,UAAUC,gLAAYL,aAAAA,CAAWM,KAAK;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4490, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-pathname-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\nexport class DevPagesPathnameNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    super(pagesDir, extensions, PAGE_TYPES.PAGES)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevPagesPathnameNormalizer","constructor","pagesDir","extensions","PAGES"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAExE,MAAMC,8OAAmCD,6BAAAA;IAC9CE,YAAYC,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,KAAK,CAACD,UAAUC,gLAAYL,aAAAA,CAAWM,KAAK;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4508, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/built/pages/index.ts"],"sourcesContent":["import {\n  DevPagesBundlePathNormalizer,\n  PagesBundlePathNormalizer,\n} from './pages-bundle-path-normalizer'\nimport { PagesFilenameNormalizer } from './pages-filename-normalizer'\nimport { DevPagesPageNormalizer } from './pages-page-normalizer'\nimport { DevPagesPathnameNormalizer } from './pages-pathname-normalizer'\n\nexport class PagesNormalizers {\n  public readonly filename: PagesFilenameNormalizer\n  public readonly bundlePath: PagesBundlePathNormalizer\n\n  constructor(distDir: string) {\n    this.filename = new PagesFilenameNormalizer(distDir)\n    this.bundlePath = new PagesBundlePathNormalizer()\n\n    // You'd think that we'd require a `pathname` normalizer here, but for\n    // `/pages` we have to handle i18n routes, which means that we need to\n    // analyze the page path to determine the locale prefix and it's locale.\n  }\n}\n\nexport class DevPagesNormalizers {\n  public readonly page: DevPagesPageNormalizer\n  public readonly pathname: DevPagesPathnameNormalizer\n  public readonly bundlePath: DevPagesBundlePathNormalizer\n\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    this.page = new DevPagesPageNormalizer(pagesDir, extensions)\n    this.pathname = new DevPagesPathnameNormalizer(pagesDir, extensions)\n    this.bundlePath = new DevPagesBundlePathNormalizer(this.page)\n  }\n}\n"],"names":["DevPagesBundlePathNormalizer","PagesBundlePathNormalizer","PagesFilenameNormalizer","DevPagesPageNormalizer","DevPagesPathnameNormalizer","PagesNormalizers","constructor","distDir","filename","bundlePath","DevPagesNormalizers","pagesDir","extensions","page","pathname"],"mappings":";;;;AAAA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,iCAAgC;AACvC,SAASC,uBAAuB,QAAQ,8BAA6B;AACrE,SAASC,sBAAsB,QAAQ,0BAAyB;AAChE,SAASC,0BAA0B,QAAQ,8BAA6B;;;;;AAEjE,MAAMC;IAIXC,YAAYC,OAAe,CAAE;QAC3B,IAAI,CAACC,QAAQ,GAAG,8NAAIN,0BAAAA,CAAwBK;QAC5C,IAAI,CAACE,UAAU,GAAG,oOAAIR,4BAAAA;IAEtB,sEAAsE;IACtE,sEAAsE;IACtE,wEAAwE;IAC1E;AACF;AAEO,MAAMS;IAKXJ,YAAYK,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,IAAI,CAACC,IAAI,GAAG,0NAAIV,yBAAAA,CAAuBQ,UAAUC;QACjD,IAAI,CAACE,QAAQ,GAAG,8NAAIV,6BAAAA,CAA2BO,UAAUC;QACzD,IAAI,CAACH,UAAU,GAAG,oOAAIT,+BAAAA,CAA6B,IAAI,CAACa,IAAI;IAC9D;AACF","ignoreList":[0]}},
    {"offset": {"line": 4542, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/suffix.ts"],"sourcesContent":["import type { Normalizer } from '../normalizer'\n\nexport class SuffixPathnameNormalizer implements Normalizer {\n  constructor(private readonly suffix: string) {}\n\n  public match(pathname: string) {\n    // If the pathname doesn't end in the suffix, we don't match.\n    if (!pathname.endsWith(this.suffix)) return false\n\n    return true\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    return pathname.substring(0, pathname.length - this.suffix.length)\n  }\n}\n"],"names":["SuffixPathnameNormalizer","constructor","suffix","match","pathname","endsWith","normalize","matched","substring","length"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAc,CAAE;aAAhBA,MAAAA,GAAAA;IAAiB;IAEvCC,MAAMC,QAAgB,EAAE;QAC7B,6DAA6D;QAC7D,IAAI,CAACA,SAASC,QAAQ,CAAC,IAAI,CAACH,MAAM,GAAG,OAAO;QAE5C,OAAO;IACT;IAEOI,UAAUF,QAAgB,EAAEG,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACJ,KAAK,CAACC,WAAW,OAAOA;QAE9C,OAAOA,SAASI,SAAS,CAAC,GAAGJ,SAASK,MAAM,GAAG,IAAI,CAACP,MAAM,CAACO,MAAM;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4566, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/rsc.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { RSC_SUFFIX } from '../../../lib/constants'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class RSCPathnameNormalizer\n  extends SuffixPathnameNormalizer\n  implements PathnameNormalizer\n{\n  constructor() {\n    super(RSC_SUFFIX)\n  }\n}\n"],"names":["RSC_SUFFIX","SuffixPathnameNormalizer","RSCPathnameNormalizer","constructor"],"mappings":";;;AAEA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,wBAAwB,QAAQ,WAAU;;;AAE5C,MAAMC,wNACHD,2BAAAA;IAGRE,aAAc;QACZ,KAAK,iKAACH,aAAAA;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 4584, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/prefetch-rsc.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { RSC_PREFETCH_SUFFIX } from '../../../lib/constants'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class PrefetchRSCPathnameNormalizer\n  extends SuffixPathnameNormalizer\n  implements PathnameNormalizer\n{\n  constructor() {\n    super(RSC_PREFETCH_SUFFIX)\n  }\n\n  public match(pathname: string): boolean {\n    if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {\n      return true\n    }\n\n    return super.match(pathname)\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {\n      return '/'\n    }\n\n    return super.normalize(pathname, matched)\n  }\n}\n"],"names":["RSC_PREFETCH_SUFFIX","SuffixPathnameNormalizer","PrefetchRSCPathnameNormalizer","constructor","match","pathname","normalize","matched"],"mappings":";;;AAEA,SAASA,mBAAmB,QAAQ,yBAAwB;AAC5D,SAASC,wBAAwB,QAAQ,WAAU;;;AAE5C,MAAMC,gOACHD,2BAAAA;IAGRE,aAAc;QACZ,KAAK,iKAACH,sBAAAA;IACR;IAEOI,MAAMC,QAAgB,EAAW;QACtC,IAAIA,aAAa,6KAAaL,sBAAAA,EAAqB;YACjD,OAAO;QACT;QAEA,OAAO,KAAK,CAACI,MAAMC;IACrB;IAEOC,UAAUD,QAAgB,EAAEE,OAAiB,EAAU;QAC5D,IAAIF,aAAa,6KAAaL,sBAAAA,EAAqB;YACjD,OAAO;QACT;QAEA,OAAO,KAAK,CAACM,UAAUD,UAAUE;IACnC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4614, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/prefix.ts"],"sourcesContent":["import type { Normalizer } from '../normalizer'\n\nexport class PrefixPathnameNormalizer implements Normalizer {\n  constructor(private readonly prefix: string) {\n    if (prefix.endsWith('/')) {\n      throw new Error(\n        `PrefixPathnameNormalizer: prefix \"${prefix}\" should not end with a slash`\n      )\n    }\n  }\n\n  public match(pathname: string) {\n    // If the pathname doesn't start with the prefix, we don't match.\n    if (pathname !== this.prefix && !pathname.startsWith(this.prefix + '/')) {\n      return false\n    }\n\n    return true\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    if (pathname.length === this.prefix.length) {\n      return '/'\n    }\n\n    return pathname.substring(this.prefix.length)\n  }\n}\n"],"names":["PrefixPathnameNormalizer","constructor","prefix","endsWith","Error","match","pathname","startsWith","normalize","matched","length","substring"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAc,CAAE;aAAhBA,MAAAA,GAAAA;QAC3B,IAAIA,OAAOC,QAAQ,CAAC,MAAM;YACxB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,kCAAkC,EAAEF,OAAO,6BAA6B,CAAC,GADtE,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;IAEOG,MAAMC,QAAgB,EAAE;QAC7B,iEAAiE;QACjE,IAAIA,aAAa,IAAI,CAACJ,MAAM,IAAI,CAACI,SAASC,UAAU,CAAC,IAAI,CAACL,MAAM,GAAG,MAAM;YACvE,OAAO;QACT;QAEA,OAAO;IACT;IAEOM,UAAUF,QAAgB,EAAEG,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACJ,KAAK,CAACC,WAAW,OAAOA;QAE9C,IAAIA,SAASI,MAAM,KAAK,IAAI,CAACR,MAAM,CAACQ,MAAM,EAAE;YAC1C,OAAO;QACT;QAEA,OAAOJ,SAASK,SAAS,CAAC,IAAI,CAACT,MAAM,CAACQ,MAAM;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4650, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/next-data.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { denormalizePagePath } from '../../../shared/lib/page-path/denormalize-page-path'\nimport { PrefixPathnameNormalizer } from './prefix'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class NextDataPathnameNormalizer implements PathnameNormalizer {\n  private readonly prefix: PrefixPathnameNormalizer\n  private readonly suffix = new SuffixPathnameNormalizer('.json')\n  constructor(buildID: string) {\n    if (!buildID) {\n      throw new Error('Invariant: buildID is required')\n    }\n\n    this.prefix = new PrefixPathnameNormalizer(`/_next/data/${buildID}`)\n  }\n\n  public match(pathname: string) {\n    return this.prefix.match(pathname) && this.suffix.match(pathname)\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    pathname = this.prefix.normalize(pathname, true)\n    pathname = this.suffix.normalize(pathname, true)\n\n    return denormalizePagePath(pathname)\n  }\n}\n"],"names":["denormalizePagePath","PrefixPathnameNormalizer","SuffixPathnameNormalizer","NextDataPathnameNormalizer","constructor","buildID","suffix","Error","prefix","match","pathname","normalize","matched"],"mappings":";;;AAEA,SAASA,mBAAmB,QAAQ,sDAAqD;AACzF,SAASC,wBAAwB,QAAQ,WAAU;AACnD,SAASC,wBAAwB,QAAQ,WAAU;;;;AAE5C,MAAMC;IAGXC,YAAYC,OAAe,CAAE;aADZC,MAAAA,GAAS,8LAAIJ,2BAAAA,CAAyB;QAErD,IAAI,CAACG,SAAS;YACZ,MAAM,OAAA,cAA2C,CAA3C,IAAIE,MAAM,mCAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0C;QAClD;QAEA,IAAI,CAACC,MAAM,GAAG,8LAAIP,2BAAAA,CAAyB,CAAC,YAAY,EAAEI,SAAS;IACrE;IAEOI,MAAMC,QAAgB,EAAE;QAC7B,OAAO,IAAI,CAACF,MAAM,CAACC,KAAK,CAACC,aAAa,IAAI,CAACJ,MAAM,CAACG,KAAK,CAACC;IAC1D;IAEOC,UAAUD,QAAgB,EAAEE,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACH,KAAK,CAACC,WAAW,OAAOA;QAE9CA,WAAW,IAAI,CAACF,MAAM,CAACG,SAAS,CAACD,UAAU;QAC3CA,WAAW,IAAI,CAACJ,MAAM,CAACK,SAAS,CAACD,UAAU;QAE3C,uNAAOV,sBAAAA,EAAoBU;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 4688, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/normalizers/request/segment-prefix-rsc.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport {\n  RSC_SEGMENT_SUFFIX,\n  RSC_SEGMENTS_DIR_SUFFIX,\n} from '../../../lib/constants'\n\nconst PATTERN = new RegExp(\n  `^(/.*)${RSC_SEGMENTS_DIR_SUFFIX}(/.*)${RSC_SEGMENT_SUFFIX}$`\n)\n\nexport class SegmentPrefixRSCPathnameNormalizer implements PathnameNormalizer {\n  public match(pathname: string): boolean {\n    return PATTERN.test(pathname)\n  }\n\n  public extract(pathname: string) {\n    const match = pathname.match(PATTERN)\n    if (!match) return null\n\n    return { originalPathname: match[1], segmentPath: match[2] }\n  }\n\n  public normalize(pathname: string): string {\n    const match = this.extract(pathname)\n    if (!match) return pathname\n\n    return match.originalPathname\n  }\n}\n"],"names":["RSC_SEGMENT_SUFFIX","RSC_SEGMENTS_DIR_SUFFIX","PATTERN","RegExp","SegmentPrefixRSCPathnameNormalizer","match","pathname","test","extract","originalPathname","segmentPath","normalize"],"mappings":";;;AAEA,SACEA,kBAAkB,EAClBC,uBAAuB,QAClB,yBAAwB;;AAE/B,MAAMC,UAAU,IAAIC,OAClB,CAAC,MAAM,kKAAEF,0BAAAA,CAAwB,KAAK,kKAAED,qBAAAA,CAAmB,CAAC,CAAC;AAGxD,MAAMI;IACJC,MAAMC,QAAgB,EAAW;QACtC,OAAOJ,QAAQK,IAAI,CAACD;IACtB;IAEOE,QAAQF,QAAgB,EAAE;QAC/B,MAAMD,QAAQC,SAASD,KAAK,CAACH;QAC7B,IAAI,CAACG,OAAO,OAAO;QAEnB,OAAO;YAAEI,kBAAkBJ,KAAK,CAAC,EAAE;YAAEK,aAAaL,KAAK,CAAC,EAAE;QAAC;IAC7D;IAEOM,UAAUL,QAAgB,EAAU;QACzC,MAAMD,QAAQ,IAAI,CAACG,OAAO,CAACF;QAC3B,IAAI,CAACD,OAAO,OAAOC;QAEnB,OAAOD,MAAMI,gBAAgB;IAC/B;AACF","ignoreList":[0]}},
    {"offset": {"line": 4718, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/route-matcher.ts"],"sourcesContent":["import type { RouteMatch } from '../route-matches/route-match'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Params } from '../request/params'\n\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport {\n  getRouteMatcher,\n  type RouteMatchFn,\n} from '../../shared/lib/router/utils/route-matcher'\nimport { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\n\ntype RouteMatchResult = {\n  params?: Params\n}\n\nexport class RouteMatcher<D extends RouteDefinition = RouteDefinition> {\n  private readonly dynamic?: RouteMatchFn\n\n  /**\n   * When set, this is an array of all the other matchers that are duplicates of\n   * this one. This is used by the managers to warn the users about possible\n   * duplicate matches on routes.\n   */\n  public duplicated?: Array<RouteMatcher>\n\n  constructor(public readonly definition: D) {\n    if (isDynamicRoute(definition.pathname)) {\n      this.dynamic = getRouteMatcher(getRouteRegex(definition.pathname))\n    }\n  }\n\n  /**\n   * Identity returns the identity part of the matcher. This is used to compare\n   * a unique matcher to another. This is also used when sorting dynamic routes,\n   * so it must contain the pathname part.\n   */\n  public get identity(): string {\n    return this.definition.pathname\n  }\n\n  public get isDynamic() {\n    return this.dynamic !== undefined\n  }\n\n  public match(pathname: string): RouteMatch<D> | null {\n    const result = this.test(pathname)\n    if (!result) return null\n\n    return { definition: this.definition, params: result.params }\n  }\n\n  public test(pathname: string): RouteMatchResult | null {\n    if (this.dynamic) {\n      const params = this.dynamic(pathname)\n      if (!params) return null\n\n      return { params }\n    }\n\n    if (pathname === this.definition.pathname) {\n      return {}\n    }\n\n    return null\n  }\n}\n"],"names":["isDynamicRoute","getRouteMatcher","getRouteRegex","RouteMatcher","constructor","definition","pathname","dynamic","identity","isDynamic","undefined","match","result","test","params"],"mappings":";;;AAIA,SAASA,cAAc,QAAQ,gCAA+B;;AAC9D,SACEC,eAAe,QAEV,8CAA6C;AACpD,SAASC,aAAa,QAAQ,4CAA2C;;;;AAMlE,MAAMC;IAUXC,YAA4BC,UAAa,CAAE;aAAfA,UAAAA,GAAAA;QAC1B,yMAAIL,iBAAAA,EAAeK,WAAWC,QAAQ,GAAG;YACvC,IAAI,CAACC,OAAO,2MAAGN,kBAAAA,wMAAgBC,gBAAAA,EAAcG,WAAWC,QAAQ;QAClE;IACF;IAEA;;;;GAIC,GACD,IAAWE,WAAmB;QAC5B,OAAO,IAAI,CAACH,UAAU,CAACC,QAAQ;IACjC;IAEA,IAAWG,YAAY;QACrB,OAAO,IAAI,CAACF,OAAO,KAAKG;IAC1B;IAEOC,MAAML,QAAgB,EAAwB;QACnD,MAAMM,SAAS,IAAI,CAACC,IAAI,CAACP;QACzB,IAAI,CAACM,QAAQ,OAAO;QAEpB,OAAO;YAAEP,YAAY,IAAI,CAACA,UAAU;YAAES,QAAQF,OAAOE,MAAM;QAAC;IAC9D;IAEOD,KAAKP,QAAgB,EAA2B;QACrD,IAAI,IAAI,CAACC,OAAO,EAAE;YAChB,MAAMO,SAAS,IAAI,CAACP,OAAO,CAACD;YAC5B,IAAI,CAACQ,QAAQ,OAAO;YAEpB,OAAO;gBAAEA;YAAO;QAClB;QAEA,IAAIR,aAAa,IAAI,CAACD,UAAU,CAACC,QAAQ,EAAE;YACzC,OAAO,CAAC;QACV;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 4773, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/locale-route-matcher.ts"],"sourcesContent":["import type { LocaleAnalysisResult } from '../lib/i18n-provider'\nimport type { LocaleRouteDefinition } from '../route-definitions/locale-route-definition'\nimport type { LocaleRouteMatch } from '../route-matches/locale-route-match'\nimport { RouteMatcher } from './route-matcher'\n\nexport type LocaleMatcherMatchOptions = {\n  /**\n   * If defined, this indicates to the matcher that the request should be\n   * treated as locale-aware. If this is undefined, it means that this\n   * application was not configured for additional locales.\n   */\n  i18n?: LocaleAnalysisResult\n}\n\nexport class LocaleRouteMatcher<\n  D extends LocaleRouteDefinition = LocaleRouteDefinition,\n> extends RouteMatcher<D> {\n  /**\n   * Identity returns the identity part of the matcher. This is used to compare\n   * a unique matcher to another. This is also used when sorting dynamic routes,\n   * so it must contain the pathname part as well.\n   */\n  public get identity(): string {\n    return `${this.definition.pathname}?__nextLocale=${this.definition.i18n?.locale}`\n  }\n\n  /**\n   * Match will attempt to match the given pathname against this route while\n   * also taking into account the locale information.\n   *\n   * @param pathname The pathname to match against.\n   * @param options The options to use when matching.\n   * @returns The match result, or `null` if there was no match.\n   */\n  public match(\n    pathname: string,\n    options?: LocaleMatcherMatchOptions\n  ): LocaleRouteMatch<D> | null {\n    // This is like the parent `match` method but instead this injects the\n    // additional `options` into the\n    const result = this.test(pathname, options)\n    if (!result) return null\n\n    return {\n      definition: this.definition,\n      params: result.params,\n      detectedLocale:\n        // If the options have a detected locale, then use that, otherwise use\n        // the route's locale.\n        options?.i18n?.detectedLocale ?? this.definition.i18n?.locale,\n    }\n  }\n\n  /**\n   * Test will attempt to match the given pathname against this route while\n   * also taking into account the locale information.\n   *\n   * @param pathname The pathname to match against.\n   * @param options The options to use when matching.\n   * @returns The match result, or `null` if there was no match.\n   */\n  public test(pathname: string, options?: LocaleMatcherMatchOptions) {\n    // If this route has locale information and we have detected a locale, then\n    // we need to compare the detected locale to the route's locale.\n    if (this.definition.i18n && options?.i18n) {\n      // If we have detected a locale and it does not match this route's locale,\n      // then this isn't a match!\n      if (\n        this.definition.i18n.locale &&\n        options.i18n.detectedLocale &&\n        this.definition.i18n.locale !== options.i18n.detectedLocale\n      ) {\n        return null\n      }\n\n      // Perform regular matching against the locale stripped pathname now, the\n      // locale information matches!\n      return super.test(options.i18n.pathname)\n    }\n\n    // If we don't have locale information, then we can just perform regular\n    // matching.\n    return super.test(pathname)\n  }\n}\n"],"names":["RouteMatcher","LocaleRouteMatcher","identity","definition","pathname","i18n","locale","match","options","result","test","params","detectedLocale"],"mappings":";;;AAGA,SAASA,YAAY,QAAQ,kBAAiB;;AAWvC,MAAMC,0NAEHD,eAAAA;IACR;;;;GAIC,GACD,IAAWE,WAAmB;YACuB;QAAnD,OAAO,GAAG,IAAI,CAACC,UAAU,CAACC,QAAQ,CAAC,cAAc,EAAA,CAAE,wBAAA,IAAI,CAACD,UAAU,CAACE,IAAI,KAAA,OAAA,KAAA,IAApB,sBAAsBC,MAAM,EAAE;IACnF;IAEA;;;;;;;GAOC,GACMC,MACLH,QAAgB,EAChBI,OAAmC,EACP;YAUxB,AACA,sBAAsB,gDADgD;QAEtEA,eAAiC;QAXrC,sEAAsE;QACtE,gCAAgC;QAChC,MAAMC,SAAS,IAAI,CAACC,IAAI,CAACN,UAAUI;QACnC,IAAI,CAACC,QAAQ,OAAO;QAEpB,OAAO;YACLN,YAAY,IAAI,CAACA,UAAU;YAC3BQ,QAAQF,OAAOE,MAAM;YACrBC,gBAGEJ,CAAAA,WAAAA,OAAAA,KAAAA,IAAAA,CAAAA,gBAAAA,QAASH,IAAI,KAAA,OAAA,KAAA,IAAbG,cAAeI,cAAc,KAAA,CAAA,CAAI,wBAAA,IAAI,CAACT,UAAU,CAACE,IAAI,KAAA,OAAA,KAAA,IAApB,sBAAsBC,MAAM;QACjE;IACF;IAEA;;;;;;;GAOC,GACMI,KAAKN,QAAgB,EAAEI,OAAmC,EAAE;QACjE,2EAA2E;QAC3E,gEAAgE;QAChE,IAAI,IAAI,CAACL,UAAU,CAACE,IAAI,IAAA,CAAIG,WAAAA,OAAAA,KAAAA,IAAAA,QAASH,IAAI,GAAE;YACzC,0EAA0E;YAC1E,2BAA2B;YAC3B,IACE,IAAI,CAACF,UAAU,CAACE,IAAI,CAACC,MAAM,IAC3BE,QAAQH,IAAI,CAACO,cAAc,IAC3B,IAAI,CAACT,UAAU,CAACE,IAAI,CAACC,MAAM,KAAKE,QAAQH,IAAI,CAACO,cAAc,EAC3D;gBACA,OAAO;YACT;YAEA,yEAAyE;YACzE,8BAA8B;YAC9B,OAAO,KAAK,CAACF,KAAKF,QAAQH,IAAI,CAACD,QAAQ;QACzC;QAEA,wEAAwE;QACxE,YAAY;QACZ,OAAO,KAAK,CAACM,KAAKN;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4838, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/app-page-route-matcher.ts"],"sourcesContent":["import { RouteMatcher } from './route-matcher'\nimport type { AppPageRouteDefinition } from '../route-definitions/app-page-route-definition'\n\nexport class AppPageRouteMatcher extends RouteMatcher<AppPageRouteDefinition> {\n  public get identity(): string {\n    return `${this.definition.pathname}?__nextPage=${this.definition.page}`\n  }\n}\n"],"names":["RouteMatcher","AppPageRouteMatcher","identity","definition","pathname","page"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,kBAAiB;;AAGvC,MAAMC,2NAA4BD,eAAAA;IACvC,IAAWE,WAAmB;QAC5B,OAAO,GAAG,IAAI,CAACC,UAAU,CAACC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAACD,UAAU,CAACE,IAAI,EAAE;IACzE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4854, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/app-route-route-matcher.ts"],"sourcesContent":["import { RouteMatcher } from './route-matcher'\nimport type { AppRouteRouteDefinition } from '../route-definitions/app-route-route-definition'\n\nexport class AppRouteRouteMatcher extends RouteMatcher<AppRouteRouteDefinition> {}\n"],"names":["RouteMatcher","AppRouteRouteMatcher"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,kBAAiB;;AAGvC,MAAMC,4NAA6BD,eAAAA;AAAuC","ignoreList":[0]}},
    {"offset": {"line": 4867, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/pages-api-route-matcher.ts"],"sourcesContent":["import type { PagesAPIRouteDefinition } from '../route-definitions/pages-api-route-definition'\nimport { LocaleRouteMatcher } from './locale-route-matcher'\nimport { RouteMatcher } from './route-matcher'\n\nexport class PagesAPIRouteMatcher extends RouteMatcher<PagesAPIRouteDefinition> {}\n\nexport class PagesAPILocaleRouteMatcher extends LocaleRouteMatcher<PagesAPIRouteDefinition> {}\n"],"names":["LocaleRouteMatcher","RouteMatcher","PagesAPIRouteMatcher","PagesAPILocaleRouteMatcher"],"mappings":";;;;AACA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SAASC,YAAY,QAAQ,kBAAiB;;;AAEvC,MAAMC,4NAA6BD,eAAAA;AAAuC;AAE1E,MAAME,4OAAmCH,qBAAAA;AAA6C","ignoreList":[0]}},
    {"offset": {"line": 4885, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matchers/pages-route-matcher.ts"],"sourcesContent":["import type { PagesRouteDefinition } from '../route-definitions/pages-route-definition'\nimport { LocaleRouteMatcher } from './locale-route-matcher'\nimport { RouteMatcher } from './route-matcher'\n\nexport class PagesRouteMatcher extends RouteMatcher<PagesRouteDefinition> {}\n\nexport class PagesLocaleRouteMatcher extends LocaleRouteMatcher<PagesRouteDefinition> {}\n"],"names":["LocaleRouteMatcher","RouteMatcher","PagesRouteMatcher","PagesLocaleRouteMatcher"],"mappings":";;;;AACA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SAASC,YAAY,QAAQ,kBAAiB;;;AAEvC,MAAMC,yNAA0BD,eAAAA;AAAoC;AAEpE,MAAME,yOAAgCH,qBAAAA;AAA0C","ignoreList":[0]}},
    {"offset": {"line": 4903, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-managers/default-route-matcher-manager.ts"],"sourcesContent":["import { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { RouteKind } from '../route-kind'\nimport type { RouteMatch } from '../route-matches/route-match'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { RouteMatcherProvider } from '../route-matcher-providers/route-matcher-provider'\nimport type { RouteMatcher } from '../route-matchers/route-matcher'\nimport type { MatchOptions, RouteMatcherManager } from './route-matcher-manager'\nimport { getSortedRoutes } from '../../shared/lib/router/utils'\nimport { LocaleRouteMatcher } from '../route-matchers/locale-route-matcher'\nimport { ensureLeadingSlash } from '../../shared/lib/page-path/ensure-leading-slash'\nimport { DetachedPromise } from '../../lib/detached-promise'\n\ninterface RouteMatchers {\n  static: ReadonlyArray<RouteMatcher>\n  dynamic: ReadonlyArray<RouteMatcher>\n  duplicates: Record<string, ReadonlyArray<RouteMatcher>>\n}\n\nexport class DefaultRouteMatcherManager implements RouteMatcherManager {\n  private readonly providers: Array<RouteMatcherProvider> = []\n  protected readonly matchers: RouteMatchers = {\n    static: [],\n    dynamic: [],\n    duplicates: {},\n  }\n  private lastCompilationID = this.compilationID\n\n  /**\n   * When this value changes, it indicates that a change has been introduced\n   * that requires recompilation.\n   */\n  private get compilationID() {\n    return this.providers.length\n  }\n\n  private waitTillReadyPromise?: Promise<void>\n  public async waitTillReady(): Promise<void> {\n    if (this.waitTillReadyPromise) {\n      await this.waitTillReadyPromise\n      delete this.waitTillReadyPromise\n    }\n  }\n\n  private previousMatchers: ReadonlyArray<RouteMatcher> = []\n  public async reload() {\n    const { promise, resolve, reject } = new DetachedPromise<void>()\n    this.waitTillReadyPromise = promise\n\n    // Grab the compilation ID for this run, we'll verify it at the end to\n    // ensure that if any routes were added before reloading is finished that\n    // we error out.\n    const compilationID = this.compilationID\n\n    try {\n      // Collect all the matchers from each provider.\n      const matchers: Array<RouteMatcher> = []\n\n      // Get all the providers matchers.\n      const providersMatchers: ReadonlyArray<ReadonlyArray<RouteMatcher>> =\n        await Promise.all(this.providers.map((provider) => provider.matchers()))\n\n      // Use this to detect duplicate pathnames.\n      const all = new Map<string, RouteMatcher>()\n      const duplicates: Record<string, RouteMatcher[]> = {}\n      for (const providerMatchers of providersMatchers) {\n        for (const matcher of providerMatchers) {\n          // Reset duplicated matches when reloading from pages conflicting state.\n          if (matcher.duplicated) delete matcher.duplicated\n          // Test to see if the matcher being added is a duplicate.\n          const duplicate = all.get(matcher.definition.pathname)\n          if (duplicate) {\n            // This looks a little weird, but essentially if the pathname\n            // already exists in the duplicates map, then we got that array\n            // reference. Otherwise, we create a new array with the original\n            // duplicate first. Then we push the new matcher into the duplicate\n            // array, and reset it to the duplicates object (which may be a\n            // no-op if the pathname already existed in the duplicates object).\n            // Then we set the array of duplicates on both the original\n            // duplicate object and the new one, so we can keep them in sync.\n            // If a new duplicate is found, and it matches an existing pathname,\n            // the retrieval of the `other` will actually return the array\n            // reference used by all other duplicates. This is why ReadonlyArray\n            // is so important! Array's are always references!\n            const others = duplicates[matcher.definition.pathname] ?? [\n              duplicate,\n            ]\n            others.push(matcher)\n            duplicates[matcher.definition.pathname] = others\n\n            // Add duplicated details to each route.\n            duplicate.duplicated = others\n            matcher.duplicated = others\n\n            // TODO: see if we should error for duplicates in production?\n          }\n\n          matchers.push(matcher)\n\n          // Add the matcher's pathname to the set.\n          all.set(matcher.definition.pathname, matcher)\n        }\n      }\n\n      // Update the duplicate matchers. This is used in the development manager\n      // to warn about duplicates.\n      this.matchers.duplicates = duplicates\n\n      // If the cache is the same as what we just parsed, we can exit now. We\n      // can tell by using the `===` which compares object identity, which for\n      // the manifest matchers, will return the same matcher each time.\n      if (\n        this.previousMatchers.length === matchers.length &&\n        this.previousMatchers.every(\n          (cachedMatcher, index) => cachedMatcher === matchers[index]\n        )\n      ) {\n        return\n      }\n      this.previousMatchers = matchers\n\n      // For matchers that are for static routes, filter them now.\n      this.matchers.static = matchers.filter((matcher) => !matcher.isDynamic)\n\n      // For matchers that are for dynamic routes, filter them and sort them now.\n      const dynamic = matchers.filter((matcher) => matcher.isDynamic)\n\n      // As `getSortedRoutes` only takes an array of strings, we need to create\n      // a map of the pathnames (used for sorting) and the matchers. When we\n      // have locales, there may be multiple matches for the same pathname. To\n      // handle this, we keep a map of all the indexes (in `reference`) and\n      // merge them in later.\n\n      const reference = new Map<string, number[]>()\n      const pathnames = new Array<string>()\n      for (let index = 0; index < dynamic.length; index++) {\n        // Grab the pathname from the definition.\n        const pathname = dynamic[index].definition.pathname\n\n        // Grab the index in the dynamic array, push it into the reference.\n        const indexes = reference.get(pathname) ?? []\n        indexes.push(index)\n\n        // If this is the first one set it. If it isn't, we don't need to\n        // because pushing above on the array will mutate the array already\n        // stored there because array's are always a reference!\n        if (indexes.length === 1) reference.set(pathname, indexes)\n        // Otherwise, continue, we've already added this pathname before.\n        else continue\n\n        pathnames.push(pathname)\n      }\n\n      // Sort the array of pathnames.\n      const sorted = getSortedRoutes(pathnames)\n\n      // For each of the sorted pathnames, iterate over them, grabbing the list\n      // of indexes and merging them back into the new `sortedDynamicMatchers`\n      // array. The order of the same matching pathname doesn't matter because\n      // they will have other matching characteristics (like the locale) that\n      // is considered.\n      const sortedDynamicMatchers: Array<RouteMatcher> = []\n      for (const pathname of sorted) {\n        const indexes = reference.get(pathname)\n        if (!Array.isArray(indexes)) {\n          throw new Error('Invariant: expected to find identity in indexes map')\n        }\n\n        const dynamicMatches = indexes.map((index) => dynamic[index])\n\n        sortedDynamicMatchers.push(...dynamicMatches)\n      }\n\n      this.matchers.dynamic = sortedDynamicMatchers\n\n      // This means that there was a new matcher pushed while we were waiting\n      if (this.compilationID !== compilationID) {\n        throw new Error(\n          'Invariant: expected compilation to finish before new matchers were added, possible missing await'\n        )\n      }\n    } catch (err) {\n      reject(err)\n    } finally {\n      // The compilation ID matched, so mark the complication as finished.\n      this.lastCompilationID = compilationID\n      resolve()\n    }\n  }\n\n  public push(provider: RouteMatcherProvider): void {\n    this.providers.push(provider)\n  }\n\n  public async test(pathname: string, options: MatchOptions): Promise<boolean> {\n    // See if there's a match for the pathname...\n    const match = await this.match(pathname, options)\n\n    // This default implementation only needs to check to see if there _was_ a\n    // match. The development matcher actually changes it's behavior by not\n    // recompiling the routes.\n    return match !== null\n  }\n\n  public async match(\n    pathname: string,\n    options: MatchOptions\n  ): Promise<RouteMatch<RouteDefinition<RouteKind>> | null> {\n    // \"Iterate\" over the match options. Once we found a single match, exit with\n    // it, otherwise return null below. If no match is found, the inner block\n    // won't be called.\n    for await (const match of this.matchAll(pathname, options)) {\n      return match\n    }\n\n    return null\n  }\n\n  /**\n   * This is a point for other managers to override to inject other checking\n   * behavior like duplicate route checking on a per-request basis.\n   *\n   * @param pathname the pathname to validate against\n   * @param matcher the matcher to validate/test with\n   * @returns the match if found\n   */\n  protected validate(\n    pathname: string,\n    matcher: RouteMatcher,\n    options: MatchOptions\n  ): RouteMatch | null {\n    if (matcher instanceof LocaleRouteMatcher) {\n      return matcher.match(pathname, options)\n    }\n\n    // If the locale was inferred from the default locale, then it will have\n    // already added a locale to the pathname. We need to remove it before\n    // matching because this matcher is not locale aware.\n    if (options.i18n?.inferredFromDefault) {\n      return matcher.match(options.i18n.pathname)\n    }\n\n    return matcher.match(pathname)\n  }\n\n  public async *matchAll(\n    pathname: string,\n    options: MatchOptions\n  ): AsyncGenerator<RouteMatch<RouteDefinition<RouteKind>>, null, undefined> {\n    // Guard against the matcher manager from being run before it needs to be\n    // recompiled. This was preferred to re-running the compilation here because\n    // it should be re-ran only when it changes. If a match is attempted before\n    // this is done, it indicates that there is a case where a provider is added\n    // before it was recompiled (an error). We also don't want to affect request\n    // times.\n    if (this.lastCompilationID !== this.compilationID) {\n      throw new Error(\n        'Invariant: expected routes to have been loaded before match'\n      )\n    }\n\n    // Ensure that path matching is done with a leading slash.\n    pathname = ensureLeadingSlash(pathname)\n\n    // If this pathname doesn't look like a dynamic route, and this pathname is\n    // listed in the normalized list of routes, then return it. This ensures\n    // that when a route like `/user/[id]` is encountered, it doesn't just match\n    // with the list of normalized routes.\n    if (!isDynamicRoute(pathname)) {\n      for (const matcher of this.matchers.static) {\n        const match = this.validate(pathname, matcher, options)\n        if (!match) continue\n\n        yield match\n      }\n    }\n\n    // If we should skip handling dynamic routes, exit now.\n    if (options?.skipDynamic) return null\n\n    // Loop over the dynamic matchers, yielding each match.\n    for (const matcher of this.matchers.dynamic) {\n      const match = this.validate(pathname, matcher, options)\n      if (!match) continue\n\n      yield match\n    }\n\n    // We tried direct matching against the pathname and against all the dynamic\n    // paths, so there was no match.\n    return null\n  }\n}\n"],"names":["isDynamicRoute","getSortedRoutes","LocaleRouteMatcher","ensureLeadingSlash","DetachedPromise","DefaultRouteMatcherManager","compilationID","providers","length","waitTillReady","waitTillReadyPromise","reload","promise","resolve","reject","matchers","providersMatchers","Promise","all","map","provider","Map","duplicates","providerMatchers","matcher","duplicated","duplicate","get","definition","pathname","others","push","set","previousMatchers","every","cachedMatcher","index","static","filter","isDynamic","dynamic","reference","pathnames","Array","indexes","sorted","sortedDynamicMatchers","isArray","Error","dynamicMatches","err","lastCompilationID","test","options","match","matchAll","validate","i18n","inferredFromDefault","skipDynamic"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5146, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/helpers/cached-route-matcher-provider.ts"],"sourcesContent":["import type { RouteMatcherProvider } from '../route-matcher-provider'\nimport type { RouteMatcher } from '../../route-matchers/route-matcher'\n\ninterface LoaderComparable<D> {\n  load(): Promise<D>\n  compare(left: D, right: D): boolean\n}\n\n/**\n * This will memoize the matchers if the loaded data is comparable.\n */\nexport abstract class CachedRouteMatcherProvider<\n  M extends RouteMatcher = RouteMatcher,\n  D = any,\n> implements RouteMatcherProvider<M>\n{\n  private data?: D\n  private cached: ReadonlyArray<M> = []\n\n  constructor(private readonly loader: LoaderComparable<D>) {}\n\n  protected abstract transform(data: D): Promise<ReadonlyArray<M>>\n\n  public async matchers(): Promise<readonly M[]> {\n    const data = await this.loader.load()\n    if (!data) return []\n\n    // Return the cached matchers if the data has not changed.\n    if (this.data && this.loader.compare(this.data, data)) return this.cached\n    this.data = data\n\n    // Transform the manifest into matchers.\n    const matchers = await this.transform(data)\n\n    // Cache the matchers.\n    this.cached = matchers\n\n    return matchers\n  }\n}\n"],"names":["CachedRouteMatcherProvider","constructor","loader","cached","matchers","data","load","compare","transform"],"mappings":"AAQA;;CAEC,GACD;;;AAAO,MAAeA;IAQpBC,YAA6BC,MAA2B,CAAE;aAA7BA,MAAAA,GAAAA;aAFrBC,MAAAA,GAA2B,EAAE;IAEsB;IAI3D,MAAaC,WAAkC;QAC7C,MAAMC,OAAO,MAAM,IAAI,CAACH,MAAM,CAACI,IAAI;QACnC,IAAI,CAACD,MAAM,OAAO,EAAE;QAEpB,0DAA0D;QAC1D,IAAI,IAAI,CAACA,IAAI,IAAI,IAAI,CAACH,MAAM,CAACK,OAAO,CAAC,IAAI,CAACF,IAAI,EAAEA,OAAO,OAAO,IAAI,CAACF,MAAM;QACzE,IAAI,CAACE,IAAI,GAAGA;QAEZ,wCAAwC;QACxC,MAAMD,WAAW,MAAM,IAAI,CAACI,SAAS,CAACH;QAEtC,sBAAsB;QACtB,IAAI,CAACF,MAAM,GAAGC;QAEd,OAAOA;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5175, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/manifest-route-matcher-provider.ts"],"sourcesContent":["import type { RouteMatcher } from '../route-matchers/route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { CachedRouteMatcherProvider } from './helpers/cached-route-matcher-provider'\n\nexport abstract class ManifestRouteMatcherProvider<\n  M extends RouteMatcher = RouteMatcher,\n> extends CachedRouteMatcherProvider<M, Manifest | null> {\n  constructor(manifestName: string, manifestLoader: ManifestLoader) {\n    super({\n      load: async () => manifestLoader.load(manifestName),\n      compare: (left, right) => left === right,\n    })\n  }\n}\n"],"names":["CachedRouteMatcherProvider","ManifestRouteMatcherProvider","constructor","manifestName","manifestLoader","load","compare","left","right"],"mappings":";;;AAKA,SAASA,0BAA0B,QAAQ,0CAAyC;;AAE7E,MAAeC,iRAEZD,6BAAAA;IACRE,YAAYC,YAAoB,EAAEC,cAA8B,CAAE;QAChE,KAAK,CAAC;YACJC,MAAM,UAAYD,eAAeC,IAAI,CAACF;YACtCG,SAAS,CAACC,MAAMC,QAAUD,SAASC;QACrC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5194, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/app-page-route-matcher-provider.ts"],"sourcesContent":["import { isAppPageRoute } from '../../lib/is-app-page-route'\n\nimport { APP_PATHS_MANIFEST } from '../../shared/lib/constants'\nimport { AppNormalizers } from '../normalizers/built/app'\nimport { RouteKind } from '../route-kind'\nimport { AppPageRouteMatcher } from '../route-matchers/app-page-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\n\nexport class AppPageRouteMatcherProvider extends ManifestRouteMatcherProvider<AppPageRouteMatcher> {\n  private readonly normalizers: AppNormalizers\n\n  constructor(distDir: string, manifestLoader: ManifestLoader) {\n    super(APP_PATHS_MANIFEST, manifestLoader)\n\n    this.normalizers = new AppNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<AppPageRouteMatcher>> {\n    // This matcher only matches app pages.\n    const pages = Object.keys(manifest).filter((page) => isAppPageRoute(page))\n\n    // Collect all the app paths for each page. This could include any parallel\n    // routes.\n    const allAppPaths: Record<string, string[]> = {}\n    for (const page of pages) {\n      const pathname = this.normalizers.pathname.normalize(page)\n      if (pathname in allAppPaths) allAppPaths[pathname].push(page)\n      else allAppPaths[pathname] = [page]\n    }\n\n    // Format the routes.\n    const matchers: Array<AppPageRouteMatcher> = []\n    for (const [pathname, appPaths] of Object.entries(allAppPaths)) {\n      // TODO-APP: (wyattjoh) this is a hack right now, should be more deterministic\n      const page = appPaths[0]\n\n      const filename = this.normalizers.filename.normalize(manifest[page])\n      const bundlePath = this.normalizers.bundlePath.normalize(page)\n\n      matchers.push(\n        new AppPageRouteMatcher({\n          kind: RouteKind.APP_PAGE,\n          pathname,\n          page,\n          bundlePath,\n          filename,\n          appPaths,\n        })\n      )\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAppPageRoute","APP_PATHS_MANIFEST","AppNormalizers","RouteKind","AppPageRouteMatcher","ManifestRouteMatcherProvider","AppPageRouteMatcherProvider","constructor","distDir","manifestLoader","normalizers","transform","manifest","pages","Object","keys","filter","page","allAppPaths","pathname","normalize","push","matchers","appPaths","entries","filename","bundlePath","kind","APP_PAGE"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,8BAA6B;AAE5D,SAASC,kBAAkB,QAAQ,6BAA4B;;AAC/D,SAASC,cAAc,QAAQ,2BAA0B;AACzD,SAASC,SAAS,QAAQ,gBAAe;AACzC,SAASC,mBAAmB,QAAQ,2CAA0C;AAK9E,SAASC,4BAA4B,QAAQ,oCAAmC;;;;;;;AAEzE,MAAMC,uQAAoCD,+BAAAA;IAG/CE,YAAYC,OAAe,EAAEC,cAA8B,CAAE;QAC3D,KAAK,2LAACR,qBAAAA,EAAoBQ;QAE1B,IAAI,CAACC,WAAW,GAAG,kMAAIR,iBAAAA,CAAeM;IACxC;IAEA,MAAgBG,UACdC,QAAkB,EAC2B;QAC7C,uCAAuC;QACvC,MAAMC,QAAQC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,OAASjB,sMAAAA,EAAeiB;QAEpE,2EAA2E;QAC3E,UAAU;QACV,MAAMC,cAAwC,CAAC;QAC/C,KAAK,MAAMD,QAAQJ,MAAO;YACxB,MAAMM,WAAW,IAAI,CAACT,WAAW,CAACS,QAAQ,CAACC,SAAS,CAACH;YACrD,IAAIE,YAAYD,aAAaA,WAAW,CAACC,SAAS,CAACE,IAAI,CAACJ;iBACnDC,WAAW,CAACC,SAAS,GAAG;gBAACF;aAAK;QACrC;QAEA,qBAAqB;QACrB,MAAMK,WAAuC,EAAE;QAC/C,KAAK,MAAM,CAACH,UAAUI,SAAS,IAAIT,OAAOU,OAAO,CAACN,aAAc;YAC9D,8EAA8E;YAC9E,MAAMD,OAAOM,QAAQ,CAAC,EAAE;YAExB,MAAME,WAAW,IAAI,CAACf,WAAW,CAACe,QAAQ,CAACL,SAAS,CAACR,QAAQ,CAACK,KAAK;YACnE,MAAMS,aAAa,IAAI,CAAChB,WAAW,CAACgB,UAAU,CAACN,SAAS,CAACH;YAEzDK,SAASD,IAAI,CACX,kNAAIjB,sBAAAA,CAAoB;gBACtBuB,6KAAMxB,YAAAA,CAAUyB,QAAQ;gBACxBT;gBACAF;gBACAS;gBACAD;gBACAF;YACF;QAEJ;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5253, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/app-route-route-matcher-provider.ts"],"sourcesContent":["import { isAppRouteRoute } from '../../lib/is-app-route-route'\nimport { APP_PATHS_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport { AppRouteRouteMatcher } from '../route-matchers/app-route-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport { AppNormalizers } from '../normalizers/built/app'\n\nexport class AppRouteRouteMatcherProvider extends ManifestRouteMatcherProvider<AppRouteRouteMatcher> {\n  private readonly normalizers: AppNormalizers\n\n  constructor(distDir: string, manifestLoader: ManifestLoader) {\n    super(APP_PATHS_MANIFEST, manifestLoader)\n\n    this.normalizers = new AppNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<AppRouteRouteMatcher>> {\n    // This matcher only matches app routes.\n    const pages = Object.keys(manifest).filter((page) => isAppRouteRoute(page))\n\n    // Format the routes.\n    const matchers: Array<AppRouteRouteMatcher> = []\n    for (const page of pages) {\n      const filename = this.normalizers.filename.normalize(manifest[page])\n      const pathname = this.normalizers.pathname.normalize(page)\n      const bundlePath = this.normalizers.bundlePath.normalize(page)\n\n      matchers.push(\n        new AppRouteRouteMatcher({\n          kind: RouteKind.APP_ROUTE,\n          pathname,\n          page,\n          bundlePath,\n          filename,\n        })\n      )\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAppRouteRoute","APP_PATHS_MANIFEST","RouteKind","AppRouteRouteMatcher","ManifestRouteMatcherProvider","AppNormalizers","AppRouteRouteMatcherProvider","constructor","distDir","manifestLoader","normalizers","transform","manifest","pages","Object","keys","filter","page","matchers","filename","normalize","pathname","bundlePath","push","kind","APP_ROUTE"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,+BAA8B;AAC9D,SAASC,kBAAkB,QAAQ,6BAA4B;;AAC/D,SAASC,SAAS,QAAQ,gBAAe;AACzC,SAASC,oBAAoB,QAAQ,4CAA2C;AAKhF,SAASC,4BAA4B,QAAQ,oCAAmC;AAChF,SAASC,cAAc,QAAQ,2BAA0B;;;;;;;AAElD,MAAMC,wQAAqCF,+BAAAA;IAGhDG,YAAYC,OAAe,EAAEC,cAA8B,CAAE;QAC3D,KAAK,2LAACR,qBAAAA,EAAoBQ;QAE1B,IAAI,CAACC,WAAW,GAAG,kMAAIL,iBAAAA,CAAeG;IACxC;IAEA,MAAgBG,UACdC,QAAkB,EAC4B;QAC9C,wCAAwC;QACxC,MAAMC,QAAQC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,6LAASjB,kBAAAA,EAAgBiB;QAErE,qBAAqB;QACrB,MAAMC,WAAwC,EAAE;QAChD,KAAK,MAAMD,QAAQJ,MAAO;YACxB,MAAMM,WAAW,IAAI,CAACT,WAAW,CAACS,QAAQ,CAACC,SAAS,CAACR,QAAQ,CAACK,KAAK;YACnE,MAAMI,WAAW,IAAI,CAACX,WAAW,CAACW,QAAQ,CAACD,SAAS,CAACH;YACrD,MAAMK,aAAa,IAAI,CAACZ,WAAW,CAACY,UAAU,CAACF,SAAS,CAACH;YAEzDC,SAASK,IAAI,CACX,mNAAIpB,uBAAAA,CAAqB;gBACvBqB,6KAAMtB,YAAAA,CAAUuB,SAAS;gBACzBJ;gBACAJ;gBACAK;gBACAH;YACF;QAEJ;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5300, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/pages-api-route-matcher-provider.ts"],"sourcesContent":["import { isAPIRoute } from '../../lib/is-api-route'\nimport { PAGES_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport {\n  PagesAPILocaleRouteMatcher,\n  PagesAPIRouteMatcher,\n} from '../route-matchers/pages-api-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport type { I18NProvider } from '../lib/i18n-provider'\nimport { PagesNormalizers } from '../normalizers/built/pages'\n\nexport class PagesAPIRouteMatcherProvider extends ManifestRouteMatcherProvider<PagesAPIRouteMatcher> {\n  private readonly normalizers: PagesNormalizers\n\n  constructor(\n    distDir: string,\n    manifestLoader: ManifestLoader,\n    private readonly i18nProvider?: I18NProvider\n  ) {\n    super(PAGES_MANIFEST, manifestLoader)\n\n    this.normalizers = new PagesNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<PagesAPIRouteMatcher>> {\n    // This matcher is only for Pages API routes.\n    const pathnames = Object.keys(manifest).filter((pathname) =>\n      isAPIRoute(pathname)\n    )\n\n    const matchers: Array<PagesAPIRouteMatcher> = []\n\n    for (const page of pathnames) {\n      if (this.i18nProvider) {\n        // Match the locale on the page name, or default to the default locale.\n        const { detectedLocale, pathname } = this.i18nProvider.analyze(page)\n\n        matchers.push(\n          new PagesAPILocaleRouteMatcher({\n            kind: RouteKind.PAGES_API,\n            pathname,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n            i18n: {\n              locale: detectedLocale,\n            },\n          })\n        )\n      } else {\n        matchers.push(\n          new PagesAPIRouteMatcher({\n            kind: RouteKind.PAGES_API,\n            // In `pages/`, the page is the same as the pathname.\n            pathname: page,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n          })\n        )\n      }\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAPIRoute","PAGES_MANIFEST","RouteKind","PagesAPILocaleRouteMatcher","PagesAPIRouteMatcher","ManifestRouteMatcherProvider","PagesNormalizers","PagesAPIRouteMatcherProvider","constructor","distDir","manifestLoader","i18nProvider","normalizers","transform","manifest","pathnames","Object","keys","filter","pathname","matchers","page","detectedLocale","analyze","push","kind","PAGES_API","bundlePath","normalize","filename","i18n","locale"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,cAAc,QAAQ,6BAA4B;;AAC3D,SAASC,SAAS,QAAQ,gBAAe;AACzC,SACEC,0BAA0B,EAC1BC,oBAAoB,QACf,4CAA2C;AAKlD,SAASC,4BAA4B,QAAQ,oCAAmC;AAEhF,SAASC,gBAAgB,QAAQ,6BAA4B;;;;;;;AAEtD,MAAMC,wQAAqCF,+BAAAA;IAGhDG,YACEC,OAAe,EACfC,cAA8B,EACbC,YAA2B,CAC5C;QACA,KAAK,2LAACV,iBAAAA,EAAgBS,iBAAAA,IAAAA,CAFLC,YAAAA,GAAAA;QAIjB,IAAI,CAACC,WAAW,GAAG,oMAAIN,mBAAAA,CAAiBG;IAC1C;IAEA,MAAgBI,UACdC,QAAkB,EAC4B;QAC9C,6CAA6C;QAC7C,MAAMC,YAAYC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,wLAC9CnB,aAAAA,EAAWmB;QAGb,MAAMC,WAAwC,EAAE;QAEhD,KAAK,MAAMC,QAAQN,UAAW;YAC5B,IAAI,IAAI,CAACJ,YAAY,EAAE;gBACrB,uEAAuE;gBACvE,MAAM,EAAEW,cAAc,EAAEH,QAAQ,EAAE,GAAG,IAAI,CAACR,YAAY,CAACY,OAAO,CAACF;gBAE/DD,SAASI,IAAI,CACX,mNAAIrB,6BAAAA,CAA2B;oBAC7BsB,4KAAMvB,aAAAA,CAAUwB,SAAS;oBACzBP;oBACAE;oBACAM,YAAY,IAAI,CAACf,WAAW,CAACe,UAAU,CAACC,SAAS,CAACP;oBAClDQ,UAAU,IAAI,CAACjB,WAAW,CAACiB,QAAQ,CAACD,SAAS,CAACd,QAAQ,CAACO,KAAK;oBAC5DS,MAAM;wBACJC,QAAQT;oBACV;gBACF;YAEJ,OAAO;gBACLF,SAASI,IAAI,CACX,mNAAIpB,uBAAAA,CAAqB;oBACvBqB,4KAAMvB,aAAAA,CAAUwB,SAAS;oBACzB,qDAAqD;oBACrDP,UAAUE;oBACVA;oBACAM,YAAY,IAAI,CAACf,WAAW,CAACe,UAAU,CAACC,SAAS,CAACP;oBAClDQ,UAAU,IAAI,CAACjB,WAAW,CAACiB,QAAQ,CAACD,SAAS,CAACd,QAAQ,CAACO,KAAK;gBAC9D;YAEJ;QACF;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5359, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/pages-route-matcher-provider.ts"],"sourcesContent":["import { isAPIRoute } from '../../lib/is-api-route'\nimport { BLOCKED_PAGES, PAGES_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport {\n  PagesLocaleRouteMatcher,\n  PagesRouteMatcher,\n} from '../route-matchers/pages-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport type { I18NProvider } from '../lib/i18n-provider'\nimport { PagesNormalizers } from '../normalizers/built/pages'\n\nexport class PagesRouteMatcherProvider extends ManifestRouteMatcherProvider<PagesRouteMatcher> {\n  private readonly normalizers: PagesNormalizers\n\n  constructor(\n    distDir: string,\n    manifestLoader: ManifestLoader,\n    private readonly i18nProvider?: I18NProvider\n  ) {\n    super(PAGES_MANIFEST, manifestLoader)\n\n    this.normalizers = new PagesNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<PagesRouteMatcher>> {\n    // This matcher is only for Pages routes, not Pages API routes which are\n    // included in this manifest.\n    const pathnames = Object.keys(manifest)\n      .filter((pathname) => !isAPIRoute(pathname))\n      // Remove any blocked pages (page that can't be routed to, like error or\n      // internal pages).\n      .filter((pathname) => {\n        const normalized =\n          this.i18nProvider?.analyze(pathname).pathname ?? pathname\n\n        // Skip any blocked pages.\n        if (BLOCKED_PAGES.includes(normalized)) return false\n\n        return true\n      })\n\n    const matchers: Array<PagesRouteMatcher> = []\n    for (const page of pathnames) {\n      if (this.i18nProvider) {\n        // Match the locale on the page name, or default to the default locale.\n        const { detectedLocale, pathname } = this.i18nProvider.analyze(page)\n\n        matchers.push(\n          new PagesLocaleRouteMatcher({\n            kind: RouteKind.PAGES,\n            pathname,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n            i18n: {\n              locale: detectedLocale,\n            },\n          })\n        )\n      } else {\n        matchers.push(\n          new PagesRouteMatcher({\n            kind: RouteKind.PAGES,\n            // In `pages/`, the page is the same as the pathname.\n            pathname: page,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n          })\n        )\n      }\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAPIRoute","BLOCKED_PAGES","PAGES_MANIFEST","RouteKind","PagesLocaleRouteMatcher","PagesRouteMatcher","ManifestRouteMatcherProvider","PagesNormalizers","PagesRouteMatcherProvider","constructor","distDir","manifestLoader","i18nProvider","normalizers","transform","manifest","pathnames","Object","keys","filter","pathname","normalized","analyze","includes","matchers","page","detectedLocale","push","kind","PAGES","bundlePath","normalize","filename","i18n","locale"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,aAAa,EAAEC,cAAc,QAAQ,6BAA4B;;AAC1E,SAASC,SAAS,QAAQ,gBAAe;AACzC,SACEC,uBAAuB,EACvBC,iBAAiB,QACZ,wCAAuC;AAK9C,SAASC,4BAA4B,QAAQ,oCAAmC;AAEhF,SAASC,gBAAgB,QAAQ,6BAA4B;;;;;;;AAEtD,MAAMC,qQAAkCF,+BAAAA;IAG7CG,YACEC,OAAe,EACfC,cAA8B,EACbC,YAA2B,CAC5C;QACA,KAAK,2LAACV,iBAAAA,EAAgBS,iBAAAA,IAAAA,CAFLC,YAAAA,GAAAA;QAIjB,IAAI,CAACC,WAAW,GAAG,oMAAIN,mBAAAA,CAAiBG;IAC1C;IAEA,MAAgBI,UACdC,QAAkB,EACyB;QAC3C,wEAAwE;QACxE,6BAA6B;QAC7B,MAAMC,YAAYC,OAAOC,IAAI,CAACH,UAC3BI,MAAM,CAAC,CAACC,WAAa,8KAACpB,aAAAA,EAAWoB,WAClC,wEAAwE;QACxE,mBAAmB;SAClBD,MAAM,CAAC,CAACC;gBAEL;YADF,MAAMC,aACJ,CAAA,CAAA,qBAAA,IAAI,CAACT,YAAY,KAAA,OAAA,KAAA,IAAjB,mBAAmBU,OAAO,CAACF,UAAUA,QAAQ,KAAIA;YAEnD,0BAA0B;YAC1B,8LAAInB,gBAAAA,CAAcsB,QAAQ,CAACF,aAAa,OAAO;YAE/C,OAAO;QACT;QAEF,MAAMG,WAAqC,EAAE;QAC7C,KAAK,MAAMC,QAAQT,UAAW;YAC5B,IAAI,IAAI,CAACJ,YAAY,EAAE;gBACrB,uEAAuE;gBACvE,MAAM,EAAEc,cAAc,EAAEN,QAAQ,EAAE,GAAG,IAAI,CAACR,YAAY,CAACU,OAAO,CAACG;gBAE/DD,SAASG,IAAI,CACX,4MAAIvB,0BAAAA,CAAwB;oBAC1BwB,6KAAMzB,YAAAA,CAAU0B,KAAK;oBACrBT;oBACAK;oBACAK,YAAY,IAAI,CAACjB,WAAW,CAACiB,UAAU,CAACC,SAAS,CAACN;oBAClDO,UAAU,IAAI,CAACnB,WAAW,CAACmB,QAAQ,CAACD,SAAS,CAAChB,QAAQ,CAACU,KAAK;oBAC5DQ,MAAM;wBACJC,QAAQR;oBACV;gBACF;YAEJ,OAAO;gBACLF,SAASG,IAAI,CACX,4MAAItB,oBAAAA,CAAkB;oBACpBuB,6KAAMzB,YAAAA,CAAU0B,KAAK;oBACrB,qDAAqD;oBACrDT,UAAUK;oBACVA;oBACAK,YAAY,IAAI,CAACjB,WAAW,CAACiB,UAAU,CAACC,SAAS,CAACN;oBAClDO,UAAU,IAAI,CAACnB,WAAW,CAACmB,QAAQ,CAACD,SAAS,CAAChB,QAAQ,CAACU,KAAK;gBAC9D;YAEJ;QACF;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5427, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader.ts"],"sourcesContent":["import type { Manifest, ManifestLoader } from './manifest-loader'\n\nexport class ServerManifestLoader implements ManifestLoader {\n  constructor(private readonly getter: (name: string) => Manifest | null) {}\n\n  public load(name: string): Manifest | null {\n    return this.getter(name)\n  }\n}\n"],"names":["ServerManifestLoader","constructor","getter","load","name"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAyC,CAAE;aAA3CA,MAAAA,GAAAA;IAA4C;IAElEC,KAAKC,IAAY,EAAmB;QACzC,OAAO,IAAI,CAACF,MAAM,CAACE;IACrB;AACF","ignoreList":[0]}},
    {"offset": {"line": 5444, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/send-response.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport { isNodeNextResponse } from './base-http/helpers'\n\nimport { pipeToNodeResponse } from './pipe-readable'\nimport { splitCookiesString } from './web/utils'\n\n/**\n * Sends the response on the underlying next response object.\n *\n * @param req the underlying request object\n * @param res the underlying response object\n * @param response the response to send\n */\nexport async function sendResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  response: Response,\n  waitUntil?: Promise<unknown>\n): Promise<void> {\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextResponse(res)\n  ) {\n    // Copy over the response status.\n    res.statusCode = response.status\n    res.statusMessage = response.statusText\n\n    // TODO: this is not spec-compliant behavior and we should not restrict\n    // headers that are allowed to appear many times.\n    //\n    // See:\n    // https://github.com/vercel/next.js/pull/70127\n    const headersWithMultipleValuesAllowed = [\n      // can add more headers to this list if needed\n      'set-cookie',\n      'www-authenticate',\n      'proxy-authenticate',\n      'vary',\n    ]\n\n    // Copy over the response headers.\n    response.headers?.forEach((value, name) => {\n      // `x-middleware-set-cookie` is an internal header not needed for the response\n      if (name.toLowerCase() === 'x-middleware-set-cookie') {\n        return\n      }\n\n      // The append handling is special cased for `set-cookie`.\n      if (name.toLowerCase() === 'set-cookie') {\n        // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n        for (const cookie of splitCookiesString(value)) {\n          res.appendHeader(name, cookie)\n        }\n      } else {\n        // only append the header if it is either not present in the outbound response\n        // or if the header supports multiple values\n        const isHeaderPresent = typeof res.getHeader(name) !== 'undefined'\n        if (\n          headersWithMultipleValuesAllowed.includes(name.toLowerCase()) ||\n          !isHeaderPresent\n        ) {\n          res.appendHeader(name, value)\n        }\n      }\n    })\n\n    /**\n     * The response can't be directly piped to the underlying response. The\n     * following is duplicated from the edge runtime handler.\n     *\n     * See packages/next/server/next-server.ts\n     */\n\n    const { originalResponse } = res\n\n    // A response body must not be sent for HEAD requests. See https://httpwg.org/specs/rfc9110.html#HEAD\n    if (response.body && req.method !== 'HEAD') {\n      await pipeToNodeResponse(response.body, originalResponse, waitUntil)\n    } else {\n      originalResponse.end()\n    }\n  }\n}\n"],"names":["isNodeNextResponse","pipeToNodeResponse","splitCookiesString","sendResponse","req","res","response","waitUntil","process","env","NEXT_RUNTIME","statusCode","status","statusMessage","statusText","headersWithMultipleValuesAllowed","headers","forEach","value","name","toLowerCase","cookie","appendHeader","isHeaderPresent","getHeader","includes","originalResponse","body","method","end"],"mappings":";;;AACA,SAASA,kBAAkB,QAAQ,sBAAqB;AAExD,SAASC,kBAAkB,QAAQ,kBAAiB;AACpD,SAASC,kBAAkB,QAAQ,cAAa;;;;AASzC,eAAeC,aACpBC,GAAoB,EACpBC,GAAqB,EACrBC,QAAkB,EAClBC,SAA4B;IAE5B,IACE,AACA,6DAA6D,QADQ;IAErEC,QAAQC,GAAG,CAACC,YAAY,qBAAK,+LAC7BV,qBAAAA,EAAmBK,MACnB;;YAkBA,AACAC,kCADkC;IAyCpC;AACF","ignoreList":[0]}},
    {"offset": {"line": 5466, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-modules/checks.ts"],"sourcesContent":["import type { AppRouteRouteModule } from './app-route/module'\nimport type { AppPageRouteModule } from './app-page/module'\nimport type { PagesRouteModule } from './pages/module'\nimport type { PagesAPIRouteModule } from './pages-api/module'\n\nimport type { RouteModule } from './route-module'\n\nimport { RouteKind } from '../route-kind'\n\nexport function isAppRouteRouteModule(\n  routeModule: RouteModule\n): routeModule is AppRouteRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_ROUTE\n}\n\nexport function isAppPageRouteModule(\n  routeModule: RouteModule\n): routeModule is AppPageRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_PAGE\n}\n\nexport function isPagesRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES\n}\n\nexport function isPagesAPIRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesAPIRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES_API\n}\n"],"names":["RouteKind","isAppRouteRouteModule","routeModule","definition","kind","APP_ROUTE","isAppPageRouteModule","APP_PAGE","isPagesRouteModule","PAGES","isPagesAPIRouteModule","PAGES_API"],"mappings":";;;;;;AAOA,SAASA,SAAS,QAAQ,gBAAe;;AAElC,SAASC,sBACdC,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUK,SAAS;AAC5D;AAEO,SAASC,qBACdJ,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUO,QAAQ;AAC3D;AAEO,SAASC,mBACdN,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUS,KAAK;AACxD;AAEO,SAASC,sBACdR,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUW,SAAS;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 5492, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-modules/route-module.ts"],"sourcesContent":["import type { RouteDefinition } from '../route-definitions/route-definition'\n\n/**\n * RouteModuleOptions is the options that are passed to the route module, other\n * route modules should extend this class to add specific options for their\n * route.\n */\nexport interface RouteModuleOptions<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  readonly definition: Readonly<D>\n  readonly userland: Readonly<U>\n}\n\n/**\n * RouteHandlerContext is the base context for a route handler.\n */\nexport interface RouteModuleHandleContext {\n  /**\n   * Any matched parameters for the request. This is only defined for dynamic\n   * routes.\n   */\n  params: Record<string, string | string[] | undefined> | undefined\n}\n\n/**\n * RouteModule is the base class for all route modules. This class should be\n * extended by all route modules.\n */\nexport abstract class RouteModule<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  /**\n   * The userland module. This is the module that is exported from the user's\n   * code. This is marked as readonly to ensure that the module is not mutated\n   * because the module (when compiled) only provides getters.\n   */\n  public readonly userland: Readonly<U>\n\n  /**\n   * The definition of the route.\n   */\n  public readonly definition: Readonly<D>\n\n  /**\n   * The shared modules that are exposed and required for the route module.\n   */\n  public static readonly sharedModules: any\n\n  constructor({ userland, definition }: RouteModuleOptions<D, U>) {\n    this.userland = userland\n    this.definition = definition\n  }\n}\n"],"names":["RouteModule","constructor","userland","definition"],"mappings":"AA0BA;;;CAGC,GACD;;;AAAO,MAAeA;IAqBpBC,YAAY,EAAEC,QAAQ,EAAEC,UAAU,EAA4B,CAAE;QAC9D,IAAI,CAACD,QAAQ,GAAGA;QAChB,IAAI,CAACC,UAAU,GAAGA;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 5510, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-modules/app-page/vendored/contexts/entrypoints.ts"],"sourcesContent":["export * as HeadManagerContext from '../../../../../shared/lib/head-manager-context.shared-runtime'\nexport * as ServerInsertedHtml from '../../../../../shared/lib/server-inserted-html.shared-runtime'\nexport * as ServerInsertedMetadata from '../../../../../shared/lib/server-inserted-metadata.shared-runtime'\nexport * as AppRouterContext from '../../../../../shared/lib/app-router-context.shared-runtime'\nexport * as HooksClientContext from '../../../../../shared/lib/hooks-client-context.shared-runtime'\nexport * as RouterContext from '../../../../../shared/lib/router-context.shared-runtime'\nexport * as AmpContext from '../../../../../shared/lib/amp-context.shared-runtime'\nexport * as ImageConfigContext from '../../../../../shared/lib/image-config-context.shared-runtime'\n"],"names":["HeadManagerContext","ServerInsertedHtml","ServerInsertedMetadata","AppRouterContext","HooksClientContext","RouterContext","AmpContext","ImageConfigContext"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 5585, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-modules/app-page/module.ts"],"sourcesContent":["import type { AppPageRouteDefinition } from '../../route-definitions/app-page-route-definition'\nimport type RenderResult from '../../render-result'\nimport type { RenderOpts } from '../../app-render/types'\nimport type { NextParsedUrlQuery } from '../../request-meta'\nimport type { LoaderTree } from '../../lib/app-dir-module'\n\nimport {\n  renderToHTMLOrFlight,\n  type AppSharedContext,\n} from '../../app-render/app-render'\nimport {\n  RouteModule,\n  type RouteModuleOptions,\n  type RouteModuleHandleContext,\n} from '../route-module'\nimport * as vendoredContexts from './vendored/contexts/entrypoints'\nimport type { BaseNextRequest, BaseNextResponse } from '../../base-http'\nimport type { ServerComponentsHmrCache } from '../../response-cache'\nimport type { FallbackRouteParams } from '../../request/fallback-params'\n\nlet vendoredReactRSC\nlet vendoredReactSSR\n\n// the vendored Reacts are loaded from their original source in the edge runtime\nif (process.env.NEXT_RUNTIME !== 'edge') {\n  vendoredReactRSC = require('./vendored/rsc/entrypoints')\n  vendoredReactSSR = require('./vendored/ssr/entrypoints')\n}\n\n/**\n * The AppPageModule is the type of the module exported by the bundled app page\n * module.\n */\nexport type AppPageModule = typeof import('../../../build/templates/app-page')\n\ntype AppPageUserlandModule = {\n  /**\n   * The tree created in next-app-loader that holds component segments and modules\n   */\n  loaderTree: LoaderTree\n}\n\nexport interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n  page: string\n  query: NextParsedUrlQuery\n  fallbackRouteParams: FallbackRouteParams | null\n  renderOpts: RenderOpts\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  sharedContext: AppSharedContext\n}\n\nexport type AppPageRouteModuleOptions = RouteModuleOptions<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n>\n\nexport class AppPageRouteModule extends RouteModule<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n> {\n  public render(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      false,\n      context.sharedContext\n    )\n  }\n\n  public warmup(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      true,\n      context.sharedContext\n    )\n  }\n}\n\nconst vendored = {\n  'react-rsc': vendoredReactRSC,\n  'react-ssr': vendoredReactSSR,\n  contexts: vendoredContexts,\n}\n\nexport { renderToHTMLOrFlight, vendored }\n\nexport default AppPageRouteModule\n"],"names":["renderToHTMLOrFlight","RouteModule","vendoredContexts","vendoredReactRSC","vendoredReactSSR","process","env","NEXT_RUNTIME","require","AppPageRouteModule","render","req","res","context","page","query","fallbackRouteParams","renderOpts","serverComponentsHmrCache","sharedContext","warmup","vendored","contexts"],"mappings":";;;;;AAMA,SACEA,oBAAoB,QAEf,8BAA6B;AACpC,SACEC,WAAW,QAGN,kBAAiB;AACxB,YAAYC,sBAAsB,kCAAiC;;;;AAKnE,IAAIC;AACJ,IAAIC;AAEJ,gFAAgF;AAChF,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;AAGzC;AA6BO,MAAME,wNAA2BR,cAAAA;IAI/BS,OACLC,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,QAAOb,kNAAAA,EACLW,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChC,OACAL,QAAQM,aAAa;IAEzB;IAEOC,OACLT,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,mMAAOb,uBAAAA,EACLW,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChC,MACAL,QAAQM,aAAa;IAEzB;AACF;AAEA,MAAME,WAAW;IACf,aAAalB;IACb,aAAaC;IACbkB,UAAUpB;AACZ;;uCAIeO,mBAAkB","ignoreList":[0]}},
    {"offset": {"line": 5662, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;IACvCC,OAAOC,OAAO,GAAGC,QAAQ;AAC3B,OAAO;;AAkBP","ignoreList":[0]}},
    {"offset": {"line": 5673, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isRevalidate?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isRevalidate) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isRevalidate","undefined"],"mappings":";;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,YAAY,EAAE;QACvB,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 5691, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isRevalidate?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isRevalidate) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isRevalidate","undefined"],"mappings":";;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,YAAY,EAAE;QACvB,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 5709, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/use-cache/handlers.ts"],"sourcesContent":["import DefaultCacheHandler from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_USE_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache[${process.pid}]: ${message}`, ...args)\n    }\n  : () => {}\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug('cache handlers already initialized')\n    return false\n  }\n\n  debug('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug('setting \"default\" cache handler from default')\n      fallback = DefaultCacheHandler\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    debug('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', DefaultCacheHandler)\n    debug('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', DefaultCacheHandler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it is not initialized or does not exist.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get an iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n"],"names":["DefaultCacheHandler","debug","process","env","NEXT_PRIVATE_DEBUG_USE_CACHE","message","args","console","log","pid","handlersSymbol","Symbol","for","handlersMapSymbol","handlersSetSymbol","reference","globalThis","initializeCacheHandlers","Map","fallback","DefaultCache","set","RemoteCache","Set","values","getCacheHandler","kind","Error","get","getCacheHandlers","undefined","setCacheHandler","cacheHandler","add"],"mappings":";;;;;;AAAA,OAAOA,yBAAyB,gCAA+B;;AAG/D,MAAMC,QAAQC,QAAQC,GAAG,CAACC,4BAA4B,GAClD,CAACC,SAAiB,GAAGC;IACnBC,QAAQC,GAAG,CAAC,CAAC,UAAU,EAAEN,QAAQO,GAAG,CAAC,GAAG,EAAEJ,SAAS,KAAKC;AAC1D,IACA,KAAO;AAEX,MAAMI,iBAAiBC,OAAOC,GAAG,CAAC;AAClC,MAAMC,oBAAoBF,OAAOC,GAAG,CAAC;AACrC,MAAME,oBAAoBH,OAAOC,GAAG,CAAC;AAErC;;;;CAIC,GACD,MAAMG,YAOFC;AAMG,SAASC;IACd,0EAA0E;IAC1E,IAAIF,SAAS,CAACF,kBAAkB,EAAE;QAChCZ,MAAM;QACN,OAAO;IACT;IAEAA,MAAM;IACNc,SAAS,CAACF,kBAAkB,GAAG,IAAIK;IAEnC,uDAAuD;IACvD,IAAIH,SAAS,CAACL,eAAe,EAAE;QAC7B,IAAIS;QACJ,IAAIJ,SAAS,CAACL,eAAe,CAACU,YAAY,EAAE;YAC1CnB,MAAM;YACNkB,WAAWJ,SAAS,CAACL,eAAe,CAACU,YAAY;QACnD,OAAO;YACLnB,MAAM;YACNkB,wMAAWnB,UAAAA;QACb;QAEAe,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAAC,WAAWF;QAE5C,IAAIJ,SAAS,CAACL,eAAe,CAACY,WAAW,EAAE;YACzCrB,MAAM;YACNc,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAC9B,UACAN,SAAS,CAACL,eAAe,CAACY,WAAW;QAEzC,OAAO;YACLrB,MAAM;YACNc,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAAC,UAAUF;QAC7C;IACF,OAAO;QACLlB,MAAM;QACNc,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAAC,wMAAWrB,UAAAA;QAC5CC,MAAM;QACNc,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAAC,uMAAUrB,UAAAA;IAC7C;IAEA,sCAAsC;IACtCe,SAAS,CAACD,kBAAkB,GAAG,IAAIS,IAAIR,SAAS,CAACF,kBAAkB,CAACW,MAAM;IAE1E,OAAO;AACT;AAOO,SAASC,gBAAgBC,IAAY;IAC1C,8DAA8D;IAC9D,IAAI,CAACX,SAAS,CAACF,kBAAkB,EAAE;QACjC,MAAM,OAAA,cAA2C,CAA3C,IAAIc,MAAM,mCAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAA0C;IAClD;IAEA,OAAOZ,SAAS,CAACF,kBAAkB,CAACe,GAAG,CAACF;AAC1C;AAMO,SAASG;IACd,IAAI,CAACd,SAAS,CAACD,kBAAkB,EAAE;QACjC,OAAOgB;IACT;IAEA,OAAOf,SAAS,CAACD,kBAAkB,CAACU,MAAM;AAC5C;AAOO,SAASO,gBACdL,IAAY,EACZM,YAA0B;IAE1B,8DAA8D;IAC9D,IAAI,CAACjB,SAAS,CAACF,kBAAkB,IAAI,CAACE,SAAS,CAACD,kBAAkB,EAAE;QAClE,MAAM,OAAA,cAA2C,CAA3C,IAAIa,MAAM,mCAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAA0C;IAClD;IAEA1B,MAAM,kCAAkCyB;IACxCX,SAAS,CAACF,kBAAkB,CAACQ,GAAG,CAACK,MAAMM;IACvCjB,SAAS,CAACD,kBAAkB,CAACmB,GAAG,CAACD;AACnC","ignoreList":[0]}},
    {"offset": {"line": 5800, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/use-cache/use-cache-errors.ts"],"sourcesContent":["const USE_CACHE_TIMEOUT_ERROR_CODE = 'USE_CACHE_TIMEOUT'\n\nexport class UseCacheTimeoutError extends Error {\n  digest: typeof USE_CACHE_TIMEOUT_ERROR_CODE = USE_CACHE_TIMEOUT_ERROR_CODE\n\n  constructor() {\n    super(\n      'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n    )\n  }\n}\n\nexport function isUseCacheTimeoutError(\n  err: unknown\n): err is UseCacheTimeoutError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === USE_CACHE_TIMEOUT_ERROR_CODE\n}\n"],"names":["USE_CACHE_TIMEOUT_ERROR_CODE","UseCacheTimeoutError","Error","constructor","digest","isUseCacheTimeoutError","err"],"mappings":";;;;AAAA,MAAMA,+BAA+B;AAE9B,MAAMC,6BAA6BC;IAGxCC,aAAc;QACZ,KAAK,CACH,gLAAA,IAAA,CAJJC,MAAAA,GAA8CJ;IAM9C;AACF;AAEO,SAASK,uBACdC,GAAY;IAEZ,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 5822, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/use-cache/use-cache-errors.ts"],"sourcesContent":["const USE_CACHE_TIMEOUT_ERROR_CODE = 'USE_CACHE_TIMEOUT'\n\nexport class UseCacheTimeoutError extends Error {\n  digest: typeof USE_CACHE_TIMEOUT_ERROR_CODE = USE_CACHE_TIMEOUT_ERROR_CODE\n\n  constructor() {\n    super(\n      'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n    )\n  }\n}\n\nexport function isUseCacheTimeoutError(\n  err: unknown\n): err is UseCacheTimeoutError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === USE_CACHE_TIMEOUT_ERROR_CODE\n}\n"],"names":["USE_CACHE_TIMEOUT_ERROR_CODE","UseCacheTimeoutError","Error","constructor","digest","isUseCacheTimeoutError","err"],"mappings":";;;;AAAA,MAAMA,+BAA+B;AAE9B,MAAMC,6BAA6BC;IAGxCC,aAAc;QACZ,KAAK,CACH,gLAAA,IAAA,CAJJC,MAAAA,GAA8CJ;IAM9C;AACF;AAEO,SAASK,uBACdC,GAAY;IAEZ,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 5844, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/web-server.ts"],"sourcesContent":["import type { WebNextRequest, WebNextResponse } from './base-http/web'\nimport type RenderResult from './render-result'\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\nimport type { Params } from './request/params'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type {\n  LoadedRenderOpts,\n  MiddlewareRoutingItem,\n  NormalizedRouteManifest,\n  Options,\n  RouteHandler,\n} from './base-server'\nimport type { CacheControl } from './lib/cache-control'\n\nimport { byteLength } from './api-utils/web'\nimport BaseServer, { NoFallbackError } from './base-server'\nimport { generateETag } from './lib/etag'\nimport { addRequestMeta, getRequestMeta } from './request-meta'\nimport WebResponseCache from './response-cache/web'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport {\n  interpolateDynamicPath,\n  normalizeVercelUrl,\n  normalizeDynamicRouteParams,\n} from './server-utils'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport { IncrementalCache } from './lib/incremental-cache'\nimport type { PAGE_TYPES } from '../lib/page-types'\nimport type { Rewrite } from '../lib/load-custom-routes'\nimport { buildCustomRoute } from '../lib/build-custom-route'\nimport { UNDERSCORE_NOT_FOUND_ROUTE } from '../api/constants'\nimport { getEdgeInstrumentationModule } from './web/globals'\nimport type { ServerOnInstrumentationRequestError } from './app-render/types'\nimport { getEdgePreviewProps } from './web/get-edge-preview-props'\n\ninterface WebServerOptions extends Options {\n  buildId: string\n  webServerConfig: {\n    page: string\n    pathname: string\n    pagesType: PAGE_TYPES\n    loadComponent: (page: string) => Promise<LoadComponentsReturnType | null>\n    extendRenderOpts: Partial<BaseServer['renderOpts']> & {\n      serverActionsManifest?: any\n    }\n    renderToHTML:\n      | typeof import('./app-render/app-render').renderToHTMLOrFlight\n      | undefined\n    incrementalCacheHandler?: any\n    interceptionRouteRewrites?: Rewrite[]\n  }\n}\n\ntype WebRouteHandler = RouteHandler<WebNextRequest, WebNextResponse>\n\nexport default class NextWebServer extends BaseServer<\n  WebServerOptions,\n  WebNextRequest,\n  WebNextResponse\n> {\n  constructor(options: WebServerOptions) {\n    super(options)\n\n    // Extend `renderOpts`.\n    Object.assign(this.renderOpts, options.webServerConfig.extendRenderOpts)\n  }\n\n  protected async getIncrementalCache({\n    requestHeaders,\n  }: {\n    requestHeaders: IncrementalCache['requestHeaders']\n  }) {\n    const dev = !!this.renderOpts.dev\n    // incremental-cache is request specific\n    // although can have shared caches in module scope\n    // per-cache handler\n    return new IncrementalCache({\n      dev,\n      requestHeaders,\n      requestProtocol: 'https',\n      allowedRevalidateHeaderKeys:\n        this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      minimalMode: this.minimalMode,\n      fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n      maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n      flushToDisk: false,\n      CurCacheHandler:\n        this.serverOptions.webServerConfig.incrementalCacheHandler,\n      getPrerenderManifest: () => this.getPrerenderManifest(),\n    })\n  }\n  protected getResponseCache() {\n    return new WebResponseCache(this.minimalMode)\n  }\n\n  protected async hasPage(page: string) {\n    return page === this.serverOptions.webServerConfig.page\n  }\n\n  protected getBuildId() {\n    return this.serverOptions.buildId\n  }\n\n  protected getEnabledDirectories() {\n    return {\n      app: this.serverOptions.webServerConfig.pagesType === 'app',\n      pages: this.serverOptions.webServerConfig.pagesType === 'pages',\n    }\n  }\n\n  protected getPagesManifest() {\n    return {\n      // keep same theme but server path doesn't need to be accurate\n      [this.serverOptions.webServerConfig.pathname]:\n        `server${this.serverOptions.webServerConfig.page}.js`,\n    }\n  }\n\n  protected getAppPathsManifest() {\n    const page = this.serverOptions.webServerConfig.page\n    return {\n      [this.serverOptions.webServerConfig.page]: `app${page}.js`,\n    }\n  }\n\n  protected attachRequestMeta(\n    req: WebNextRequest,\n    parsedUrl: NextUrlWithParsedQuery\n  ) {\n    addRequestMeta(req, 'initQuery', { ...parsedUrl.query })\n  }\n\n  protected getPrerenderManifest() {\n    return {\n      version: -1 as any, // letting us know this doesn't conform to spec\n      routes: {},\n      dynamicRoutes: {},\n      notFoundRoutes: [],\n      preview: getEdgePreviewProps(),\n    }\n  }\n\n  protected getNextFontManifest() {\n    return this.serverOptions.webServerConfig.extendRenderOpts.nextFontManifest\n  }\n\n  protected handleCatchallRenderRequest: WebRouteHandler = async (\n    req,\n    res,\n    parsedUrl\n  ) => {\n    let { pathname, query } = parsedUrl\n    if (!pathname) {\n      throw new Error('pathname is undefined')\n    }\n\n    // interpolate query information into page for dynamic route\n    // so that rewritten paths are handled properly\n    const normalizedPage = this.serverOptions.webServerConfig.pathname\n\n    if (pathname !== normalizedPage) {\n      pathname = normalizedPage\n\n      if (isDynamicRoute(pathname)) {\n        const routeRegex = getNamedRouteRegex(pathname, {\n          prefixRouteKeys: false,\n        })\n        const dynamicRouteMatcher = getRouteMatcher(routeRegex)\n        const defaultRouteMatches = dynamicRouteMatcher(\n          pathname\n        ) as NextParsedUrlQuery\n        const paramsResult = normalizeDynamicRouteParams(\n          query,\n          routeRegex,\n          defaultRouteMatches,\n          false\n        )\n        const normalizedParams = paramsResult.hasValidParams\n          ? paramsResult.params\n          : query\n\n        pathname = interpolateDynamicPath(\n          pathname,\n          normalizedParams,\n          routeRegex\n        )\n        normalizeVercelUrl(req, Object.keys(routeRegex.routeKeys), routeRegex)\n      }\n    }\n\n    // next.js core assumes page path without trailing slash\n    pathname = removeTrailingSlash(pathname)\n\n    if (this.i18nProvider) {\n      const { detectedLocale } = await this.i18nProvider.analyze(pathname)\n      if (detectedLocale) {\n        addRequestMeta(req, 'locale', detectedLocale)\n      }\n    }\n\n    const bubbleNoFallback = getRequestMeta(req, 'bubbleNoFallback')\n\n    try {\n      await this.render(req, res, pathname, query, parsedUrl, true)\n\n      return true\n    } catch (err) {\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        return false\n      }\n      throw err\n    }\n  }\n\n  protected renderHTML(\n    req: WebNextRequest,\n    res: WebNextResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult> {\n    const { renderToHTML } = this.serverOptions.webServerConfig\n    if (!renderToHTML) {\n      throw new Error(\n        'Invariant: routeModule should be configured when rendering pages'\n      )\n    }\n\n    // For edge runtime if the pathname hit as /_not-found entrypoint,\n    // override the pathname to /404 for rendering\n    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n      pathname = '/404'\n    }\n    return renderToHTML(\n      req as any,\n      res as any,\n      pathname,\n      query,\n      // Edge runtime does not support ISR/PPR, so we don't need to pass in\n      // the unknown params.\n      null,\n      Object.assign(renderOpts, {\n        disableOptimizedLoading: true,\n        runtime: 'experimental-edge',\n      }),\n      undefined,\n      false,\n      {\n        buildId: this.serverOptions.buildId,\n      }\n    )\n  }\n\n  protected async sendRenderResult(\n    _req: WebNextRequest,\n    res: WebNextResponse,\n    options: {\n      result: RenderResult\n      type: 'html' | 'json'\n      generateEtags: boolean\n      poweredByHeader: boolean\n      cacheControl: CacheControl | undefined\n    }\n  ): Promise<void> {\n    res.setHeader('X-Edge-Runtime', '1')\n\n    // Add necessary headers.\n    // @TODO: Share the isomorphic logic with server/send-payload.ts.\n    if (options.poweredByHeader && options.type === 'html') {\n      res.setHeader('X-Powered-By', 'Next.js')\n    }\n\n    if (!res.getHeader('Content-Type')) {\n      res.setHeader(\n        'Content-Type',\n        options.result.contentType\n          ? options.result.contentType\n          : options.type === 'json'\n            ? 'application/json'\n            : 'text/html; charset=utf-8'\n      )\n    }\n\n    let promise: Promise<void> | undefined\n    if (options.result.isDynamic) {\n      promise = options.result.pipeTo(res.transformStream.writable)\n    } else {\n      const payload = options.result.toUnchunkedString()\n      res.setHeader('Content-Length', String(byteLength(payload)))\n      if (options.generateEtags) {\n        res.setHeader('ETag', generateETag(payload))\n      }\n      res.body(payload)\n    }\n\n    res.send()\n\n    // If we have a promise, wait for it to resolve.\n    if (promise) await promise\n  }\n\n  protected async findPageComponents({\n    page,\n    query,\n    params,\n    url: _url,\n  }: {\n    page: string\n    query: NextParsedUrlQuery\n    params: Params | null\n    isAppPath: boolean\n    url?: string\n  }) {\n    const result = await this.serverOptions.webServerConfig.loadComponent(page)\n    if (!result) return null\n\n    return {\n      query: {\n        ...(query || {}),\n        ...(params || {}),\n      },\n      components: result,\n    }\n  }\n\n  // Below are methods that are not implemented by the web server as they are\n  // handled by the upstream proxy (edge runtime or node server).\n\n  protected async runApi() {\n    // This web server does not need to handle API requests.\n    return true\n  }\n\n  protected async handleApiRequest() {\n    // Edge API requests are handled separately in minimal mode.\n    return false\n  }\n\n  protected loadEnvConfig() {\n    // The web server does not need to load the env config. This is done by the\n    // runtime already.\n  }\n\n  protected getPublicDir() {\n    // Public files are not handled by the web server.\n    return ''\n  }\n\n  protected getHasStaticDir() {\n    return false\n  }\n\n  protected getFontManifest() {\n    return undefined\n  }\n\n  protected handleCompression() {\n    // For the web server layer, compression is automatically handled by the\n    // upstream proxy (edge runtime or node server) and we can simply skip here.\n  }\n\n  protected async handleUpgrade(): Promise<void> {\n    // The web server does not support web sockets.\n  }\n\n  protected async getFallbackErrorComponents(\n    _url?: string\n  ): Promise<LoadComponentsReturnType | null> {\n    // The web server does not need to handle fallback errors in production.\n    return null\n  }\n  protected getRoutesManifest(): NormalizedRouteManifest | undefined {\n    // The web server does not need to handle rewrite rules. This is done by the\n    // upstream proxy (edge runtime or node server).\n    return undefined\n  }\n\n  protected getMiddleware(): Promise<MiddlewareRoutingItem | undefined> {\n    // The web server does not need to handle middleware. This is done by the\n    // upstream proxy (edge runtime or node server).\n    return Promise.resolve(undefined)\n  }\n\n  protected getFilesystemPaths() {\n    return new Set<string>()\n  }\n\n  protected getinterceptionRoutePatterns(): RegExp[] {\n    return (\n      this.serverOptions.webServerConfig.interceptionRouteRewrites?.map(\n        (rewrite) => new RegExp(buildCustomRoute('rewrite', rewrite).regex)\n      ) ?? []\n    )\n  }\n\n  protected async loadInstrumentationModule() {\n    return await getEdgeInstrumentationModule()\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    await super.instrumentationOnRequestError(...args)\n    const err = args[0]\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof __next_log_error__ === 'function'\n    ) {\n      __next_log_error__(err)\n    } else {\n      console.error(err)\n    }\n  }\n}\n"],"names":["byteLength","BaseServer","NoFallbackError","generateETag","addRequestMeta","getRequestMeta","WebResponseCache","removeTrailingSlash","isDynamicRoute","interpolateDynamicPath","normalizeVercelUrl","normalizeDynamicRouteParams","getNamedRouteRegex","getRouteMatcher","IncrementalCache","buildCustomRoute","UNDERSCORE_NOT_FOUND_ROUTE","getEdgeInstrumentationModule","getEdgePreviewProps","NextWebServer","constructor","options","handleCatchallRenderRequest","req","res","parsedUrl","pathname","query","Error","normalizedPage","serverOptions","webServerConfig","routeRegex","prefixRouteKeys","dynamicRouteMatcher","defaultRouteMatches","paramsResult","normalizedParams","hasValidParams","params","Object","keys","routeKeys","i18nProvider","detectedLocale","analyze","bubbleNoFallback","render","err","assign","renderOpts","extendRenderOpts","getIncrementalCache","requestHeaders","dev","requestProtocol","allowedRevalidateHeaderKeys","nextConfig","experimental","minimalMode","fetchCacheKeyPrefix","maxMemoryCacheSize","cacheMaxMemorySize","flushToDisk","CurCacheHandler","incrementalCacheHandler","getPrerenderManifest","getResponseCache","hasPage","page","getBuildId","buildId","getEnabledDirectories","app","pagesType","pages","getPagesManifest","getAppPathsManifest","attachRequestMeta","version","routes","dynamicRoutes","notFoundRoutes","preview","getNextFontManifest","nextFontManifest","renderHTML","renderToHTML","disableOptimizedLoading","runtime","undefined","sendRenderResult","_req","setHeader","poweredByHeader","type","getHeader","result","contentType","promise","isDynamic","pipeTo","transformStream","writable","payload","toUnchunkedString","String","generateEtags","body","send","findPageComponents","url","_url","loadComponent","components","runApi","handleApiRequest","loadEnvConfig","getPublicDir","getHasStaticDir","getFontManifest","handleCompression","handleUpgrade","getFallbackErrorComponents","getRoutesManifest","getMiddleware","Promise","resolve","getFilesystemPaths","Set","getinterceptionRoutePatterns","interceptionRouteRewrites","map","rewrite","RegExp","regex","loadInstrumentationModule","instrumentationOnRequestError","args","process","env","NODE_ENV","__next_log_error__","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6120, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(new HangingPromiseRejectionError(expression))\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"names":["isHangingPromiseRejectionError","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","expression","makeHangingPromise","signal","hangingPromise","Promise","_","reject","addEventListener","once","catch","ignoreReject"],"mappings":";;;;AAAO,SAASA,+BACdC,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YAA4BC,UAAkB,CAAE;QAC9C,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,qJAAqJ,CAAC,GAAA,IAAA,CAFnRA,UAAAA,GAAAA,YAAAA,IAAAA,CAFZL,MAAAA,GAASC;IAMzB;AACF;AASO,SAASK,mBACdC,MAAmB,EACnBF,UAAkB;IAElB,MAAMG,iBAAiB,IAAIC,QAAW,CAACC,GAAGC;QACxCJ,OAAOK,gBAAgB,CACrB,SACA;YACED,OAAO,IAAIT,6BAA6BG;QAC1C,GACA;YAAEQ,MAAM;QAAK;IAEjB;IACA,2GAA2G;IAC3G,6GAA6G;IAC7G,yFAAyF;IACzFL,eAAeM,KAAK,CAACC;IACrB,OAAOP;AACT;AAEA,SAASO,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 6157, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/htmlescape.ts"],"sourcesContent":["// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\nconst ESCAPE_LOOKUP: { [match: string]: string } = {\n  '&': '\\\\u0026',\n  '>': '\\\\u003e',\n  '<': '\\\\u003c',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029',\n}\n\nexport const ESCAPE_REGEX = /[&><\\u2028\\u2029]/g\n\nexport function htmlEscapeJsonString(str: string): string {\n  return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match])\n}\n"],"names":["ESCAPE_LOOKUP","ESCAPE_REGEX","htmlEscapeJsonString","str","replace","match"],"mappings":"AAAA,iEAAiE;AACjE,uGAAuG;;;;;AAEvG,MAAMA,gBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,UAAU;IACV,UAAU;AACZ;AAEO,MAAMC,eAAe,qBAAoB;AAEzC,SAASC,qBAAqBC,GAAW;IAC9C,OAAOA,IAAIC,OAAO,CAACH,cAAc,CAACI,QAAUL,aAAa,CAACK,MAAM;AAClE","ignoreList":[0]}},
    {"offset": {"line": 6180, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<\n  Map<string, T>,\n  'entries' | 'keys' | 'size' | 'get' | 'set'\n>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * A cache store for encrypted bound args of inline server functions.\n */\nexport type EncryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * An in-memory-only cache store for decrypted bound args of inline server\n * functions.\n */\nexport type DecryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * Serialized format for \"use cache\" entries\n */\ninterface UseCacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = CacheStore<Promise<CacheEntry>>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, UseCacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Serializes UseCacheCacheStore entries into an array of key-value pairs\n * @param entries - The store entries to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function serializeUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>\n): Promise<[string, UseCacheCacheStoreSerialized][]> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value.then(async (entry) => {\n        const [left, right] = entry.value.tee()\n        entry.value = right\n\n        let binaryString: string = ''\n\n        // We want to encode the value as a string, but we aren't sure if the\n        // value is a a stream of UTF-8 bytes or not, so let's just encode it\n        // as a string using base64.\n        for await (const chunk of left) {\n          binaryString += arrayBufferToString(chunk)\n        }\n\n        return [\n          key,\n          {\n            // Encode the value as a base64 string.\n            value: btoa(binaryString),\n            tags: entry.tags,\n            stale: entry.stale,\n            timestamp: entry.timestamp,\n            expire: entry.expire,\n            revalidate: entry.revalidate,\n          },\n        ] satisfies [string, UseCacheCacheStoreSerialized]\n      })\n    })\n  )\n}\n"],"names":["arrayBufferToString","stringToUint8Array","parseUseCacheCacheStore","entries","store","Map","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","atob","close","serializeUseCacheCacheStore","all","Array","from","map","then","entry","left","right","tee","binaryString","chunk","btoa"],"mappings":";;;;AAAA,SACEA,mBAAmB,EACnBC,kBAAkB,QACb,iCAAgC;;AAmDhC,SAASC,wBACdC,OAAyD;IAEzD,MAAMC,QAAQ,IAAIC;IAElB,KAAK,MAAM,CACTC,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIT,QAAS;QACZC,MAAMS,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,EAAClB,sNAAAA,EAAmBmB,KAAKb;oBAE3C,mBAAmB;oBACnBW,WAAWG,KAAK;gBAClB;YACF;YACAb;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOR;AACT;AAOO,eAAekB,4BACpBnB,OAAwD;IAExD,OAAOW,QAAQS,GAAG,CAChBC,MAAMC,IAAI,CAACtB,SAASuB,GAAG,CAAC,CAAC,CAACpB,KAAKC,MAAM;QACnC,OAAOA,MAAMoB,IAAI,CAAC,OAAOC;YACvB,MAAM,CAACC,MAAMC,MAAM,GAAGF,MAAMrB,KAAK,CAACwB,GAAG;YACrCH,MAAMrB,KAAK,GAAGuB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,kNAAgBhC,sBAAAA,EAAoBiC;YACtC;YAEA,OAAO;gBACL3B;gBACA;oBACE,uCAAuC;oBACvCC,OAAO2B,KAAKF;oBACZxB,MAAMoB,MAAMpB,IAAI;oBAChBC,OAAOmB,MAAMnB,KAAK;oBAClBC,WAAWkB,MAAMlB,SAAS;oBAC1BC,QAAQiB,MAAMjB,MAAM;oBACpBC,YAAYgB,MAAMhB,UAAU;gBAC9B;aACD;QACH;IACF;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 6241, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  type EncryptedBoundArgsCacheStore,\n  serializeUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  type DecryptedBoundArgsCacheStore,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for encrypted bound args of inline server functions.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly encryptedBoundArgs: Omit<EncryptedBoundArgsCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. The 'set' operation is omitted to\n   * enforce immutability.\n   */\n  readonly decryptedBoundArgs: Omit<DecryptedBoundArgsCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n\n  /**\n   * A mutable Map store for encrypted bound args of inline server functions.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly encryptedBoundArgs: EncryptedBoundArgsCacheStore\n\n  /**\n   * A mutable Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. Supports both 'get' and 'set'\n   * operations to build the cache during pre-rendering.\n   */\n  readonly decryptedBoundArgs: DecryptedBoundArgsCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n    encryptedBoundArgs: {\n      [key: string]: string\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or\n * transmission. Handles 'use cache' values, fetch responses, and encrypted\n * bound args for inline server functions.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or\n * 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n): Promise<string> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`stringifyResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n      return 'null'\n    }\n\n    const json: ResumeStoreSerialized = {\n      store: {\n        fetch: Object.fromEntries(Array.from(resumeDataCache.fetch.entries())),\n        cache: Object.fromEntries(\n          await serializeUseCacheCacheStore(resumeDataCache.cache.entries())\n        ),\n        encryptedBoundArgs: Object.fromEntries(\n          Array.from(resumeDataCache.encryptedBoundArgs.entries())\n        ),\n      },\n    }\n\n    // Compress the JSON string using zlib. As the data we already want to\n    // decompress is in memory, we use the synchronous deflateSync function.\n    const { deflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    return deflateSync(JSON.stringify(json)).toString('base64')\n  }\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n    encryptedBoundArgs: new Map(),\n    decryptedBoundArgs: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCacheOrPersistedCache: PrerenderResumeDataCache | string\n): RenderResumeDataCache {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`createRenderResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n      // If the cache is already a prerender cache, we can return it directly,\n      // we're just performing a type change.\n      return prerenderResumeDataCacheOrPersistedCache\n    }\n\n    if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n      return {\n        cache: new Map(),\n        fetch: new Map(),\n        encryptedBoundArgs: new Map(),\n        decryptedBoundArgs: new Map(),\n      }\n    }\n\n    // This should be a compressed string. Let's decompress it using zlib.\n    // As the data we already want to decompress is in memory, we use the\n    // synchronous inflateSync function.\n    const { inflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    const json: ResumeStoreSerialized = JSON.parse(\n      inflateSync(\n        Buffer.from(prerenderResumeDataCacheOrPersistedCache, 'base64')\n      ).toString('utf-8')\n    )\n\n    return {\n      cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n      fetch: new Map(Object.entries(json.store.fetch)),\n      encryptedBoundArgs: new Map(\n        Object.entries(json.store.encryptedBoundArgs)\n      ),\n      decryptedBoundArgs: new Map(),\n    }\n  }\n}\n"],"names":["InvariantError","serializeUseCacheCacheStore","parseUseCacheCacheStore","stringifyResumeDataCache","resumeDataCache","process","env","NEXT_RUNTIME","fetch","size","cache","json","store","Object","fromEntries","Array","from","entries","encryptedBoundArgs","deflateSync","require","JSON","stringify","toString","createPrerenderResumeDataCache","Map","decryptedBoundArgs","createRenderResumeDataCache","prerenderResumeDataCacheOrPersistedCache","inflateSync","parse","Buffer"],"mappings":";;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAIEC,2BAA2B,EAC3BC,uBAAuB,QAElB,gBAAe;;;AA4Ff,eAAeC,yBACpBC,eAAiE;IAEjE,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,qEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAsBP;AACF;AASO,SAASwB;IACd,OAAO;QACLd,OAAO,IAAIe;QACXjB,OAAO,IAAIiB;QACXP,oBAAoB,IAAIO;QACxBC,oBAAoB,IAAID;IAC1B;AACF;AAiBO,SAASE,4BACdC,wCAA2E;IAE3E,IAAIvB,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,wEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAmCP;AACF","ignoreList":[0]}},
    {"offset": {"line": 6286, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<\n  Map<string, T>,\n  'entries' | 'keys' | 'size' | 'get' | 'set'\n>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * A cache store for encrypted bound args of inline server functions.\n */\nexport type EncryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * An in-memory-only cache store for decrypted bound args of inline server\n * functions.\n */\nexport type DecryptedBoundArgsCacheStore = CacheStore<string>\n\n/**\n * Serialized format for \"use cache\" entries\n */\ninterface UseCacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = CacheStore<Promise<CacheEntry>>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, UseCacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Serializes UseCacheCacheStore entries into an array of key-value pairs\n * @param entries - The store entries to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function serializeUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>\n): Promise<[string, UseCacheCacheStoreSerialized][]> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value.then(async (entry) => {\n        const [left, right] = entry.value.tee()\n        entry.value = right\n\n        let binaryString: string = ''\n\n        // We want to encode the value as a string, but we aren't sure if the\n        // value is a a stream of UTF-8 bytes or not, so let's just encode it\n        // as a string using base64.\n        for await (const chunk of left) {\n          binaryString += arrayBufferToString(chunk)\n        }\n\n        return [\n          key,\n          {\n            // Encode the value as a base64 string.\n            value: btoa(binaryString),\n            tags: entry.tags,\n            stale: entry.stale,\n            timestamp: entry.timestamp,\n            expire: entry.expire,\n            revalidate: entry.revalidate,\n          },\n        ] satisfies [string, UseCacheCacheStoreSerialized]\n      })\n    })\n  )\n}\n"],"names":["arrayBufferToString","stringToUint8Array","parseUseCacheCacheStore","entries","store","Map","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","atob","close","serializeUseCacheCacheStore","all","Array","from","map","then","entry","left","right","tee","binaryString","chunk","btoa"],"mappings":";;;;AAAA,SACEA,mBAAmB,EACnBC,kBAAkB,QACb,iCAAgC;;AAmDhC,SAASC,wBACdC,OAAyD;IAEzD,MAAMC,QAAQ,IAAIC;IAElB,KAAK,MAAM,CACTC,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIT,QAAS;QACZC,MAAMS,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,EAAClB,sNAAAA,EAAmBmB,KAAKb;oBAE3C,mBAAmB;oBACnBW,WAAWG,KAAK;gBAClB;YACF;YACAb;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOR;AACT;AAOO,eAAekB,4BACpBnB,OAAwD;IAExD,OAAOW,QAAQS,GAAG,CAChBC,MAAMC,IAAI,CAACtB,SAASuB,GAAG,CAAC,CAAC,CAACpB,KAAKC,MAAM;QACnC,OAAOA,MAAMoB,IAAI,CAAC,OAAOC;YACvB,MAAM,CAACC,MAAMC,MAAM,GAAGF,MAAMrB,KAAK,CAACwB,GAAG;YACrCH,MAAMrB,KAAK,GAAGuB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,kNAAgBhC,sBAAAA,EAAoBiC;YACtC;YAEA,OAAO;gBACL3B;gBACA;oBACE,uCAAuC;oBACvCC,OAAO2B,KAAKF;oBACZxB,MAAMoB,MAAMpB,IAAI;oBAChBC,OAAOmB,MAAMnB,KAAK;oBAClBC,WAAWkB,MAAMlB,SAAS;oBAC1BC,QAAQiB,MAAMjB,MAAM;oBACpBC,YAAYgB,MAAMhB,UAAU;gBAC9B;aACD;QACH;IACF;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 6347, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  type EncryptedBoundArgsCacheStore,\n  serializeUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  type DecryptedBoundArgsCacheStore,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for encrypted bound args of inline server functions.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly encryptedBoundArgs: Omit<EncryptedBoundArgsCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. The 'set' operation is omitted to\n   * enforce immutability.\n   */\n  readonly decryptedBoundArgs: Omit<DecryptedBoundArgsCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n\n  /**\n   * A mutable Map store for encrypted bound args of inline server functions.\n   * Supports both 'get' and 'set' operations to build the cache during\n   * pre-rendering.\n   */\n  readonly encryptedBoundArgs: EncryptedBoundArgsCacheStore\n\n  /**\n   * A mutable Map store for decrypted bound args of inline server functions.\n   * This is only intended for in-memory usage during pre-rendering, and must\n   * not be persisted in the resume store. Supports both 'get' and 'set'\n   * operations to build the cache during pre-rendering.\n   */\n  readonly decryptedBoundArgs: DecryptedBoundArgsCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n    encryptedBoundArgs: {\n      [key: string]: string\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or\n * transmission. Handles 'use cache' values, fetch responses, and encrypted\n * bound args for inline server functions.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or\n * 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n): Promise<string> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`stringifyResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n      return 'null'\n    }\n\n    const json: ResumeStoreSerialized = {\n      store: {\n        fetch: Object.fromEntries(Array.from(resumeDataCache.fetch.entries())),\n        cache: Object.fromEntries(\n          await serializeUseCacheCacheStore(resumeDataCache.cache.entries())\n        ),\n        encryptedBoundArgs: Object.fromEntries(\n          Array.from(resumeDataCache.encryptedBoundArgs.entries())\n        ),\n      },\n    }\n\n    // Compress the JSON string using zlib. As the data we already want to\n    // decompress is in memory, we use the synchronous deflateSync function.\n    const { deflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    return deflateSync(JSON.stringify(json)).toString('base64')\n  }\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n    encryptedBoundArgs: new Map(),\n    decryptedBoundArgs: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCacheOrPersistedCache: PrerenderResumeDataCache | string\n): RenderResumeDataCache {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`createRenderResumeDataCache` should not be called in edge runtime.'\n    )\n  } else {\n    if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n      // If the cache is already a prerender cache, we can return it directly,\n      // we're just performing a type change.\n      return prerenderResumeDataCacheOrPersistedCache\n    }\n\n    if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n      return {\n        cache: new Map(),\n        fetch: new Map(),\n        encryptedBoundArgs: new Map(),\n        decryptedBoundArgs: new Map(),\n      }\n    }\n\n    // This should be a compressed string. Let's decompress it using zlib.\n    // As the data we already want to decompress is in memory, we use the\n    // synchronous inflateSync function.\n    const { inflateSync } = require('node:zlib') as typeof import('node:zlib')\n\n    const json: ResumeStoreSerialized = JSON.parse(\n      inflateSync(\n        Buffer.from(prerenderResumeDataCacheOrPersistedCache, 'base64')\n      ).toString('utf-8')\n    )\n\n    return {\n      cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n      fetch: new Map(Object.entries(json.store.fetch)),\n      encryptedBoundArgs: new Map(\n        Object.entries(json.store.encryptedBoundArgs)\n      ),\n      decryptedBoundArgs: new Map(),\n    }\n  }\n}\n"],"names":["InvariantError","serializeUseCacheCacheStore","parseUseCacheCacheStore","stringifyResumeDataCache","resumeDataCache","process","env","NEXT_RUNTIME","fetch","size","cache","json","store","Object","fromEntries","Array","from","entries","encryptedBoundArgs","deflateSync","require","JSON","stringify","toString","createPrerenderResumeDataCache","Map","decryptedBoundArgs","createRenderResumeDataCache","prerenderResumeDataCacheOrPersistedCache","inflateSync","parse","Buffer"],"mappings":";;;;;AAAA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAIEC,2BAA2B,EAC3BC,uBAAuB,QAElB,gBAAe;;;AA4Ff,eAAeC,yBACpBC,eAAiE;IAEjE,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,qEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAsBP;AACF;AASO,SAASwB;IACd,OAAO;QACLd,OAAO,IAAIe;QACXjB,OAAO,IAAIiB;QACXP,oBAAoB,IAAIO;QACxBC,oBAAoB,IAAID;IAC1B;AACF;AAiBO,SAASE,4BACdC,wCAA2E;IAE3E,IAAIvB,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;QACvC,MAAM,OAAA,cAEL,CAFK,uLAAIP,iBAAAA,CACR,wEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;;IAmCP;AACF","ignoreList":[0]}},
    {"offset": {"line": 6392, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["React","errorRef","current","cache","fn","logErrorOrWarn","process","env","__NEXT_DYNAMIC_IO","console","error","warn","flushCurrentErrorIfNew","key","createDedupedByCallsiteServerErrorLoggerDev","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":";;;AAAA,YAAYA,WAAW,QAAO;;AAE9B,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,6LAAOH,MAAMG,EAAK,KAAK,mMACnBH,MAAMG,EAAK,GACX,CAACC,KAA+BA;AAEtC,qEAAqE;AACrE,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,iBAAiBC,QAAQC,GAAG,CAACC,iBAAiB,GAChDC,QAAQC,KAAK,gCACbD,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBT,MAC7B,AACA,CAACU,yEADyE;IAExE,IAAI;QACFR,eAAeJ,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASY,4CACdC,UAAoC;IAEpC,OAAO,SAASC,gBAAgB,GAAGC,IAAU;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIX,QAAQC,GAAG,CAACY,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DpB,eAAea;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAML,MAAMO,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBN,uBAAuBC;YACzB;QACF,OAAO;;QAEP;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 6444, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/request-meta.ts"],"sourcesContent":["/* eslint-disable no-redeclare */\nimport type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type { ServerComponentsHmrCache } from './response-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: any\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * Equals the segment path that was used for the prefetch RSC request.\n   */\n  segmentPrefetchRSCRequest?: string\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * True when the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  isNextDataReq?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntry?: (\n    cacheEntry: any,\n    requestMeta: any\n  ) => Promise<boolean | void> | boolean | void\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * In development, the original source page that returned a 404.\n   */\n  developmentNotFoundSourcePage?: string\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the default route matches were set on the request during routing.\n   */\n  didSetDefaultRouteMatches?: boolean\n\n  /**\n   * Whether the request is for the custom error page.\n   */\n  customErrorRender?: true\n\n  /**\n   * Whether to bubble up the NoFallbackError to the caller when a 404 is\n   * returned.\n   */\n  bubbleNoFallback?: true\n\n  /**\n   * True when the request had locale information inferred from the default\n   * locale.\n   */\n  localeInferredFromDefault?: true\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   */\n  locale?: string\n\n  /**\n   * The default locale that was inferred or explicitly set for the request.\n   */\n  defaultLocale?: string\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  /**\n   * The `_rsc` query parameter used for cache busting to ensure that the RSC\n   * requests do not get cached by the browser explicitly.\n   */\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery &\n  NextQueryMetadata & {\n    amp?: '1'\n  }\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta"],"mappings":"AAAA,+BAA+B,GAU/B,kGAAkG;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAgM/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC","ignoreList":[0]}},
    {"offset": {"line": 6477, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/client-component-renderer-logger.ts"],"sourcesContent":["import type { AppPageModule } from './route-modules/app-page/module'\n\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(\n  ComponentMod: AppPageModule\n): AppPageModule['__next_app__'] {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args) => {\n      const startTime = performance.now()\n      const result = ComponentMod.__next_app__.loadChunk(...args)\n      // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n      // We only need to know when it's settled.\n      result.finally(() => {\n        clientComponentLoadTimes += performance.now() - startTime\n      })\n      return result\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","result","finally","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":"AAEA,oDAAoD;;;;;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BACdC,YAA2B;IAE3B,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,MAAME,SAAST,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YACtD,gHAAgH;YAChH,0CAA0C;YAC1CK,OAAOC,OAAO,CAAC;gBACbb,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;YACA,OAAOI;QACT;IACF;AACF;AAEO,SAASE,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJjB,6BAA6B,IACzBkB,YACA;QACElB;QACAC;QACAC;IACF;IAEN,IAAIc,QAAQG,KAAK,EAAE;QACjBnB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOe;AACT","ignoreList":[0]}},
    {"offset": {"line": 6533, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6664, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { CacheControl } from './lib/cache-control'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToBuffer,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'\n\ntype ContentTypeOption = string | undefined\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  cacheControl?: CacheControl\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentData?: Map<string, Buffer>\n\n  /**\n   * In development, the cache is warmed up before the render. This is attached\n   * to the metadata so that it can be used during the render.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  cacheControl?: CacheControl\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType?: ContentTypeOption\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(value: string | Buffer) {\n    return new RenderResult<StaticRenderResultMetadata>(value, { metadata: {} })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  public toUnchunkedBuffer(stream?: false): Buffer\n  public toUnchunkedBuffer(stream: true): Promise<Buffer>\n  public toUnchunkedBuffer(stream = false): Promise<Buffer> | Buffer {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToBuffer(this.readable)\n    }\n\n    return Buffer.from(this.response)\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns the response if it is a stream, or throws an error if it is a\n   * string.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be streamed')\n    }\n    if (typeof this.response === 'string') {\n      throw new Error('Invariant: static responses cannot be streamed')\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public chain(readable: ReadableStream<Uint8Array>) {\n    if (this.response === null) {\n      throw new Error('Invariant: response is null. This is a bug in Next.js')\n    }\n\n    // If the response is not an array of streams already, make it one.\n    let responses: ReadableStream<Uint8Array>[]\n    if (typeof this.response === 'string') {\n      responses = [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      responses = this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      responses = [streamFromBuffer(this.response)]\n    } else {\n      responses = [this.response]\n    }\n\n    // Add the new stream to the array.\n    responses.push(readable)\n\n    // Update the response.\n    this.response = responses\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToBuffer","streamToString","isAbortError","pipeToNodeResponse","RenderResult","fromStatic","value","metadata","constructor","response","contentType","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedBuffer","stream","Error","readable","Buffer","from","toUnchunkedString","isBuffer","Array","isArray","chain","responses","push","pipeTo","writable","preventClose","close","err","abort","res"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6858, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [NEXT_RSC_UNION_QUERY] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(url: T): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n\n  instance.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;oMAACD,uBAAAA;CAAqB;AAE5C,SAASE,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQH,qBAAsB;QACvC,OAAOE,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BAAkDC,GAAM;IACtE,MAAMC,cAAc,OAAOD,QAAQ;IACnC,MAAME,WAAWD,cAAc,IAAIE,IAAIH,OAAQA;IAE/CE,SAASE,YAAY,CAACC,MAAM,iMAACX,uBAAAA;IAE7B,OAAQO,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 6884, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(new HangingPromiseRejectionError(expression))\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"names":["isHangingPromiseRejectionError","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","expression","makeHangingPromise","signal","hangingPromise","Promise","_","reject","addEventListener","once","catch","ignoreReject"],"mappings":";;;;AAAO,SAASA,+BACdC,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YAA4BC,UAAkB,CAAE;QAC9C,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,qJAAqJ,CAAC,GAAA,IAAA,CAFnRA,UAAAA,GAAAA,YAAAA,IAAAA,CAFZL,MAAAA,GAASC;IAMzB;AACF;AASO,SAASK,mBACdC,MAAmB,EACnBF,UAAkB;IAElB,MAAMG,iBAAiB,IAAIC,QAAW,CAACC,GAAGC;QACxCJ,OAAOK,gBAAgB,CACrB,SACA;YACED,OAAO,IAAIT,6BAA6BG;QAC1C,GACA;YAAEQ,MAAM;QAAK;IAEjB;IACA,2GAA2G;IAC3G,6GAA6G;IAC7G,yFAAyF;IACzFL,eAAeM,KAAK,CAACC;IACrB,OAAOP;AACT;AAEA,SAASO,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 6921, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/htmlescape.ts"],"sourcesContent":["// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\nconst ESCAPE_LOOKUP: { [match: string]: string } = {\n  '&': '\\\\u0026',\n  '>': '\\\\u003e',\n  '<': '\\\\u003c',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029',\n}\n\nexport const ESCAPE_REGEX = /[&><\\u2028\\u2029]/g\n\nexport function htmlEscapeJsonString(str: string): string {\n  return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match])\n}\n"],"names":["ESCAPE_LOOKUP","ESCAPE_REGEX","htmlEscapeJsonString","str","replace","match"],"mappings":"AAAA,iEAAiE;AACjE,uGAAuG;;;;;AAEvG,MAAMA,gBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,UAAU;IACV,UAAU;AACZ;AAEO,MAAMC,eAAe,qBAAoB;AAEzC,SAASC,qBAAqBC,GAAW;IAC9C,OAAOA,IAAIC,OAAO,CAACH,cAAc,CAACI,QAAUL,aAAa,CAACK,MAAM;AAClE","ignoreList":[0]}},
    {"offset": {"line": 6944, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0]}},
    {"offset": {"line": 6973, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/dev/hot-reloader-types.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type { UrlObject } from 'url'\nimport type { Duplex } from 'stream'\nimport type { webpack } from 'next/dist/compiled/webpack/webpack'\nimport type getBaseWebpackConfig from '../../build/webpack-config'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Project, Update as TurbopackUpdate } from '../../build/swc/types'\nimport type { VersionInfo } from './parse-version-info'\nimport type { DebugInfo } from '../../client/components/react-dev-overlay/types'\nimport type { DevIndicatorServerState } from './dev-indicator-server-state'\n\nexport const enum HMR_ACTIONS_SENT_TO_BROWSER {\n  ADDED_PAGE = 'addedPage',\n  REMOVED_PAGE = 'removedPage',\n  RELOAD_PAGE = 'reloadPage',\n  SERVER_COMPONENT_CHANGES = 'serverComponentChanges',\n  MIDDLEWARE_CHANGES = 'middlewareChanges',\n  CLIENT_CHANGES = 'clientChanges',\n  SERVER_ONLY_CHANGES = 'serverOnlyChanges',\n  SYNC = 'sync',\n  BUILT = 'built',\n  BUILDING = 'building',\n  DEV_PAGES_MANIFEST_UPDATE = 'devPagesManifestUpdate',\n  TURBOPACK_MESSAGE = 'turbopack-message',\n  SERVER_ERROR = 'serverError',\n  TURBOPACK_CONNECTED = 'turbopack-connected',\n  ISR_MANIFEST = 'isrManifest',\n  DEV_INDICATOR = 'devIndicator',\n}\n\ninterface ServerErrorAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR\n  errorJSON: string\n}\n\nexport interface TurbopackMessageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE\n  data: TurbopackUpdate | TurbopackUpdate[]\n}\n\ninterface BuildingAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILDING\n}\n\nexport interface CompilationError {\n  moduleName?: string\n  message: string\n  details?: string\n  moduleTrace?: Array<{ moduleName?: string }>\n  stack?: string\n}\nexport interface SyncAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SYNC\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  versionInfo: VersionInfo\n  updatedModules?: ReadonlyArray<string>\n  debug?: DebugInfo\n  devIndicator: DevIndicatorServerState\n}\ninterface BuiltAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILT\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  updatedModules?: ReadonlyArray<string>\n}\n\ninterface AddedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE\n  data: [page: string | null]\n}\n\ninterface RemovedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE\n  data: [page: string | null]\n}\n\nexport interface ReloadPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE\n  data: string\n}\n\ninterface ServerComponentChangesAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES\n  hash: string\n}\n\ninterface MiddlewareChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n}\n\ninterface ClientChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n}\n\ninterface ServerOnlyChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES\n  pages: ReadonlyArray<string>\n}\n\ninterface DevPagesManifestUpdateAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE\n  data: [\n    {\n      devPagesManifest: true\n    },\n  ]\n}\n\nexport interface TurbopackConnectedAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n  data: { sessionId: number }\n}\n\nexport interface AppIsrManifestAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST\n  data: Record<string, boolean>\n}\n\nexport interface DevIndicatorAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_INDICATOR\n  devIndicator: DevIndicatorServerState\n}\n\nexport type HMR_ACTION_TYPES =\n  | TurbopackMessageAction\n  | TurbopackConnectedAction\n  | BuildingAction\n  | SyncAction\n  | BuiltAction\n  | AddedPageAction\n  | RemovedPageAction\n  | ReloadPageAction\n  | ServerComponentChangesAction\n  | ClientChangesAction\n  | MiddlewareChangesAction\n  | ServerOnlyChangesAction\n  | DevPagesManifestUpdateAction\n  | ServerErrorAction\n  | AppIsrManifestAction\n  | DevIndicatorAction\n\nexport type TurbopackMsgToBrowser =\n  | { type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE; data: any }\n  | {\n      type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n      data: { sessionId: number }\n    }\n\nexport interface NextJsHotReloaderInterface {\n  turbopackProject?: Project\n  activeWebpackConfigs?: Array<Awaited<ReturnType<typeof getBaseWebpackConfig>>>\n  serverStats: webpack.Stats | null\n  edgeServerStats: webpack.Stats | null\n  run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }>\n\n  setHmrServerError(error: Error | null): void\n  clearHmrServerError(): void\n  start(): Promise<void>\n  send(action: HMR_ACTION_TYPES): void\n  getCompilationErrors(page: string): Promise<any[]>\n  onHMR(\n    req: IncomingMessage,\n    _socket: Duplex,\n    head: Buffer,\n    onUpgrade: (client: { send(data: string): void }) => void\n  ): void\n  invalidate({\n    reloadAfterInvalidation,\n  }: {\n    reloadAfterInvalidation: boolean\n  }): Promise<void> | void\n  buildFallbackError(): Promise<void>\n  ensurePage({\n    page,\n    clientOnly,\n    appPaths,\n    definition,\n    isApp,\n    url,\n  }: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    isApp?: boolean\n    definition: RouteDefinition | undefined\n    url?: string\n  }): Promise<void>\n  close(): void\n}\n"],"names":["HMR_ACTIONS_SENT_TO_BROWSER"],"mappings":";;;AAWO,IAAWA,8BAAAA,WAAAA,GAAAA,SAAAA,2BAAAA;;;;;;;;;;;;;;;;;WAAAA;MAiBjB","ignoreList":[0]}},
    {"offset": {"line": 7001, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/server/dev/extract-modules-from-turbopack-message.ts"],"sourcesContent":["import type { Update as TurbopackUpdate } from '../../build/swc/types'\n\nexport function extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n): Set<string> {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+\\[.*/.exec(name)\n        if (res === null) {\n          console.error(\n            '[Turbopack HMR] Expected module to match pattern: ' + name\n          )\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return updatedModules\n}\n"],"names":["extractModulesFromTurbopackMessage","data","updatedModules","Set","updates","Array","isArray","update","type","instruction","merged","undefined","mergedUpdate","name","Object","keys","entries","res","exec","console","error","add"],"mappings":";;;AAEO,SAASA,mCACdC,IAAyC;IAEzC,MAAMC,iBAA8B,IAAIC;IAExC,MAAMC,UAAUC,MAAMC,OAAO,CAACL,QAAQA,OAAO;QAACA;KAAK;IACnD,KAAK,MAAMM,UAAUH,QAAS;QAC5B,sFAAsF;QACtF,IACEG,OAAOC,IAAI,KAAK,aAChBD,OAAOE,WAAW,CAACD,IAAI,KAAK,qBAC5BD,OAAOE,WAAW,CAACC,MAAM,KAAKC,WAC9B;YACA;QACF;QAEA,KAAK,MAAMC,gBAAgBL,OAAOE,WAAW,CAACC,MAAM,CAAE;YACpD,KAAK,MAAMG,QAAQC,OAAOC,IAAI,CAACH,aAAaI,OAAO,EAAG;gBACpD,MAAMC,MAAM,cAAcC,IAAI,CAACL;gBAC/B,IAAII,QAAQ,MAAM;oBAChBE,QAAQC,KAAK,CACX,uDAAuDP;oBAEzD;gBACF;gBAEAX,eAAemB,GAAG,CAACJ,GAAG,CAAC,EAAE;YAC3B;QACF;IACF;IAEA,OAAOf;AACT","ignoreList":[0]}}]
}